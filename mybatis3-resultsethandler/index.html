<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Mybatis3源码分析之ResultSetHandler | Java技术天地</title><meta name="description" content="Mybatis3源码分析之ResultSetHandler"><meta name="keywords" content="MyBatis3源码解析"><meta name="author" content="Java技术天地"><meta name="copyright" content="Java技术天地"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon-32x32.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://hm.baidu.com"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Mybatis3源码分析之ResultSetHandler"><meta name="twitter:description" content="Mybatis3源码分析之ResultSetHandler"><meta name="twitter:image" content="https://www.zzwzdx.cn/img/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="Mybatis3源码分析之ResultSetHandler"><meta property="og:url" content="https://www.zzwzdx.cn/mybatis3-resultsethandler/"><meta property="og:site_name" content="Java技术天地"><meta property="og:description" content="Mybatis3源码分析之ResultSetHandler"><meta property="og:image" content="https://www.zzwzdx.cn/img/avatar.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode="1",t=Cookies.get("theme");if("1"==autoChangeMode){var isDarkMode=window.matchMedia("(prefers-color-scheme: dark)").matches,isLightMode=window.matchMedia("(prefers-color-scheme: light)").matches,isNotSpecified=window.matchMedia("(prefers-color-scheme: no-preference)").matches,hasNoSupport=!isDarkMode&&!isLightMode&&!isNotSpecified;if(void 0===t){if(isLightMode)activateLightMode();else if(isDarkMode)activateDarkMode();else if(isNotSpecified||hasNoSupport){console.log("You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.");var now=new Date,hour=now.getHours(),isNight=hour<6||18<=hour;isNight?activateDarkMode():activateLightMode()}}else"light"==t?activateLightMode():activateDarkMode()}else"2"==autoChangeMode?(isNight=(hour=(now=new Date).getHours())<6||18<=hour,void 0===t?isNight?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode()):"dark"==t?activateDarkMode():"light"==t&&activateLightMode();function activateDarkMode(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#000")}function activateLightMode(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#fff")}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://www.zzwzdx.cn/mybatis3-resultsethandler/"><link rel="prev" title="Mybatis3源码分析之缓存的实现" href="https://www.zzwzdx.cn/mybatis3-cache-implementation/"><link rel="next" title="Mybatis3源码分析之Statement初始化和参数设置" href="https://www.zzwzdx.cn/mybatis3-statement-initialization/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6cdf806ea3d36641644ddfae3f9e80cb";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},translate:{defaultEncoding:2,translateDelay:0,cookieDomain:"https://www.zzwzdx.cn/",msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},bookmark:{message_prev:"按",message_next:"键将本页加入书签"},runtime_unit:"天",runtime:!0,copyright:{languages:{author:"作者: Java技术天地",link:"链接: ",source:"来源: Java技术天地",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},ClickShowText:void 0,medium_zoom:!1,fancybox:!0,Snackbar:{bookmark:{message_prev:"按",message_next:"键将本页加入书签"},chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#2d3035",position:"top-center"},baiduPush:!1,highlightCopy:!0,highlightLang:!0,highlightShrink:"false",isFontAwesomeV5:!1,isPhotoFigcaption:!1}</script><script>var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isSidebar:!1}</script><noscript><style>#page-header{opacity:1}.justified-gallery img{opacity:1}</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">65</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/" aria-current="page"><i class="fa-fw fa fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/juc/" aria-current="page"><i class="fa-fw fa fa-lock"></i> <span>Java并发</span></a></div><div class="menus_item"><a class="site-page" href="/spring-ioc/" aria-current="page"><i class="fa-fw fa fa-eercast"></i> <span>Spring IOC专题</span></a></div><div class="menus_item"><a class="site-page" href="/dp/" aria-current="page"><i class="fa-fw fa fa-ge"></i> <span>设计模式</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-meetup" aria-hidden="true"></i> <span>Mybatis教程</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/mybatis3/"><i class="fa-fw fa fa-anchor"></i> <span>Mybatis基础教程</span></a></li><li><a class="site-page" href="/mybatis3-source/"><i class="fa-fw fa fa-asterisk"></i> <span>Mybatis源码分析</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/" aria-current="page"><i class="fa-fw fa fa-archive"></i> <span>归档</span></a></div></div></div></div><div class="main-bg" id="body-wrap"><div class="post-bg" id="nav"><div id="page-header"><a class="pull_left" id="blog_name" href="/"><i class="logo"></i><span class="blog_title" id="site-name">Java技术天地</span></a><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/" aria-current="page"><i class="fa-fw fa fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/juc/" aria-current="page"><i class="fa-fw fa fa-lock"></i> <span>Java并发</span></a></div><div class="menus_item"><a class="site-page" href="/spring-ioc/" aria-current="page"><i class="fa-fw fa fa-eercast"></i> <span>Spring IOC专题</span></a></div><div class="menus_item"><a class="site-page" href="/dp/" aria-current="page"><i class="fa-fw fa fa-ge"></i> <span>设计模式</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-meetup" aria-hidden="true"></i> <span>Mybatis教程</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/mybatis3/"><i class="fa-fw fa fa-anchor"></i> <span>Mybatis基础教程</span></a></li><li><a class="site-page" href="/mybatis3-source/"><i class="fa-fw fa fa-asterisk"></i> <span>Mybatis源码分析</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/" aria-current="page"><i class="fa-fw fa fa-archive"></i> <span>归档</span></a></div></div><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i></a></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="post-info"><div id="post-title"><div class="posttitle">Mybatis3源码分析之ResultSetHandler</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date" title="发表于 2021-05-11 15:10:47"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-05-11</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/MyBatis3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank">MyBatis3源码解析</a></span><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/mybatis3-resultsethandler/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div><div id="article-container"><p>在PreparedStatementHandler中的query()方法中，是用ResultSetHandler来完成结果集的映射的。</p><pre><code>public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
   PreparedStatement ps = (PreparedStatement) statement;
   ps.execute();
   return resultSetHandler.&lt;E&gt; handleResultSets(ps);
 }</code></pre><p>Mybatis中只提供了一个ResultSetHandler的实现，那就是DefaultResultSetHandler。下面来看看他的handleResultSets()方法</p><pre><code>public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException {
    final List&lt;Object&gt; multipleResults = new ArrayList&lt;Object&gt;();

    int resultSetCount = 0;
    //获取第一个ResultSet,通常只会有一个
    ResultSetWrapper rsw = getFirstResultSet(stmt);
    //从配置中读取对应的ResultMap，通常也只会有一个
    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();
    int resultMapCount = resultMaps.size();
    validateResultMapsCount(rsw, resultMapCount);
    while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) {
      ResultMap resultMap = resultMaps.get(resultSetCount);
      //完成映射，将结果加到入multipleResults中
      handleResultSet(rsw, resultMap, multipleResults, null);
      rsw = getNextResultSet(stmt);
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }

    String[] resultSets = mappedStatement.getResulSets();
    if (resultSets != null) {
      while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) {
        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
        if (parentMapping != null) {
          String nestedResultMapId = parentMapping.getNestedResultMapId();
          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
          handleResultSet(rsw, resultMap, null, parentMapping);
        }
        rsw = getNextResultSet(stmt);
        cleanUpAfterHandlingResultSet();
        resultSetCount++;
      }
    }
    //如果只有一个映射，返回第一个
    return collapseSingleResultList(multipleResults);
  }</code></pre><p>在实际运行过程中，通常情况下一个Sql语句只返回一个结果集，对多个结果集的情况不做分析 。实际很少用到。</p><p>继续看handleResultSet方法</p><pre><code>private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException {
    try {
      if (parentMapping != null) {
        //子映射
        handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);
      } else {
        //一般情况resultHandler都为空,见ResultHandler.NO_RESULT_HANDLER
        if (resultHandler == null) {
          DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory);
          //生成对象，并加到defaultResultHandler.resultList集合中
          handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);
          //将结果加入multipleResults中
          multipleResults.add(defaultResultHandler.getResultList());
        } else {
          handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);
        }
      }
    } finally {
      //关闭结果集
      closeResultSet(rsw.getResultSet()); // issue #228 (close resultsets)
    }
  }



private void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException {
    if (resultMap.hasNestedResultMaps()) {
      //有子映射或内映射的情况
      ensureNoRowBounds();
      checkResultHandler();
      handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);
    } else {
      //没有子映射或内映射
      handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);
    }
  }  </code></pre><p>简单映射handleRowValuesForSimpleResultMap</p><p>========================================</p><pre><code>private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping)
      throws SQLException {
    DefaultResultContext resultContext = new DefaultResultContext();
    skipRows(rsw.getResultSet(), rowBounds);
    while (shouldProcessMoreRows(rsw.getResultSet(), resultContext, rowBounds)) {
      //discriminator的处理,可以根据条件选择不同的映射
      ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null);
      //真正从ResultSet中映射出一个对象
      Object rowValue = getRowValue(rsw, discriminatedResultMap);
      //加入resultHandler.resultList中
      storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());
    }
  }

   //没有内映射
   private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap) throws SQLException {
    final ResultLoaderMap lazyLoader = new ResultLoaderMap();
    //实例化一个对象,类型为resultMap.getType(),最终调用了ObjectFactory.create()方法
    Object resultObject = createResultObject(rsw, resultMap, lazyLoader, null);
    if (resultObject != null &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) {
      //设置对象属性
      final MetaObject metaObject = configuration.newMetaObject(resultObject);
      boolean foundValues = resultMap.getConstructorResultMappings().size() &gt; 0;
      if (shouldApplyAutomaticMappings(resultMap, !AutoMappingBehavior.NONE.equals(configuration.getAutoMappingBehavior()))) { 
        //自动映射,结果集中有的column，但resultMap中并没有配置   
        foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, null) || foundValues;
      }
      //映射result节点
      foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, null) || foundValues;
      foundValues = lazyLoader.size() &gt; 0 || foundValues;
      resultObject = foundValues ? resultObject : null;
      return resultObject;
    }
    return resultObject;
  }</code></pre><p>以上代码开始总结出简单映射(没有内映射)的逻辑</p><ol><li>每条结果都会生成一个java对象</li><li>根据构造方法实例化对象</li><li>自动映射(结果集有但在resultMap里没有配置的字段)，有两情况会发生自动映射<ol><li>在resultMap上配置了autoMapping=”true”属性</li><li>在mybatis-config.xml配置了autoMappingBehavior=”PARTIAL|FULL”，默认为PARTIAL。<br>在实际应用中，都会使用自动映射，减少配置的工作。自动映射在Mybatis中也是默认开启的。</li></ol></li><li>最后再映射属性。</li></ol><h2 id="根据构造方法实例化对象"><a href="#根据构造方法实例化对象" class="headerlink" title="根据构造方法实例化对象"></a>根据构造方法实例化对象</h2><pre><code>&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException {
    //构造方法中的参数类型
    final List&lt;Class&lt;?&gt;&gt; constructorArgTypes = new ArrayList&lt;Class&lt;?&gt;&gt;();
    //构造方法中具体值
    final List&lt;Object&gt; constructorArgs = new ArrayList&lt;Object&gt;();
    //根据构造方法生成对象
    final Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);
    if (resultObject != null &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) {
      final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();
      for (ResultMapping propertyMapping : propertyMappings) {
        if (propertyMapping.getNestedQueryId() != null &amp;&amp; propertyMapping.isLazy()) { // issue gcode #109 &amp;&amp; issue #149
          return configuration.getProxyFactory().createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);
        }
      }
    }
    return resultObject;
  }

  private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix)
      throws SQLException {
    final Class&lt;?&gt; resultType = resultMap.getType();
    //resultMap配置中的construnctor节点
    final List&lt;ResultMapping&gt; constructorMappings = resultMap.getConstructorResultMappings();
    if (typeHandlerRegistry.hasTypeHandler(resultType)) {
      return createPrimitiveResultObject(rsw, resultMap, columnPrefix);
    } else if (constructorMappings.size() &gt; 0) {
      //construnctor节点有配置
      return createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix);
    } else {
     //construnctor节点没有配置，调用无参的构造方法
      return objectFactory.create(resultType);
    }
  }

  private Object createParameterizedResultObject(ResultSetWrapper rsw, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; constructorMappings, List&lt;Class&lt;?&gt;&gt; constructorArgTypes,
      List&lt;Object&gt; constructorArgs, String columnPrefix) throws SQLException {
    boolean foundValues = false;
    for (ResultMapping constructorMapping : constructorMappings) {
      final Class&lt;?&gt; parameterType = constructorMapping.getJavaType();
      final String column = constructorMapping.getColumn();
      final Object value; 
     //取出参数类型和具体的值
      if (constructorMapping.getNestedQueryId() != null) {
        value = getNestedQueryConstructorValue(rsw.getResultSet(), constructorMapping, columnPrefix);
      } else if (constructorMapping.getNestedResultMapId() != null) {
        final ResultMap resultMap = configuration.getResultMap(constructorMapping.getNestedResultMapId());
        value = getRowValue(rsw, resultMap);
      } else {
        final TypeHandler&lt;?&gt; typeHandler = constructorMapping.getTypeHandler();
        value = typeHandler.getResult(rsw.getResultSet(), prependPrefix(column, columnPrefix));
      }
      constructorArgTypes.add(parameterType);
      constructorArgs.add(value);
      foundValues = value != null || foundValues;
    }
     //创建对象
    return foundValues ? objectFactory.create(resultType, constructorArgTypes, constructorArgs) : null;
  }</code></pre><h2 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h2><pre><code>private boolean applyAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix) throws SQLException {
  //获取结果集中在resultMap中没有配置的列名
  //如果resultMap中只设置了resultType=&quot;java.util.HashMap&quot;的话，全都会在这里完成映射
  final List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);
  boolean foundValues = false;
  for (String columnName : unmappedColumnNames) {
    //属性名就是列名
    String propertyName = columnName;
    if (columnPrefix != null &amp;&amp; columnPrefix.length() &gt; 0) {
      // When columnPrefix is specified,
      // ignore columns without the prefix.
      if (columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) {
        propertyName = columnName.substring(columnPrefix.length());
      } else {
        continue;
      }
    }
    //是否有对应的属性
    final String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase());
    //是否有对应的set方法
    if (property != null &amp;&amp; metaObject.hasSetter(property)) {
      final Class&lt;?&gt; propertyType = metaObject.getSetterType(property);
      if (typeHandlerRegistry.hasTypeHandler(propertyType)) {
        final TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName);
        final Object value = typeHandler.getResult(rsw.getResultSet(), columnName);
        if (value != null || configuration.isCallSettersOnNulls()) { // issue #377, call setter on nulls
          if (value != null || !propertyType.isPrimitive()) {
            //直接设置
            metaObject.setValue(property, value);
          }
          foundValues = true;
        }
      }
    }
  }
  return foundValues;
}</code></pre><h2 id="映射result节点"><a href="#映射result节点" class="headerlink" title="映射result节点"></a>映射result节点</h2><pre><code>private boolean applyPropertyMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, ResultLoaderMap lazyLoader, String columnPrefix)
     throws SQLException {
   final List&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);
   boolean foundValues = false;
   //获取需要映射的ResultMapping
   final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();
   for (ResultMapping propertyMapping : propertyMappings) {
     final String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);
     if (propertyMapping.isCompositeResult() 
         || (column != null &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH))) 
         || propertyMapping.getResultSet() != null) {
       //在结果中的获取对应的值
       Object value = getPropertyMappingValue(rsw.getResultSet(), metaObject, propertyMapping, lazyLoader, columnPrefix);
       final String property = propertyMapping.getProperty(); // issue #541 make property optional
       if (value != NO_VALUE &amp;&amp; property != null &amp;&amp; (value != null || configuration.isCallSettersOnNulls())) { // issue #377, call setter on nulls
         if (value != null || !metaObject.getSetterType(property).isPrimitive()) {
           //设置属性
           metaObject.setValue(property, value);
         }
         foundValues = true;
       }
     }
   }
   return foundValues;
 }



private Object getPropertyMappingValue(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)
     throws SQLException {
   if (propertyMapping.getNestedQueryId() != null) {
     //子查询，这里就是会产生N+1次查询的地方，每个记录都会再执行一个子查询。子查询的过程这里就不在讨论了。
     return getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);
   } else if (propertyMapping.getResultSet() != null) {
     addPendingChildRelation(rs, metaResultObject, propertyMapping);
     return NO_VALUE;
   } else if (propertyMapping.getNestedResultMapId() != null) {
     // the user added a column attribute to a nested result map, ignore it
     return NO_VALUE;
   } else {
     final TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();
     final String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);
     //直接从结果集里获取。
     return typeHandler.getResult(rs, column);
   }
 }</code></pre><h1 id="复杂映射-内映射-handleRowValuesForNestedResultMap"><a href="#复杂映射-内映射-handleRowValuesForNestedResultMap" class="headerlink" title="复杂映射(内映射)handleRowValuesForNestedResultMap"></a>复杂映射(内映射)handleRowValuesForNestedResultMap</h1><p>处理这种映射的逻辑比较复杂。这里先举例说明:</p><p>配置如下resultMap</p><pre><code>&lt;resultMap type=&quot;com.ashan.mybatis.User&quot; id=&quot;detailUserResultMap&quot;&gt;&lt;!-- 整个resultMap会被解析成一个ResultMap对应 --&gt;
        &lt;constructor&gt;
            &lt;idArg column=&quot;user_id&quot; javaType=&quot;String&quot;/&gt;&lt;!-- idArg会被解析成一个resultMapping对象 --&gt;
            &lt;arg column=&quot;user_name&quot; javaType=&quot;String&quot;/&gt;&lt;!-- resultMapping对象 --&gt;
        &lt;/constructor&gt;

        &lt;result property=&quot;svcnum&quot; column=&quot;svc_num&quot; /&gt; &lt;!-- resultMapping对象 --&gt;

        &lt;association property=&quot;cust&quot; javaType=&quot;com.ashan.mybatis.Cust&quot;&gt; &lt;!-- resultMapping对象 这个resultMapping对象指向了另一个ResultMap--&gt;
            &lt;id property=&quot;id&quot; column=&quot;cust_id&quot;/&gt;
            &lt;result property=&quot;custname&quot; column=&quot;cust_name&quot;/&gt;
            &lt;result property=&quot;certNo&quot; column=&quot;cert_no&quot;/&gt;
        &lt;/association&gt;

        &lt;collection property=&quot;accts&quot; ofType=&quot;com.ashan.mybatis.Acct&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;acct_id&quot; /&gt;
            &lt;result property=&quot;payName&quot; column=&quot;pay_name&quot;/&gt;
            &lt;result property=&quot;bankNo&quot; column=&quot;bank_no&quot;/&gt;
        &lt;/collection&gt;

    &lt;/resultMap&gt;</code></pre><p>假设需要映射的结果集:</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151223232813379" alt><br>可以看出，这个结果集将最终会映射成两个对象User对象，两个User对象对应的Cust对应都是cust_01，id为user_01对应的accts为：acct_01,acct_02,acct_04;user_02对应的acct只有一个acct_03。</p><h2 id="User对象映射过程"><a href="#User对象映射过程" class="headerlink" title="User对象映射过程"></a>User对象映射过程</h2><p>下面来看Mybatis是怎么生成这两个User对象的。</p><pre><code>private void handleRowValuesForNestedResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException {
    final DefaultResultContext resultContext = new DefaultResultContext();
    skipRows(rsw.getResultSet(), rowBounds);
    Object rowValue = null;
    while (shouldProcessMoreRows(rsw.getResultSet(), resultContext, rowBounds)) {

      //开始处理一行新的结果集记录      
      final ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null);

      //为这行记录生成一个key,createRowKey方法会利用idResultMapping(即idArg,和id节点)和resultMap的id来生成key
      //例子中第1、2、4条记录生成的key都是一样的,大概内容为detailUserResultMap:user_01
      //第3条记录生成的key大概内容为detailUserResultMap:user_02
      final CacheKey rowKey = createRowKey(discriminatedResultMap, rsw, null);
      //nestedResultObjects是一个HashMap对象，在映射过程中所有生成的映射对象(包括内映射对象)，都会生成一个key并保存在这里。
      //例子中生成映射对象有三类：User,Cust,Acct

      Object partialObject = nestedResultObjects.get(rowKey);
      //如果是处理第1、3条记录，这里的parialObject为null值
      //如果是处理第2、4条记录，这里的parialObject不为null
      //
      if (mappedStatement.isResultOrdered()) { // issue #577 &amp;&amp; #542
        //先不讨论
        if (partialObject == null &amp;&amp; rowValue != null) {
          nestedResultObjects.clear();
          storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());
        }
        rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, rowKey, null, partialObject);
      } else {
        //这个方法把结果集的记录映射成java对象
        //处理第一条记录时，rowValue是新生成的User对象(user_01)其中属性cust为cust_01,accts里只有一个acct_01
        //处理第二条记录时，rowValue对象就是第一条记录生成里的User对象，不过这时accts里多了一条acct_02
        //处理第三条记录时，rowValue为新生成的User对象(user_02)，cust属性为cust_01,accts只有一个acct_03
        //处理第四条记录时，rowValue对象就是第一条记录生成里的User对象，这时accts里又多了一条acct_04
        rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, rowKey, null, partialObject);
        //只有第一条记录和第三条记录partialObject才会为null
        if (partialObject == null) {
          //把User对象加入到resultHandler.resultList中，这里也可以看出，虽然有四条记录，但只会被映射成两个User对象
          storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());
        }
      }
    }
    if (rowValue != null &amp;&amp; mappedStatement.isResultOrdered()) {
      storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());
    }
  }</code></pre><p>接下来继续看User对象的生成过程</p><pre><code>private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, CacheKey combinedKey, CacheKey absoluteKey, String columnPrefix, Object partialObject) throws SQLException {
   final String resultMapId = resultMap.getId();
   Object resultObject = partialObject;
   //第一和第三条记录时，partialObject为null, resultObject也为null
   if (resultObject != null) {
     //处理第二、四条记录里会执行这里
     final MetaObject metaObject = configuration.newMetaObject(resultObject);
     putAncestor(absoluteKey, resultObject, resultMapId, columnPrefix);
     //直接调用内映射，即设置处理cust和accts，例子中主要是加入一个acct,因为cust只有一个，在user对象创建里就会被创建
     applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, false);
     ancestorObjects.remove(absoluteKey);
   } else {
     //处理第一、三条记录里会执行这里,说明需要创建一个新的User对象
     final ResultLoaderMap lazyLoader = new ResultLoaderMap();
     //创建一个user对象，跟简单映射的处理方式一样
     resultObject = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);
     if (resultObject != null &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) {
       final MetaObject metaObject = configuration.newMetaObject(resultObject);
       boolean foundValues = resultMap.getConstructorResultMappings().size() &gt; 0;
       if (shouldApplyAutomaticMappings(resultMap, AutoMappingBehavior.FULL.equals(configuration.getAutoMappingBehavior()))) {
         //自动映射，跟简单映射的处理方式一样,跟简单映射的处理方式一样,例子中不会执行这一步
         foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;
       }   
       //映射reulst节点，跟简单映射的处理方式一样,跟简单映射的处理方式一样 ,例子中主要映射svc_num    
       foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;
       putAncestor(absoluteKey, resultObject, resultMapId, columnPrefix);
       //调用内映射，即生成cust和acct对象并设置到User对象中
       foundValues = applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, true) || foundValues;
       ancestorObjects.remove(absoluteKey);
       foundValues = lazyLoader.size() &gt; 0 || foundValues;
       resultObject = foundValues ? resultObject : null;
     }
     //注意这里，生成User对象里combinedKey就是User对象的key,将新创建的两个User对象加入nestedResultObjects中，以便后续处理使用，在处理第二、四条记录里就可以使用对应的User对象了。
     if (combinedKey != CacheKey.NULL_CACHE_KEY) nestedResultObjects.put(combinedKey, resultObject);
   }
   return resultObject;
 }</code></pre><p>上面是User对象的生成过程。nestedResultObjects在处理过程的作用很重要，由这个容器来控制是否需要创建新的User对象。</p><h2 id="Cust对象映射过程"><a href="#Cust对象映射过程" class="headerlink" title="Cust对象映射过程"></a>Cust对象映射过程</h2><p>再来看Cust对象是怎么生成并加入到User对象中的</p><pre><code> //处理内映射，生成内映射对象，并加入到上层对象中。这里主要根据例子分析Cust对象的生成，上层对象为User
private boolean applyNestedResultMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String parentPrefix, CacheKey parentRowKey, boolean newObject) {
   boolean foundValues = false;
   for (ResultMapping resultMapping : resultMap.getPropertyResultMappings()) {
     final String nestedResultMapId = resultMapping.getNestedResultMapId();
     if (nestedResultMapId != null &amp;&amp; resultMapping.getResultSet() == null) {
        //resultMap中的collection,association节点都会被生成一个nestedResultMap,这里分析Cust对象，也就是association
       try {
         final String columnPrefix = getColumnPrefix(parentPrefix, resultMapping);
         //获取内映射的ResultMap
         final ResultMap nestedResultMap = getNestedResultMap(rsw.getResultSet(), nestedResultMapId, columnPrefix);
         CacheKey rowKey = null;
         Object ancestorObject = null;
         if (ancestorColumnPrefix.containsKey(nestedResultMapId)) {
           //第二、三、四记录时会执行,ancestorColumnPrefi也是一个HashMap,保存的是什么内容下面再看
           //第一条记录时，肯定不会有这个对应关系
           rowKey = createRowKey(nestedResultMap, rsw, ancestorColumnPrefix.get(nestedResultMapId));

           //这个ancestorObjects是一个HashMap跟名字一样只会保存原始对应，也就是上层对象，这里cust和acct对象是最下层的对象了。也就是说cust和acct没有内映射了
           //所以例子中ancestorObjects只会保留User对象
           ancestorObject = ancestorObjects.get(rowKey);
         }
         if (ancestorObject != null) { 
           if (newObject) metaObject.setValue(resultMapping.getProperty(), ancestorObject);
         } else {
           //映射四条记录的Cust对应都会执行这里
           //这里是生成内映射Cust的key,大概是这样的:Cust:cust_01
           rowKey = createRowKey(nestedResultMap, rsw, columnPrefix);

           //这里的combineKeys是跟上层对象组合成的一个key
           //parentRowKey为上层对象(User对象)的key,第一、二、四条记录为user_01,第三条记录为user_02
           //这样combineKey值大概为:第一、二、四条记录为user_01:cust_01,第三条记录为user_02:cust_01
           final CacheKey combinedKey = combineKeys(rowKey, parentRowKey);   

           //从nestedResultObjects获取
           //第一、三条记录rowValue是为null的,第二、四条记录与第一条记录的combinedKey一样，所以rowValue的值不一样         
           Object rowValue = nestedResultObjects.get(combinedKey);
           boolean knownValue = (rowValue != null);
           //检查要映射的对象是否为Collection类型，这里是Cust类型，collectionProperty为null
           final Object collectionProperty = instantiateCollectionPropertyIfAppropriate(resultMapping, metaObject);            
           if (anyNotNullColumnHasValue(resultMapping, columnPrefix, rsw.getResultSet())) {
             //生成Cust对象
             //注意入参的rowValue，第一、三条记录为null
             rowValue = getRowValue(rsw, nestedResultMap, combinedKey, rowKey, columnPrefix, rowValue);
             if (rowValue != null &amp;&amp; !knownValue) {
               //第一、三条记录时才会执行这里，第二、四条记录用的是第一条中的Cust对象，不用重复设置                 

               if (collectionProperty != null) {
                 //User.cust属性不是集合，不会执行这里
                 final MetaObject targetMetaObject = configuration.newMetaObject(collectionProperty);
                 targetMetaObject.add(rowValue);
               } else {
                 //将生成的Cust对象设置到User对象中
                 metaObject.setValue(resultMapping.getProperty(), rowValue);
               }
               foundValues = true;
             }
           }
         }
       } catch (SQLException e) {
         throw new ExecutorException(&quot;Error getting nested result map values for &apos;&quot; + resultMapping.getProperty() + &quot;&apos;.  Cause: &quot; + e, e);
       }
     }
   }
   return foundValues;
 }</code></pre><p>再来看getRowValue是怎么处理Cust对象的,这个getRowValue上前讲Cust对象时的代码一样的，只不过这次是对Cust对象为分析</p><pre><code>private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, CacheKey combinedKey, CacheKey absoluteKey, String columnPrefix, Object partialObject) throws SQLException {
  //partialObject，第一、三条为null,第二、四条用是的第一条里的Cust，不为null
  final String resultMapId = resultMap.getId();
  Object resultObject = partialObject;
  if (resultObject != null) {
    //第二、四条记录
    final MetaObject metaObject = configuration.newMetaObject(resultObject);
    putAncestor(absoluteKey, resultObject, resultMapId, columnPrefix);
    //这个时间只需要处理Cust里的内映射就行了，例子中Cust没有内映射，这里将什么都不会发生
    //相当对处理第二、四条记录时，这个方法什么都没做
    applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, false);
    ancestorObjects.remove(absoluteKey);
  } else {
    //第一、三条记录
    final ResultLoaderMap lazyLoader = new ResultLoaderMap();
    //实例化
    resultObject = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);
    if (resultObject != null &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) {
      final MetaObject metaObject = configuration.newMetaObject(resultObject);
      boolean foundValues = resultMap.getConstructorResultMappings().size() &gt; 0;
      if (shouldApplyAutomaticMappings(resultMap, AutoMappingBehavior.FULL.equals(configuration.getAutoMappingBehavior()))) {
        //自动映射
        foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;
      }        
      //映射result节点
      foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;
      putAncestor(absoluteKey, resultObject, resultMapId, columnPrefix);
      //内映射，例子中Cust没有内映射
      foundValues = applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, true) || foundValues;
      ancestorObjects.remove(absoluteKey);
      foundValues = lazyLoader.size() &gt; 0 || foundValues;
      resultObject = foundValues ? resultObject : null;
    }
    //将新创建的Cust对象加入nestedResultObjects中
    if (combinedKey != CacheKey.NULL_CACHE_KEY) nestedResultObjects.put(combinedKey, resultObject);
  }
  return resultObject;
}</code></pre><p>从上面的代码可以看出，虽然四条记录对应的cust_id都为cust_01，按一般的ORM映射来说，在内存中四个User对象的Cust属性应该是同一个，但在这里个例子中会生成两个Cust对象。这是因为nestedResltOjects是用CombineKey，至于为什么这样做，还不知道！</p><h2 id="Acct对象映射过程"><a href="#Acct对象映射过程" class="headerlink" title="Acct对象映射过程"></a>Acct对象映射过程</h2><p>Acct对象映射过程,还是applyNestedResultMapping方法</p><pre><code>private boolean applyNestedResultMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String parentPrefix, CacheKey parentRowKey, boolean newObject) {
    boolean foundValues = false;
    for (ResultMapping resultMapping : resultMap.getPropertyResultMappings()) {
      final String nestedResultMapId = resultMapping.getNestedResultMapId();
      if (nestedResultMapId != null &amp;&amp; resultMapping.getResultSet() == null) {
        try {
          final String columnPrefix = getColumnPrefix(parentPrefix, resultMapping);
          final ResultMap nestedResultMap = getNestedResultMap(rsw.getResultSet(), nestedResultMapId, columnPrefix);
          CacheKey rowKey = null;
          Object ancestorObject = null;
          if (ancestorColumnPrefix.containsKey(nestedResultMapId)) {
            rowKey = createRowKey(nestedResultMap, rsw, ancestorColumnPrefix.get(nestedResultMapId));
            ancestorObject = ancestorObjects.get(rowKey);
          }
          if (ancestorObject != null) { 
            if (newObject) metaObject.setValue(resultMapping.getProperty(), ancestorObject);
          } else {
            //四条记录都会执行这里
            //四条记录都生成不同的rowKey的,大概为acct_01,acct_02,acct_03,acct_04
            rowKey = createRowKey(nestedResultMap, rsw, columnPrefix);

            //parentRowKey为User对象的key
            //四条记录的combinedKey大概为user_01:acct_01,user_01:acct_02,user_02:acct_03,user_01:acct_04
            final CacheKey combinedKey = combineKeys(rowKey, parentRowKey);            
            Object rowValue = nestedResultObjects.get(combinedKey);
            boolean knownValue = (rowValue != null);

            //实例化集合属性
            //这里User.accts对象为一个集体，instantiateCollectionPropertyIfAppropriate方法会取出accts属性的值，如果为null则创建一个,并设置到User对象中
            //第一、二、四条记录返回的都是同一个，因为他们对应同一个User对象
            final Object collectionProperty = instantiateCollectionPropertyIfAppropriate(resultMapping, metaObject);            
            if (anyNotNullColumnHasValue(resultMapping, columnPrefix, rsw.getResultSet())) {
              //生成Acct对象
              rowValue = getRowValue(rsw, nestedResultMap, combinedKey, rowKey, columnPrefix, rowValue);
              if (rowValue != null &amp;&amp; !knownValue) {
                if (collectionProperty != null) {
                  final MetaObject targetMetaObject = configuration.newMetaObject(collectionProperty);
                  //加入到集合中
                  targetMetaObject.add(rowValue);
                } else {
                  metaObject.setValue(resultMapping.getProperty(), rowValue);
                }
                foundValues = true;
              }
            }
          }
        } catch (SQLException e) {
          throw new ExecutorException(&quot;Error getting nested result map values for &apos;&quot; + resultMapping.getProperty() + &quot;&apos;.  Cause: &quot; + e, e);
        }
      }
    }
    return foundValues;
  }

  private Object instantiateCollectionPropertyIfAppropriate(ResultMapping resultMapping, MetaObject metaObject) {
    //属性名，这里为accts
    final String propertyName = resultMapping.getProperty();
    //设置值
    Object propertyValue = metaObject.getValue(propertyName);
    if (propertyValue == null) {
      //如果为空，先看他的类型
      Class&lt;?&gt; type = resultMapping.getJavaType();
      if (type == null) {
        type = metaObject.getSetterType(propertyName);
      }
      try {
        if (objectFactory.isCollection(type)) {
          //如果是集合类型

          //生成一个集合对象
          propertyValue = objectFactory.create(type);

          //设置到User对象中，即User.setAccts(list)方法
          metaObject.setValue(propertyName, propertyValue);
          return propertyValue;
        }
      } catch (Exception e) {
        throw new ExecutorException(&quot;Error instantiating collection property for result &apos;&quot; + resultMapping.getProperty() + &quot;&apos;.  Cause: &quot; + e, e);
      }
    } else if (objectFactory.isCollection(propertyValue.getClass())) {
      return propertyValue;
    }
    return null;
  }</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到此，Mybatis是怎么利用ResultSet生成对象的过程已经分析完毕。分为简单映射和复杂映射。</p><p>简单映射就是不包含内映射的resultMap</p><p>复杂映射就是包含内映射的resultMap。</p><p>复杂映射的过程比较复杂，源代码也没有一行注释，本人是写了个实例，再通过eclipse中的debuger一步步来分析的。</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MyBatis3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank">MyBatis3源码解析</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/pay-wechat.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/pay-alipay.png" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/mybatis3-cache-implementation/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mybatis3源码分析之缓存的实现</div></div></a></div><div class="next-post pull_right"><a href="/mybatis3-statement-initialization/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mybatis3源码分析之Statement初始化和参数设置</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i> <span>相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/mybatis3-source-code-preparation/" title="MyBatis3源码解析-前期准备"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-17</div><div class="relatedPosts_title">MyBatis3源码解析-前期准备</div></div></a></div><div class="relatedPosts_item"><a href="/mybatis3-configuration-loading/" title="MyBatis3源码之Configuration加载过程"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-18</div><div class="relatedPosts_title">MyBatis3源码之Configuration加载过程</div></div></a></div><div class="relatedPosts_item"><a href="/mybatis3-resultmap-loading/" title="MyBatis3源码之ResultMap加载过程"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-21</div><div class="relatedPosts_title">MyBatis3源码之ResultMap加载过程</div></div></a></div><div class="relatedPosts_item"><a href="/mybatis3-source-xmlmapperbuilder/" title="MyBatis3源码之XMLMapperBuilder加载ResultMap过程"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-28</div><div class="relatedPosts_title">MyBatis3源码之XMLMapperBuilder加载ResultMap过程</div></div></a></div><div class="relatedPosts_item"><a href="/mybatis3-source-code-mappedStatement/" title="MyBatis3源码之MappedStatement加载过程"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-05-10</div><div class="relatedPosts_title">MyBatis3源码之MappedStatement加载过程</div></div></a></div><div class="relatedPosts_item"><a href="/mybatis3-configuration-load/" title="Mybatis3源码分析之缓存配置加载"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-05-11</div><div class="relatedPosts_title">Mybatis3源码分析之缓存配置加载</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"7cba1dad1cf41bf40ba9",clientSecret:"5d208277d004b840b5b67a31ebbf6aeb80a7a901",repo:"gitalk",owner:"zhangzwd",admin:["zhangzwd"],id:md5(decodeURI(location.pathname)),language:"zh-CN",perPage:10,distractionFreeMode:!0,pagerDirection:"last",createIssueManually:!1,updateCountCallback:commentCount});function commentCount(e){try{document.getElementsByClassName("gitalk-comment-count")[0].innerHTML=e}catch(e){return!1}}gitalk.render("gitalk-container")</script></div></article><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar"><div class="left-col"><img src="/img/wechat-qcode.png"></div><div class="rght-col"><h2>关注公众号</h2><small><div>→「技术干货」每日推送</div><div>→「免费资料」随时领取</div><div>→「每月赠书」抽奖活动</div></small></div></div><div class="wechat-img"><a href="/img/wdewm.jpg" target="_blank">点击添加为微信,加入讨论技术群</a></div><div class="social-desc">除公众号以外，我还会在以下平台发布内容：</div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhangzwd" target="_blank" title="Github" rel="external nofollow noopener noreferrer"><img src="/img/github.svg"></a><a class="social-icon" href="https://gitee.com/zhangzwd" target="_blank" title="Gitee" rel="external nofollow noopener noreferrer"><img src="/img/gitee.svg"></a><a class="social-icon" href="https://www.zhihu.com/people/zhangzhengwei/activities" target="_blank" title="知乎" rel="external nofollow noopener noreferrer"><img src="/img/zhihu.svg"></a><a class="social-icon" href="https://blog.csdn.net/zhang199091" target="_blank" title="CSDN" rel="external nofollow noopener noreferrer"><img src="/img/CSDN.svg"></a><a class="social-icon" href="https://www.jianshu.com/u/44dfb2efe2f6" target="_blank" title="简书" rel="external nofollow noopener noreferrer"><img src="/img/JianShu.svg"></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fa fa-bullhorn card-announcement-animation" aria-hidden="true"></i><span>公告</span></div><div class="announcement_content">感谢访问本站，如喜欢清收藏 ^_^<div class="card-info-bookmark is-center"><a class="bookmark button--primary button--animated" id="bookmark-it" href="javascript:;" title="加入书签" target="_self"><i class="fa fa-bookmark" aria-hidden="true"></i><span>加入书签</span></a></div></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fa fa-history" aria-hidden="true"></i><span>最新文章</span></div><div class="aside-recent-item"><div class="aside-recent-post"><a href="/mybatis3-finish/" target="_blank"><div class="aside-post-title"><div class="aside-post_title" href="/mybatis3-finish/" target="_blank" title="Mybatis3源码分析之总结">Mybatis3源码分析之总结</div><time class="aside-post_meta post-meta__date" title="发表于 2021-05-11 16:30:47">2021-05-11</time></div></a></div><div class="aside-recent-post"><a href="/mybatis3-mapper-dynamic-proxy/" target="_blank"><div class="aside-post-title"><div class="aside-post_title" href="/mybatis3-mapper-dynamic-proxy/" target="_blank" title="Mybatis3源码分析之Mapper动态代理">Mybatis3源码分析之Mapper动态代理</div><time class="aside-post_meta post-meta__date" title="发表于 2021-05-11 16:10:47">2021-05-11</time></div></a></div><div class="aside-recent-post"><a href="/mybatis3-mapper-implementation/" target="_blank"><div class="aside-post-title"><div class="aside-post_title" href="/mybatis3-mapper-implementation/" target="_blank" title="Mybatis3源码分析之Mapper实现">Mybatis3源码分析之Mapper实现</div><time class="aside-post_meta post-meta__date" title="发表于 2021-05-11 16:00:47">2021-05-11</time></div></a></div><div class="aside-recent-post"><a href="/mybatis3-mapper-generation/" target="_blank"><div class="aside-post-title"><div class="aside-post_title" href="/mybatis3-mapper-generation/" target="_blank" title="Mybatis3源码分析之Mapper生成过程">Mybatis3源码分析之Mapper生成过程</div><time class="aside-post_meta post-meta__date" title="发表于 2021-05-11 15:55:47">2021-05-11</time></div></a></div><div class="aside-recent-post"><a href="/mybatis3-plug/" target="_blank"><div class="aside-post-title"><div class="aside-post_title" href="/mybatis3-plug/" target="_blank" title="Mybatis3源码分析之插件解析">Mybatis3源码分析之插件解析</div><time class="aside-post_meta post-meta__date" title="发表于 2021-05-11 15:50:47">2021-05-11</time></div></a></div></div></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Java技术天地</div><div class="icp"><a href="http://www.beian.miit.gov.cn" target="_blank" rel="external nofollow noopener noreferrer"><img class="icp-icon" src="/img/icp.png"><span>鄂ICP备19013195号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){pangu.spacingElementById("content-inner")})</script><script src="/js/search/local-search.js"></script></body></html>