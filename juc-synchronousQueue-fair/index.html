<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JUC阻塞队列之SynchronousQueue公平模式源码分析 | Java技术天地</title><meta name="description" content="JUC阻塞队列之SynchronousQueue公平模式源码分析"><meta name="keywords" content="Java,线程,SynchronousQueue"><meta name="author" content="Java技术天地"><meta name="copyright" content="Java技术天地"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon-32x32.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://hm.baidu.com"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JUC阻塞队列之SynchronousQueue公平模式源码分析"><meta name="twitter:description" content="JUC阻塞队列之SynchronousQueue公平模式源码分析"><meta name="twitter:image" content="https://www.zzwzdx.cn/img/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="JUC阻塞队列之SynchronousQueue公平模式源码分析"><meta property="og:url" content="https://www.zzwzdx.cn/juc-synchronousQueue-fair/"><meta property="og:site_name" content="Java技术天地"><meta property="og:description" content="JUC阻塞队列之SynchronousQueue公平模式源码分析"><meta property="og:image" content="https://www.zzwzdx.cn/img/avatar.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode="1",t=Cookies.get("theme");if("1"==autoChangeMode){var isDarkMode=window.matchMedia("(prefers-color-scheme: dark)").matches,isLightMode=window.matchMedia("(prefers-color-scheme: light)").matches,isNotSpecified=window.matchMedia("(prefers-color-scheme: no-preference)").matches,hasNoSupport=!isDarkMode&&!isLightMode&&!isNotSpecified;if(void 0===t){if(isLightMode)activateLightMode();else if(isDarkMode)activateDarkMode();else if(isNotSpecified||hasNoSupport){console.log("You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.");var now=new Date,hour=now.getHours(),isNight=hour<6||18<=hour;isNight?activateDarkMode():activateLightMode()}}else"light"==t?activateLightMode():activateDarkMode()}else"2"==autoChangeMode?(isNight=(hour=(now=new Date).getHours())<6||18<=hour,void 0===t?isNight?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode()):"dark"==t?activateDarkMode():"light"==t&&activateLightMode();function activateDarkMode(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#000")}function activateLightMode(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#fff")}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://www.zzwzdx.cn/juc-synchronousQueue-fair/"><link rel="prev" title="JUC阻塞队列之SynchronousQueue-非公平模式源码分析" href="https://www.zzwzdx.cn/juc-synchronousQueue-nofair/"><link rel="next" title="JUC阻塞队列之DelayQueue源码分析" href="https://www.zzwzdx.cn/juc-delayQueue/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6cdf806ea3d36641644ddfae3f9e80cb";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},translate:{defaultEncoding:2,translateDelay:0,cookieDomain:"https://www.zzwzdx.cn/",msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},bookmark:{message_prev:"按",message_next:"键将本页加入书签"},runtime_unit:"天",runtime:!0,copyright:{languages:{author:"作者: Java技术天地",link:"链接: ",source:"来源: Java技术天地",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},ClickShowText:void 0,medium_zoom:!1,fancybox:!0,Snackbar:{bookmark:{message_prev:"按",message_next:"键将本页加入书签"},chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#2d3035",position:"top-center"},baiduPush:!1,highlightCopy:!0,highlightLang:!0,highlightShrink:"false",isFontAwesomeV5:!1,isPhotoFigcaption:!1}</script><script>var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isSidebar:!1}</script><noscript><style>#page-header{opacity:1}.justified-gallery img{opacity:1}</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">65</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/" aria-current="page"><i class="fa-fw fa fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/juc/" aria-current="page"><i class="fa-fw fa fa-lock"></i> <span>Java并发</span></a></div><div class="menus_item"><a class="site-page" href="/spring-ioc/" aria-current="page"><i class="fa-fw fa fa-eercast"></i> <span>Spring IOC专题</span></a></div><div class="menus_item"><a class="site-page" href="/dp/" aria-current="page"><i class="fa-fw fa fa-ge"></i> <span>设计模式</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-meetup" aria-hidden="true"></i> <span>Mybatis教程</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/mybatis3/"><i class="fa-fw fa fa-anchor"></i> <span>Mybatis基础教程</span></a></li><li><a class="site-page" href="/mybatis3-source/"><i class="fa-fw fa fa-asterisk"></i> <span>Mybatis源码分析</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/" aria-current="page"><i class="fa-fw fa fa-archive"></i> <span>归档</span></a></div></div></div></div><div class="main-bg" id="body-wrap"><div class="post-bg" id="nav"><div id="page-header"><a class="pull_left" id="blog_name" href="/"><i class="logo"></i><span class="blog_title" id="site-name">Java技术天地</span></a><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/" aria-current="page"><i class="fa-fw fa fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/juc/" aria-current="page"><i class="fa-fw fa fa-lock"></i> <span>Java并发</span></a></div><div class="menus_item"><a class="site-page" href="/spring-ioc/" aria-current="page"><i class="fa-fw fa fa-eercast"></i> <span>Spring IOC专题</span></a></div><div class="menus_item"><a class="site-page" href="/dp/" aria-current="page"><i class="fa-fw fa fa-ge"></i> <span>设计模式</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-meetup" aria-hidden="true"></i> <span>Mybatis教程</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/mybatis3/"><i class="fa-fw fa fa-anchor"></i> <span>Mybatis基础教程</span></a></li><li><a class="site-page" href="/mybatis3-source/"><i class="fa-fw fa fa-asterisk"></i> <span>Mybatis源码分析</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/" aria-current="page"><i class="fa-fw fa fa-archive"></i> <span>归档</span></a></div></div><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i></a></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="post-info"><div id="post-title"><div class="posttitle">JUC阻塞队列之SynchronousQueue公平模式源码分析</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date" title="发表于 2019-10-29 09:18:18"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-10-29</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" target="_blank">Java并发编程</a></span><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/juc-synchronousQueue-fair/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div><div id="article-container"><p>synchronousQueue是一个不存储元素的阻塞队列。每个put操作必须等待一个take操作，否则不能继续向队列中添加元素。synchronousQueue同样支持公平和非公平性，在默认情况下线程采用非公平性策略进行访问。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>SynchronousQueue提供了2种构造方式，一种是默认的非公平性，一种是可选择公平和非公平性的构造方式，构造函数源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue &lt; E &gt; () : <span class="keyword">new</span> TransferStack &lt; E &gt; ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码中，我们可以看到，当SynchronousQueue非公平时，使用的是TransferStack这个类来构造的，否则使用的是TransferQueue这个类进行构造，下面我们看看这2个类的实现。</p><h4 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h4><p>TransferQueue是SynchronousQueue实现公平策略的核心类，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferQueue</span> &lt; <span class="title">E</span> &gt; <span class="keyword">extends</span> <span class="title">Transferer</span> &lt; <span class="title">E</span> &gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** 队列头结点 */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line">    <span class="comment">/** 队列尾节点 */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br><span class="line">    <span class="comment">// 指向一个取消的结点</span></span><br><span class="line">    <span class="comment">//当一个节点中最后一个插入时，它被取消了但是可能还没有离开队列</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode cleanMe;</span><br><span class="line"></span><br><span class="line">    TransferQueue() &#123;</span><br><span class="line">    	<span class="comment">//初始化一个空节点</span></span><br><span class="line">        QNode h = <span class="keyword">new</span> QNode(<span class="keyword">null</span>, <span class="keyword">false</span>); </span><br><span class="line">        <span class="comment">//将队列的头结点和尾节点都指向这个空节点</span></span><br><span class="line">        head = h;</span><br><span class="line">        tail = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略部分代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述TransferQueue的定义中我们可以看出，在TransferQueue中除了头、尾节点外还存在一个cleanMe节点。该节点主要用于标记，当删除的节点是尾节点时则需要使用该节点。 同时，对于TransferQueue需要注意的是，其队列永远都存在一个dummy node(虚拟节点)。在构造创建完TransferQueue后，其头结点和尾节点都指向了一个虚拟节点。而且在TransferQueue中节点的类型是<code>QNode</code>类型，它是TransferQueue的一个静态内部类，其源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向队列中的下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> QNode next;</span><br><span class="line">    <span class="comment">// 数据项 </span></span><br><span class="line">    <span class="keyword">volatile</span> Object item;</span><br><span class="line">    <span class="comment">//等待线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="comment">//模式，表示当前是数据还是请求，只有当匹配的模式相匹配时才会交换</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isData;</span><br><span class="line"></span><br><span class="line">    QNode(Object item, <span class="keyword">boolean</span> isData) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">        <span class="keyword">this</span>.isData = isData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS设置next域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(QNode cmp, QNode val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next == cmp &amp;&amp;</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS 设置item域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(Object cmp, Object val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item == cmp &amp;&amp;</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试通过CAS将此项目引用取消，将item域设置为自身</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tryCancel</span><span class="params">(Object cmp)</span> </span>&#123;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断节点是否被缺陷</span></span><br><span class="line"><span class="comment">     * 与tryCancel相照应只需要判断item释放等于自身即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item == <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isOffList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next == <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class &lt; ? &gt; k = QNode<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            itemOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">"item"</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码逻辑非常清晰，唯一需要注意的一点就是isData，该属性在进行数据交换起到关键性作用，两个线程进行数据交换的时候，必须要两者的模式保持一致,否则不能进行数据交换。</p><h4 id="TransferStack"><a href="#TransferStack" class="headerlink" title="TransferStack"></a>TransferStack</h4><p>TransferStack是SynchronousQueue实现非公平策略的关键类，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span> &lt; <span class="title">E</span> &gt; <span class="keyword">extends</span> <span class="title">Transferer</span> &lt; <span class="title">E</span> &gt; </span>&#123;</span><br><span class="line">    <span class="comment">/* Modes for SNodes, ORed together in node fields */</span></span><br><span class="line">    <span class="comment">/** 节点代表未实现的消费者 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 节点代表未完成的生产者 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** 节点正在执行另一个未完成的数据或请求 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  如果m设置了满足位，则返回true。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFulfilling</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> (m &amp; FULFILLING) != <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 栈的头部 */</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略部分代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransferStack中定义了三个状态：REQUEST表示消费数据的消费者，DATA表示生产数据的生产者，FULFILLING，表示匹配另一个生产者或消费者。任何线程对TransferStack的操作都属于上述3种状态中的一种（对应着SNode节点的mode）。同时还包含一个head域，表示头结点。 内部节点SNode定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next 节点</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode next;</span><br><span class="line">    <span class="comment">// 相匹配的节点</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode match;</span><br><span class="line">    <span class="comment">// 等待的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="comment">// item 域</span></span><br><span class="line">    Object item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式</span></span><br><span class="line">    <span class="keyword">int</span> mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * item域和mode域不需要使用volatile修饰，因为它们在volatile/atomic操作之前写，之后读</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SNode(Object item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(SNode cmp, SNode val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cmp == next &amp;&amp;</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将s结点与本结点进行匹配，匹配成功，则unpark等待线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryMatch</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (match == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, matchOffset, <span class="keyword">null</span>, s)) &#123;</span><br><span class="line">            Thread w = waiter;</span><br><span class="line">            <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123; <span class="comment">// waiters need at most one unpark</span></span><br><span class="line">                waiter = <span class="keyword">null</span>;</span><br><span class="line">                LockSupport.unpark(w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match == s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tryCancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, matchOffset, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> match == <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> matchOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class &lt; ? &gt; k = SNode<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            matchOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">"match"</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面简单介绍了TransferQueue和TransferStack的基本结构和定义，由于SynchronousQueue的put、take操作都是调用Transfer的transfer()方法，只不过是传递的参数不同而已，put传递的是e参数，所以模式为数据（公平isData = true，非公平mode= DATA），而take操作传递的是null，所以模式为请求（公平isData = false，非公平mode = REQUEST），如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// take操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平模式"><a href="#公平模式" class="headerlink" title="公平模式"></a>公平模式</h3><p>在公平模式中调用的方法是TransferQueue中的transfer方法，我们来看看该刚发的源码定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本算法是循环尝试执行以下两个操作之一：</span></span><br><span class="line"><span class="comment">     * 1.如果队列明显为空或持有相同模式的节点，请尝试将节点添加到等待队列中，直到被匹配或者被取消。</span></span><br><span class="line"><span class="comment">     * 2.如果队列显然包含等待项，并且此调用是互补模式，请尝试通过对等待节点的CAS item字段进行出队并使其出队，然后返回匹配项来实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QNode s = <span class="keyword">null</span>; </span><br><span class="line">    <span class="comment">// 判断是否是数据模式</span></span><br><span class="line">    <span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//尾节点</span></span><br><span class="line">        QNode t = tail;</span><br><span class="line">        <span class="comment">//头结点</span></span><br><span class="line">        QNode h = head;</span><br><span class="line">        <span class="comment">//队列还未初始化，则等待</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// spin</span></span><br><span class="line">        <span class="comment">//如果头为节点相等（队列为空），或者队列尾部节点和请求的节点具有相同的交易类型，那么就将节点添加到队列尾部，并且等待匹配。</span></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// empty or same-mode</span></span><br><span class="line">            QNode tn = t.next;</span><br><span class="line">            <span class="comment">// 如果此时t!=tail，则表示有其它线程进行了操作修改了tail节点，重新定位尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// tn != null，表示已经有其他线程添加了节点，tn 推进，重新处理</span></span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="comment">//尝试推进tn为尾节点</span></span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  调用的方法的 wait 类型的, 并且 超时了, 直接返回 null</span></span><br><span class="line">            <span class="comment">// timed 在take操作阐述</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) <span class="comment">// can't wait</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// s == null，构建一个新节点Node   </span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">            <span class="comment">//CAS设置新节点为尾节点，如果CAS失败，则表示有其它线程进行了操作，重新进行</span></span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s)) <span class="comment">// failed to link in</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//尝试推进s为尾节点        </span></span><br><span class="line">            advanceTail(t, s);</span><br><span class="line">            <span class="comment">// 调用awaitFulfill, 若节点是 head.next, 则进行自旋</span></span><br><span class="line">            <span class="comment">// 若不是的话, 直接 block, 直到有其他线程 与之匹配, 或它自己进行线程的中断</span></span><br><span class="line">            Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123; </span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断结束是否已经从队列中离开</span></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123; </span><br><span class="line">                <span class="comment">//尝试将s设置为head</span></span><br><span class="line">                advanceHead(t, s); </span><br><span class="line">                <span class="keyword">if</span> (x != <span class="keyword">null</span>) <span class="comment">// and forget fields</span></span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E) x : e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            QNode m = h.next;</span><br><span class="line">            <span class="comment">// 不一致读，则表示 有其他线程更改了线程结构，重新开始</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">            Object x = m.item;</span><br><span class="line">            <span class="comment">// isData == (x != null)：判断isData与x的模式是否相同，相同表示已经匹配了</span></span><br><span class="line">            <span class="comment">// x == m ：m节点被取消了</span></span><br><span class="line">            <span class="comment">// !m.casItem(x, e)：如果尝试将数据e设置到m上失败</span></span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||  x == m || !m.casItem(x, e)) &#123; </span><br><span class="line">                advanceHead(h, m); </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 成功匹配了，m设置为头结点h出列，向前推进</span></span><br><span class="line">            advanceHead(h, m); </span><br><span class="line">            <span class="comment">// 唤醒m上的等待线程</span></span><br><span class="line">            LockSupport.unpark(m.waiter);</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E) x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看看awaitFulfill这个方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">awaitFulfill</span><span class="params">(QNode s, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果指定了timed,则时间为System.nanoTime() + nanos，否则为0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0</span> L;</span><br><span class="line">    <span class="comment">//当前线程</span></span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="comment">///如果头节点下一个节点是当前s节点(以防止其他线程已经修改了head节点)</span></span><br><span class="line">    <span class="comment">// 则运算(timed ? maxTimedSpins : maxUntimedSpins)，否则直接返回。</span></span><br><span class="line">    <span class="comment">// 指定了timed则使用maxTimedSpins，反之使用maxUntimedSpins</span></span><br><span class="line">    <span class="keyword">int</span> spins = ((head.next == s) ? (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//判断当前线程是否中断</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            <span class="comment">//尝试取消，将当前节点的item设置为自己(this)</span></span><br><span class="line">            s.tryCancel(e);</span><br><span class="line">         <span class="comment">//获取当前节点的内容   </span></span><br><span class="line">        Object x = s.item;</span><br><span class="line">        <span class="comment">//如果当前节点的值和当前值是否相等，不相等表示节点已经被取出(交易)</span></span><br><span class="line">        <span class="keyword">if</span> (x != e)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="comment">//计算截止时间   </span></span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span> L) &#123;</span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            --spins;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//将当前节点的等待线程设置为当前线程</span></span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            <span class="comment">//线程阻塞</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            <span class="comment">//线程阻塞等待指定纳秒</span></span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put操作的<code>transfer</code>方法的逻辑比较复杂，这里再次对其进行一次梳理，其整个逻辑流程如下：</p><ol><li>获取队列的头结点和尾节点，如果为初始化则自旋等待初始化。</li><li>对队列的尾节点进行验证，定位出真正的尾节点，防止其它线程修改了队列后尾节点定位一次。</li><li>将当前传入的值构建成为一个新的节点，并将其添加到队列尾部并从新定义尾节点。</li><li>然后调用awaitFulfill方法阻塞线程，知道线程被中断或者超时已经消费者消费。</li><li>如何消费者消费成功，则将节点从队列中清除。</li></ol><p>最后我们举例来说明SynchronousQueue的公平模式的<code>put</code>操作。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronousQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-A"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-B"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Integer take = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                take = queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(take);</span><br><span class="line">        &#125;,<span class="string">"Thread-C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先上来之后进行的是两次put操作，然后再take操作，默认队列上来会进行初始化，初始化的内容如下代码所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TransferQueue() &#123;</span><br><span class="line">    <span class="comment">//初始化一个虚拟节点</span></span><br><span class="line">    QNode h = <span class="keyword">new</span> QNode(<span class="keyword">null</span>, <span class="keyword">false</span>); </span><br><span class="line">    head = h;</span><br><span class="line">    tail = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化后，队列的状态如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/put_1.png" alt="初始化"></p><p>当线程第一次进行<code>put</code>操作时，我们来分析下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QNode t = tail;</span><br><span class="line">QNode h = head;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>) <span class="comment">// saw uninitialized value</span></span><br><span class="line">    <span class="keyword">continue</span>; <span class="comment">// spin</span></span><br></pre></td></tr></table></figure><p>首先获取头结点和尾节点，并判断头结点和尾节点是否为空，如果为空则进行自旋，这里我们看到head=tail=虚拟节点。继续执行后面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列为空或者模式相同时进行if语句</span></span><br><span class="line"><span class="keyword">if</span> (h == t || t.isData == isData) &#123; </span><br><span class="line">    QNode tn = t.next;</span><br><span class="line">    <span class="comment">// 判断t是否是队尾，不是则重新循环。</span></span><br><span class="line">    <span class="keyword">if</span> (t != tail) </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123; </span><br><span class="line">        advanceTail(t, tn);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果指定了timed并且延时时间用尽则直接返回空，这里操作主要是offer操作时，因为队列无存储空间的当offer时不允许插入。</span></span><br><span class="line">    <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这里是新节点生成。</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">        s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">     <span class="comment">// 将尾节点的next节点修改为当前节点。</span></span><br><span class="line">    <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s)) </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">	<span class="comment">// 队尾移动</span></span><br><span class="line">    advanceTail(t, s);</span><br><span class="line">    <span class="comment">//自旋并且设置线程。</span></span><br><span class="line">    Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">    <span class="keyword">if</span> (x == s) &#123;</span><br><span class="line">        clean(t, s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.isOffList()) &#123; </span><br><span class="line">        advanceHead(t, s); </span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>) </span><br><span class="line">            s.item = s;</span><br><span class="line">        s.waiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E) x : e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完上面代码后，队列情况如下：</p><p> ![](<a href="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/put_2" target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/zhangzwd/pic-bed/raw/master/blog/put_2</a> .png)</p><p>此时线程A处于自旋状态，如果自旋次数用完后还没有消费者消费在线程进入阻塞状态。接下来是线程B进行操作，这里不进行重复进行，插入第二个元素队列的状况，此时线程B也处于等待状态。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/put_3.png" alt></p><p>上面的主要是put了两次操作后队列的情况，接下来分析一下take操作时又是如何进行操作的，当take操作时，isData为false，而队尾的isData为true两个不相等，所以不会进入到if语句，而是进入到了else语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 获取头结点的下一个节点，进行互补操作。</span></span><br><span class="line">    QNode m = h.next; </span><br><span class="line">    <span class="comment">//读取不一致，则从新读取</span></span><br><span class="line">    <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">    <span class="comment">//获取m节点的值</span></span><br><span class="line">    Object x = m.item;</span><br><span class="line">    <span class="comment">// 如果x==null，表示x节点已经被读取</span></span><br><span class="line">    <span class="comment">// x==m 表m节点已经被删除</span></span><br><span class="line">    <span class="comment">// m.casItem(x, e) 设置x节点的item为null</span></span><br><span class="line">    <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) || x == m || !m.casItem(x, e)) &#123;</span><br><span class="line">        <span class="comment">//移动头结点到头结点的下一个节点</span></span><br><span class="line">        advanceHead(h, m); </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动头结点到头结点的下一个节点</span></span><br><span class="line">    advanceHead(h, m); </span><br><span class="line">    <span class="comment">//唤醒节点上等待的线程</span></span><br><span class="line">    LockSupport.unpark(m.waiter);</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E) x : e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取头结点的下一个节点m用于互补操作，也就是take操作,接下来判断读取是否一致，不一致从新读取。然后判断m节点是否被消费，如果没消费，则移动头结点到下一个节点，并重新消费，如果没有消费，则移动头结点到下一个节点，然后将m的item值修改为null,并且唤醒m节点上阻塞的线程。因此在take()操作执行完后，队列情况如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/take.png" alt></p><p>这里需要注意的是，在执行<code>LockSupport.unpark(m.waiter);</code>代码后，或唤醒put操作的线程，这里会唤醒线程A，唤醒线程A后会在执行如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//awaitFulfill方法片段</span></span><br><span class="line">Object x = s.item;</span><br><span class="line"><span class="keyword">if</span> (x != e)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line"><span class="comment">//transfer方法片段</span></span><br><span class="line">Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line"><span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">    clean(t, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断节点是否离开了队列</span></span><br><span class="line"><span class="keyword">if</span> (!s.isOffList()) &#123; </span><br><span class="line">    <span class="comment">//调节头结点</span></span><br><span class="line">    advanceHead(t, s); </span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>) </span><br><span class="line">        s.item = s;</span><br><span class="line">    s.waiter = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E) x : e;</span><br></pre></td></tr></table></figure><p>这里的代码我们可以对照<code>插入第一个元素</code>图，s节点也就是当前m节点，获取值得时候已经修改为null，但是当时插入的值时1，所以两个不想等了，则直接返回null值。此时x!=s因此不会执行<code>clean</code>方法，接下来会执行<code>s.isOffList()</code>来判断节点是否移除了队列，很明显当前节点s并没有离开队列，将waiter设置为null后返回。</p><h3 id="清除操作"><a href="#清除操作" class="headerlink" title="清除操作"></a>清除操作</h3><p>上面分析了正常的take和put操作，接下来我们分析下中断操作，现在在被中断后会执行<code>s.tryCancel(e)</code>方法，这个方法的作用的是将QNode节点的item节点赋值为当前QNode，这时候x和e值就不相等了（<code>if (x != e)</code>），x的值是s.item，则为当前QNode，而e的值是用户指定的值，这时候返回x(s.item)。返回到函数调用地方<code>transfer</code>中，这时候要执行下面语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为节点s被删除了，所有s.item = s</span></span><br><span class="line"><span class="keyword">if</span> (x == s) &#123;                  </span><br><span class="line">    clean(t, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>clean(t,s)</code>清理节点，其方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pred [要清除节点的前一个节点]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s    [要清除的节点]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(QNode pred, QNode s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清除节点等待线程</span></span><br><span class="line">    s.waiter = <span class="keyword">null</span>; </span><br><span class="line">    <span class="comment">//判断节点是否正常(如果不正常表示有其它线程已经对队列做了操作)</span></span><br><span class="line">    <span class="keyword">while</span> (pred.next == s) &#123; </span><br><span class="line">        <span class="comment">//获取队列的头结点</span></span><br><span class="line">        QNode h = head;</span><br><span class="line">        <span class="comment">//头结点指向的下下一个节点(第一个节点)</span></span><br><span class="line">        QNode hn = h.next; </span><br><span class="line">        <span class="comment">//如果头结点的下一个节点已经交易过了，则移动头结点</span></span><br><span class="line">        <span class="keyword">if</span> (hn != <span class="keyword">null</span> &amp;&amp; hn.isCancelled()) &#123;</span><br><span class="line">            advanceHead(h, hn);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取对了的尾节点</span></span><br><span class="line">        QNode t = tail; </span><br><span class="line">        <span class="comment">//如果队列为空，则退出</span></span><br><span class="line">        <span class="keyword">if</span> (t == h)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//获取尾节点的下一个节点</span></span><br><span class="line">        QNode tn = t.next;</span><br><span class="line">        <span class="comment">//判断现在的t是不是末尾节点，可能其他线程插入了内容导致不是最后的节点。</span></span><br><span class="line">        <span class="keyword">if</span> (t != tail)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果不是最后节点的话将其现在t.next节点作为tail尾节点。</span></span><br><span class="line">        <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advanceTail(t, tn);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前要清除节点不是尾节点进入到这里面。</span></span><br><span class="line">        <span class="keyword">if</span> (s != t) &#123; </span><br><span class="line">            <span class="comment">//获取当前节点（被取消的节点）的下一个节点。</span></span><br><span class="line">            QNode sn = s.next;</span><br><span class="line">            <span class="comment">//修改上一个节点的next(下一个)元素为下下个节点。</span></span><br><span class="line">            <span class="keyword">if</span> (sn == s || pred.casNext(s, sn))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QNode dp = cleanMe;</span><br><span class="line">        <span class="keyword">if</span> (dp != <span class="keyword">null</span>) &#123; <span class="comment">// 尝试清除上一个标记为清除的节点。</span></span><br><span class="line">            <span class="comment">//获取要清除的节点</span></span><br><span class="line">            QNode d = dp.next;</span><br><span class="line">            QNode dn;</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="keyword">null</span> || <span class="comment">// d is gone or</span></span><br><span class="line">                d == dp || <span class="comment">// d is off list or</span></span><br><span class="line">                !d.isCancelled() || <span class="comment">// d not cancelled or</span></span><br><span class="line">                (d != t &amp;&amp; <span class="comment">// d not tail and</span></span><br><span class="line">                    (dn = d.next) != <span class="keyword">null</span> &amp;&amp; <span class="comment">//   has successor</span></span><br><span class="line">                    dn != d &amp;&amp; <span class="comment">//   that is on list</span></span><br><span class="line">                    dp.casNext(d, dn))) <span class="comment">// d unspliced</span></span><br><span class="line">                casCleanMe(dp, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (dp == pred)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// s is already saved node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casCleanMe(<span class="keyword">null</span>, pred))</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// Postpone cleaning s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里删除分一下3中情况：</p><ol><li>如果节点中取消的头结点的下一个节点，只需要移动当前head节点到下一个节点即可。</li><li>如果取消的是中间的节点，则将当前节点next节点修改为下下个节点。</li><li>如果修改为末尾的节点，则将当前节点放入到QNode的clearMe中，等待有内容进来之后下一次进行清除操作。</li></ol><p>这里我们对上面3种方式分别举例说明。</p><h4 id="情况一："><a href="#情况一：" class="headerlink" title="情况一："></a>情况一：</h4><p>清除头结点下一个节点，下面是实例代码进行讲解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronousQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-A"</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-B"</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        </span><br><span class="line">        threadA.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子说明我们启动了两个线程，分别向SynchronousQueue队列中添加了元素1和元素2，添加成功之后的，让主线程休眠一会，然后将第一个线程进行中断操作，添加两个元素后节点所处在的状态为下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_1.png" alt></p><p>当我们调用<code>threadA.interrupt();</code>方法时，线程A的等他消费将会被终止，然后会运行<code>awaitFulfill</code>中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">    <span class="comment">//将节点的item设置为自己</span></span><br><span class="line">    s.tryCancel(e);</span><br><span class="line">Object x = s.item;</span><br><span class="line"><span class="keyword">if</span> (x != e)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure><p>执行完上面代码后，节点状态如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_1_1.png" alt></p><p>退出<code>awaitFulfill</code>并且返回的是s节点内容（实际上返回的就是s节点），接下来返回到调用<code>awaitFulfill</code>的方法<code>transfer</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回的x就是s</span></span><br><span class="line">Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line"><span class="keyword">if</span> (x == s) &#123; </span><br><span class="line">    <span class="comment">//进入clean方法</span></span><br><span class="line">    clean(t, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>clean</code>方法后运行如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QNode h = head;</span><br><span class="line">QNode hn = h.next; </span><br><span class="line"><span class="comment">//判断头结点的下一个节点不为空，切实删除状态则进入</span></span><br><span class="line"><span class="keyword">if</span> (hn != <span class="keyword">null</span> &amp;&amp; hn.isCancelled()) &#123;</span><br><span class="line">    advanceHead(h, hn);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到首先h节点为head节点，hn为头结点的下一个节点，在进行判断头结点的下一个节点不为空并且头结点下一个节点是被中断的节点(取消的节点)，则进入到if语句中，if语句其实也很简单就是将头结点修改为头结点的下一个节点(s节点，别取消节点，并且将前节点的next节点修改为自己，也就是移除了之前的节点，我们看下advanceHead方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advanceHead</span><span class="params">(QNode h, QNode nh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == head &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, headOffset, h, nh))</span><br><span class="line">        h.next = h; <span class="comment">// forget old next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>advanceHead</code>代码比较简单，运行完后，节点状态如下所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_1_2.png" alt></p><p>从上图我们看到，队列的原头结点从队列中移除了，并且原队列中头结点的下一个元素转变成了新的头结点，至此清除头结点的下一个节点完成。</p><h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>清除中间节点，实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronousQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-A"</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        </span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-B"</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-C"</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        </span><br><span class="line">        threadB.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完3次put操作后，队列情况如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_2.png" alt></p><p>在执行<code>threadB.interrupt();</code>后，线程B会从等待中唤醒，然后和情况一相同从<code>awaitFulfill</code>方法中返回后进入<code>clean</code>方法，代入如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QNode t = tail; <span class="comment">// Ensure consistent read for tail</span></span><br><span class="line"><span class="keyword">if</span> (t == h)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">QNode tn = t.next;</span><br><span class="line"><span class="keyword">if</span> (t != tail)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    advanceTail(t, tn);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s != t) &#123;</span><br><span class="line">    QNode sn = s.next;</span><br><span class="line">    <span class="keyword">if</span> (sn == s || pred.casNext(s, sn))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里s即线程B所在的节点也就是要清除的节点，很显然<code>s!=t</code>成立，进入if语句。然后执行<code>pred.casNext(s, sn)</code>将s节点跳过，运行完后，队列情况如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_2_1.png" alt></p><h4 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h4><p>清除尾节点，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronousQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-A"</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-B"</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        threadB.interrupt();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        </span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-C"</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        threadC.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例子主要说明一个问题就是删除的节点如果是末尾节点的话，<code>clear</code>方法又是如何处理的，首先启动第一和第二个线程，然后又将第二个线程中断，这是第二个线程插入的节点为尾节点，然后再启动第三个节点插入值，再中断了第三个节点末尾节点，说一下为啥这样操作，因为当清除尾节点时，并不是直接移除当前节点，而是将被清除的节点的前节点设置到QNode的CleanMe中，等待下次clear方法时进行清除上次保存在CleanMe的节点，然后再处理当前被中断节点，将新的被清理的节点prev设置为cleanMe当中，等待下次进行处理，接下来一步一步分析，首先我们先来看一下第二个线程启动后节点的状态。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_3.png" alt></p><p>然后在执行了<code>threadB.interrupt();</code>后，状态如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_3_1.png" alt></p><p>然后在线程C执行put操作后，状态如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_3_2.png" alt></p><p>然后执行<code>threadC.interrupt();</code>后此时<code>QNode dp = cleanMe;</code>不为空，因此进入执行下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dp != <span class="keyword">null</span>) &#123; <span class="comment">// Try unlinking previous cancelled node</span></span><br><span class="line">    QNode d = dp.next;</span><br><span class="line">    QNode dn;</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="keyword">null</span> || <span class="comment">// d is gone or</span></span><br><span class="line">        d == dp || <span class="comment">// d is off list or</span></span><br><span class="line">        !d.isCancelled() || <span class="comment">// d not cancelled or</span></span><br><span class="line">        (d != t &amp;&amp; <span class="comment">// d not tail and</span></span><br><span class="line">            (dn = d.next) != <span class="keyword">null</span> &amp;&amp; <span class="comment">//   has successor</span></span><br><span class="line">            dn != d &amp;&amp; <span class="comment">//   that is on list</span></span><br><span class="line">            dp.casNext(d, dn))) <span class="comment">// d unspliced</span></span><br><span class="line">        casCleanMe(dp, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (dp == pred)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// s is already saved node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码逻辑主要如下：</p><ol><li>判断d是否为空，如果为空，则表示节点已经清除。</li><li>如果cleanMe节点的下一个节点和自己相等，说明需要清除的节点已经离队了。</li><li>判断要清除的节点状态是清除状态。</li><li>如果上面条件都正确，则执行<code>(d != t &amp;&amp; (dn = d.next) != null &amp;&amp; dn != d &amp;&amp; dp.casNext(d, dn))</code>，将清除节点前一个节点的next设置为清除节点的后一个节点。</li></ol><p>上面逻辑执行完后，队列状态如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_3_3.png" alt></p><p>可以看出将上一次标记为清除的节点清除了队列中，再次进入循环，循环之后发现dp为null则会运行<code>casCleanMe(null, pred)</code>，此时当前节点s的前一个节点已经被清除队列，但是并不影响后续的清除操作，因为前节点的next节点还在维护中，也是前节点的next指向还是<code>Reference-Thread-C</code>,如下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_3_4.png" alt></p><p>就此SynchronousQueue的公平模式的数据交换分析完毕，如果有不正确的地方请指正。下一篇将分析SynchronousQueue的非公平模式。</p></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">Java技术天地</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://www.zzwzdx.cn/juc-synchronousQueue-fair/">https://www.zzwzdx.cn/juc-synchronousQueue-fair/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.zzwzdx.cn" target="_blank">Java技术天地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/" target="_blank">Java</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/" target="_blank">线程</a><a class="post-meta__tags" href="/tags/SynchronousQueue/" target="_blank">SynchronousQueue</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/pay-wechat.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/pay-alipay.png" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/juc-synchronousQueue-nofair/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JUC阻塞队列之SynchronousQueue-非公平模式源码分析</div></div></a></div><div class="next-post pull_right"><a href="/juc-delayQueue/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC阻塞队列之DelayQueue源码分析</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i> <span>相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/juc-synchronousQueue-nofair/" title="JUC阻塞队列之SynchronousQueue-非公平模式源码分析"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-10-31</div><div class="relatedPosts_title">JUC阻塞队列之SynchronousQueue-非公平模式源码分析</div></div></a></div><div class="relatedPosts_item"><a href="/java-thread/" title="Java线程概念理解"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-05-09</div><div class="relatedPosts_title">Java线程概念理解</div></div></a></div><div class="relatedPosts_item"><a href="/java-multithreading-introduction/" title="Java多线程简介"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-05-11</div><div class="relatedPosts_title">Java多线程简介</div></div></a></div><div class="relatedPosts_item"><a href="/java-thread-startup-and-termination/" title="Java线程的启动和终止"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-05-11</div><div class="relatedPosts_title">Java线程的启动和终止</div></div></a></div><div class="relatedPosts_item"><a href="/synchronized-implementation-principle/" title="深入分析synchronized实现原理"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-05-21</div><div class="relatedPosts_title">深入分析synchronized实现原理</div></div></a></div><div class="relatedPosts_item"><a href="/jmms-happensbefore/" title="JMM之happens-before"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-06-06</div><div class="relatedPosts_title">JMM之happens-before</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"7cba1dad1cf41bf40ba9",clientSecret:"5d208277d004b840b5b67a31ebbf6aeb80a7a901",repo:"gitalk",owner:"zhangzwd",admin:["zhangzwd"],id:md5(decodeURI(location.pathname)),language:"zh-CN",perPage:10,distractionFreeMode:!0,pagerDirection:"last",createIssueManually:!1,updateCountCallback:commentCount});function commentCount(e){try{document.getElementsByClassName("gitalk-comment-count")[0].innerHTML=e}catch(e){return!1}}gitalk.render("gitalk-container")</script></div></article><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar"><div class="left-col"><img src="/img/wechat-qcode.png"></div><div class="rght-col"><h2>关注公众号</h2><small><div>→「技术干货」每日推送</div><div>→「免费资料」随时领取</div><div>→「每月赠书」抽奖活动</div></small></div></div><div class="wechat-img"><a href="/img/wdewm.jpg" target="_blank">点击添加为微信,加入讨论技术群</a></div><div class="social-desc">除公众号以外，我还会在以下平台发布内容：</div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhangzwd" target="_blank" title="Github" rel="external nofollow noopener noreferrer"><img src="/img/github.svg"></a><a class="social-icon" href="https://gitee.com/zhangzwd" target="_blank" title="Gitee" rel="external nofollow noopener noreferrer"><img src="/img/gitee.svg"></a><a class="social-icon" href="https://www.zhihu.com/people/zhangzhengwei/activities" target="_blank" title="知乎" rel="external nofollow noopener noreferrer"><img src="/img/zhihu.svg"></a><a class="social-icon" href="https://blog.csdn.net/zhang199091" target="_blank" title="CSDN" rel="external nofollow noopener noreferrer"><img src="/img/CSDN.svg"></a><a class="social-icon" href="https://www.jianshu.com/u/44dfb2efe2f6" target="_blank" title="简书" rel="external nofollow noopener noreferrer"><img src="/img/JianShu.svg"></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fa fa-bullhorn card-announcement-animation" aria-hidden="true"></i><span>公告</span></div><div class="announcement_content">感谢访问本站，如喜欢清收藏 ^_^<div class="card-info-bookmark is-center"><a class="bookmark button--primary button--animated" id="bookmark-it" href="javascript:;" title="加入书签" target="_self"><i class="fa fa-bookmark" aria-hidden="true"></i><span>加入书签</span></a></div></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fa fa-history" aria-hidden="true"></i><span>最新文章</span></div><div class="aside-recent-item"><div class="aside-recent-post"><a href="/mybatis3-finish/" target="_blank"><div class="aside-post-title"><div class="aside-post_title" href="/mybatis3-finish/" target="_blank" title="Mybatis3源码分析之总结">Mybatis3源码分析之总结</div><time class="aside-post_meta post-meta__date" title="发表于 2021-05-11 16:30:47">2021-05-11</time></div></a></div><div class="aside-recent-post"><a href="/mybatis3-mapper-dynamic-proxy/" target="_blank"><div class="aside-post-title"><div class="aside-post_title" href="/mybatis3-mapper-dynamic-proxy/" target="_blank" title="Mybatis3源码分析之Mapper动态代理">Mybatis3源码分析之Mapper动态代理</div><time class="aside-post_meta post-meta__date" title="发表于 2021-05-11 16:10:47">2021-05-11</time></div></a></div><div class="aside-recent-post"><a href="/mybatis3-mapper-implementation/" target="_blank"><div class="aside-post-title"><div class="aside-post_title" href="/mybatis3-mapper-implementation/" target="_blank" title="Mybatis3源码分析之Mapper实现">Mybatis3源码分析之Mapper实现</div><time class="aside-post_meta post-meta__date" title="发表于 2021-05-11 16:00:47">2021-05-11</time></div></a></div><div class="aside-recent-post"><a href="/mybatis3-mapper-generation/" target="_blank"><div class="aside-post-title"><div class="aside-post_title" href="/mybatis3-mapper-generation/" target="_blank" title="Mybatis3源码分析之Mapper生成过程">Mybatis3源码分析之Mapper生成过程</div><time class="aside-post_meta post-meta__date" title="发表于 2021-05-11 15:55:47">2021-05-11</time></div></a></div><div class="aside-recent-post"><a href="/mybatis3-plug/" target="_blank"><div class="aside-post-title"><div class="aside-post_title" href="/mybatis3-plug/" target="_blank" title="Mybatis3源码分析之插件解析">Mybatis3源码分析之插件解析</div><time class="aside-post_meta post-meta__date" title="发表于 2021-05-11 15:50:47">2021-05-11</time></div></a></div></div></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Java技术天地</div><div class="icp"><a href="http://www.beian.miit.gov.cn" target="_blank" rel="external nofollow noopener noreferrer"><img class="icp-icon" src="/img/icp.png"><span>鄂ICP备19013195号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){pangu.spacingElementById("content-inner")})</script><script src="/js/search/local-search.js"></script></body></html>