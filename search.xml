<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mybatis3源码分析之总结</title>
      <link href="/mybatis3-finish/"/>
      <url>/mybatis3-finish/</url>
      
        <content type="html"><![CDATA[<h1 id="Configuration加载过程"><a href="#Configuration加载过程" class="headerlink" title="Configuration加载过程"></a>Configuration加载过程</h1><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151229131927349"  alt>  </p><h2 id="Configuration组成"><a href="#Configuration组成" class="headerlink" title="Configuration组成"></a>Configuration组成</h2><ol><li>基本属性。在mybatis-config.xml加载的属性这里定义为基本属性。如cacheEnabled/variables/objectFactory等等，这些的加载都比较简单。</li><li>cache缓存。这个是从mapper配置文件加载的。一个命名空间对应一个缓存。</li><li>resultMap。结果集映射，从mapper配置文件中的resultMap节点加载。</li><li>mappedStatement。Sql语句的定义。从mapper配置文件中的select/update/insert/delete节点加载。</li></ol><p>之所以将cache/resultMap/mapperStatement单独分开，是因为我们在配置mybatis中主要使用的就是这三个配置。</p><h2 id="Configuration加载"><a href="#Configuration加载" class="headerlink" title="Configuration加载"></a>Configuration加载</h2><ol><li>XMLConfigBuilder读取mybatis-config.xml文件，解析内容并加载到configuration中基本属性中。</li><li>XMLMapperBuilder读取Mapper配置文件，解析得到配置内容。如果是加载Mapper接口的话由MapperAnnotationBuilder从注解里解析配置内容。</li><li>MapperBuilderAssistant利用XMLMapperBulider/XMLAnnotationBuilder解析到的配置构建Cache/ResultMap/MappedStatement对象并加载到Configuration中。</li></ol><h1 id="SQL执行过程"><a href="#SQL执行过程" class="headerlink" title="SQL执行过程"></a>SQL执行过程</h1><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151229131912319"  alt>  </p><h2 id="主要对象"><a href="#主要对象" class="headerlink" title="主要对象"></a>主要对象</h2><ol><li>Mybatis在SqlSession接口中提供了访问数据库的基本操作。如select/update/insert/delete/commit/rollback/close。SqlSession有一个默认的实现DefaultSqlSession</li><li>在DefaultSqlSession中有一个Executor对象，对象数据的操作都是由这个Executor来完成。Executor中有三个对象来帮助他完成MappedStatement的执行工作。</li><li>StatementHandler负责从连接中获取一个Statement对象</li><li>ParameterHandler负责对Statement设置参数</li><li>ResultHandler负责生成查询语句的结果集</li></ol><h2 id="主要过程"><a href="#主要过程" class="headerlink" title="主要过程"></a>主要过程</h2><ol><li>DefaultSqlSession根据id在configuration中找到MappedStatement对象(要执行的语句)</li><li>Executor调用MappedStatement对象的getBoundSql得到可执行的sql和参数列表</li><li>StatementHandler根据Sql生成一个Statement</li><li>ParameterHandler为Statement设置相应的参数</li><li>Executor中执行sql语句</li><li>如果是更新(update/insert/delete)语句，sql的执行工作得此结束</li><li>如果是查询语句，ResultSetHandler再根据执行结果生成ResultMap相应的对象返回。</li></ol><h1 id="Mybatis使用到的主要的设计模式"><a href="#Mybatis使用到的主要的设计模式" class="headerlink" title="Mybatis使用到的主要的设计模式"></a>Mybatis使用到的主要的设计模式</h1><ol><li>装饰模式。在实现Executor、Cache等接口时，Mybatis都使用了装饰模式。</li><li>模板模式。在看过很多框架的源都使用了这种模式。模板模式将面向对象的特性发挥到了极致。</li><li>外观模式。外观模式提供了统一的接口给客户端使用。为以后的系统或功能扩展提供了便利性。</li></ol><p>以上三种设计是Mybatis中非常重要的设计模式，我们应该了解并深入研究，在实际应用中使用。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li>Mybatis用jdk的动态代理实现了拦截器和Mapper接口。这种动态代理和注解的运用也是非常值得学习的。</li><li>SqlSession在一个生命周期中会产生大量的临时对象，如：Executor、Transaction、Cache、MetaObject、StatementHandler、ParameterHandler、ResultSetHandler等待。但是SqlSession的生命周期是非常短的。这样造成大量对象的产生，给JVM的GC工作带来了很多的消耗，这个应该是Mybatis比较大的缺点了。</li></ol><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之Mapper动态代理</title>
      <link href="/mybatis3-mapper-dynamic-proxy/"/>
      <url>/mybatis3-mapper-dynamic-proxy/</url>
      
        <content type="html"><![CDATA[<p>当定义好一个Mapper接口(UserDao)里，我们并不需要去实现这个类，但sqlSession.getMapper()最终会返回一个实现该接口的对象。这个对象是Mybatis利用jdk的动态代理实现的。这里将介绍这个代理对象的生成过程及其方法的实现过程。</p><h1 id="Mapper代码对象的生成过程"><a href="#Mapper代码对象的生成过程" class="headerlink" title="Mapper代码对象的生成过程"></a>Mapper代码对象的生成过程</h1><p>DefaultSqlSession.getMapp()方法最终会调用MapperRegistry.getMapper()方法</p><pre><code>public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {   //这个MapperProxyFactory是调用addMapper方法时加到knownMappers中的，   final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);   if (mapperProxyFactory == null)     //说明这个Mapper接口没有注册     throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);   try {      //生成一个MapperProxy对象     return mapperProxyFactory.newInstance(sqlSession);   } catch (Exception e) {     throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);   } }</code></pre><p>下面是MapperProxyFactory的newInstance方法</p><pre><code>public T newInstance(SqlSession sqlSession) {    //创建一个Mapperxy对象，这个方法实现了JDK动态代理中的InvocationHandler接口    final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);    return newInstance(mapperProxy);  }protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {    //mapperInterface，说明Mapper接口被代理了，这样子返回的对象就是Mapper接口的子类，方法被调用时会被mapperProxy拦截,也就是执行mapperProxy.invoke()方法    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);  }</code></pre><h1 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h1><p>详细分析一下MapperProxy类</p><pre><code>public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable {  private static final long serialVersionUID = -6424540398559729838L;  private final SqlSession sqlSession;  //Mapper接口  private final Class&lt;T&gt; mapperInterface;  //Mapper接口中的每个方法都会生成一个MapperMethod对象, methodCache维护着他们的对应关系  //这个methodCache是在MapperProxyFactory中持有的，MapperProxyFactory又是在Configuration中持有的  //所以每个Mapper接口类对应的MapperProxyFactory和methodCache在整个应用中是共享的，一般只会有一个实例  private final Map&lt;Method, MapperMethod&gt; methodCache;  public MapperProxy(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache) {    this.sqlSession = sqlSession;    this.mapperInterface = mapperInterface;    this.methodCache = methodCache;  }  //这里会拦截Mapper接口(UserDao)的所有方法  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    //如果是Object中定义的方法，直接执行。如toString(),hashCode()等待。    if (Object.class.equals(method.getDeclaringClass())) {      try {        return method.invoke(this, args);      } catch (Throwable t) {        throw ExceptionUtil.unwrapThrowable(t);      }    }    //其他Mapper接口定义的方法交由mapperMethod来执行。    final MapperMethod mapperMethod = cachedMapperMethod(method);    return mapperMethod.execute(sqlSession, args);  }  private MapperMethod cachedMapperMethod(Method method) {    MapperMethod mapperMethod = methodCache.get(method);    if (mapperMethod == null) {      mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());      methodCache.put(method, mapperMethod);    }    return mapperMethod;  }}</code></pre><h1 id="MapperMethod"><a href="#MapperMethod" class="headerlink" title="MapperMethod"></a>MapperMethod</h1><pre><code>//所有Mapper接口中方法被调用里，都会执行这个方法.这里实际上是调用SqlSession中的相关方法,public Object execute(SqlSession sqlSession, Object[] args) {  Object result;  //判断这个方法被注解里的Sql类型  if (SqlCommandType.INSERT == command.getType()) {    //执行insert    Object param = method.convertArgsToSqlCommandParam(args);    result = rowCountResult(sqlSession.insert(command.getName(), param));  } else if (SqlCommandType.UPDATE == command.getType()) {    //执行update    Object param = method.convertArgsToSqlCommandParam(args);    result = rowCountResult(sqlSession.update(command.getName(), param));  } else if (SqlCommandType.DELETE == command.getType()) {    /delete    Object param = method.convertArgsToSqlCommandParam(args);    result = rowCountResult(sqlSession.delete(command.getName(), param));  } else if (SqlCommandType.SELECT == command.getType()) {    //select ,查询    if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {      //没有返回值，并且有ResultHandler的情况      executeWithResultHandler(sqlSession, args);      result = null;    } else if (method.returnsMany()) {      //返回一个List      result = executeForMany(sqlSession, args);    } else if (method.returnsMap()) {      //返回一个Map      result = executeForMap(sqlSession, args);    } else {      //返回一个对象      Object param = method.convertArgsToSqlCommandParam(args);      result = sqlSession.selectOne(command.getName(), param);    }  } else {    throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());  }  if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {    throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName()         + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);  }  return result;}</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li>在Mybatis提供的编程接口中，开发人员只需要定义好Mapper接口(如：UserDao)，开发人员无需去实现。Mybatis会利用JDK的动态代理实现 Mapper接口。</li><li>在Mybatis中，每个Mapper接口都会对应一个MapperProxyFactory对象实例，这个对应关系在Configuration.mapperRegistry.knownMappers中。</li><li>当getMapper()方法被调用时，Mybatis会找到相对应的MapperProxyFactory对象实例，利用这个工厂来创建一个jdk动态代理对象，是这个Mapper接口的实现类,当Mapper定义的方法被调用时，会调用MapperProxy来处理。</li><li>MapperProxy会根据方法找到对应的MapperMethod对象来实现这次调用。</li><li>MapperMethod对应会读取方法中的注解，从Configuration中找到相对应的MappedStatement对象，再执行。</li></ol><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之Mapper实现</title>
      <link href="/mybatis3-mapper-implementation/"/>
      <url>/mybatis3-mapper-implementation/</url>
      
        <content type="html"><![CDATA[<h1 id="整体加载过程"><a href="#整体加载过程" class="headerlink" title="整体加载过程"></a>整体加载过程</h1><ol><li>mybatis-config.xml中可以在包(package)和class的方法让Mybatis加载一个Mapper</li><li>通过包的方式是从包加载所有的class,最条还是通过class方法来实现加载</li><li>加载过程中主要通过读取方法中的注解来生成MappedStatement对象，再加入到Configuration中。这个过程跟解析mapper.xml配置文件中的select/insert/update/delete节点的过程差不多。一个是从xml里读取信息，一个是从注解里读取信息。</li><li>通过注解生成的MappedStatement的Id生成规则为接口全限定名名加方法的名字，所以在定义Mapper接口类时千万不要重载方法，否则会发生预想不到的问题。</li><li>Mapper接口中的只有包含如下八种注解中的一种才会被Mybatis解析成一个MappedStatement对象。<ol><li>Select/Insert/Update/Delete</li><li>SelectProvider/InsertProvider/UpdateProvider/DeleteProvider一个方法如果没有这些注解中的其中一个，执行时Mybatis会报MappedStatement找不到</li></ol></li><li>Mybatis加载一个Mapper接口时会为其生成一个MapperProxyFactory对象，由这个对象来创建Mapper接口的实例。MapperProxyFactory这个类的实现在下一节详细分析。</li></ol><p>Mapper的配置加载是从XmlConfigBuilder.mapperElement()方法中触发的</p><pre><code>private void mapperElement(XNode parent) throws Exception {    if (parent != null) {      for (XNode child : parent.getChildren()) {        if (&quot;package&quot;.equals(child.getName())) {          //通过package的方法          String mapperPackage = child.getStringAttribute(&quot;name&quot;);          configuration.addMappers(mapperPackage);        } else {          String resource = child.getStringAttribute(&quot;resource&quot;);          String url = child.getStringAttribute(&quot;url&quot;);          String mapperClass = child.getStringAttribute(&quot;class&quot;);          if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) {            ErrorContext.instance().resource(resource);            InputStream inputStream = Resources.getResourceAsStream(resource);            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());            mapperParser.parse();          } else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) {            ErrorContext.instance().resource(url);            InputStream inputStream = Resources.getUrlAsStream(url);            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());            mapperParser.parse();          } else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) {            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);            //指定class的方式            configuration.addMapper(mapperInterface);          } else {            throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);          }        }      }    }  }</code></pre><p>通过package方式加载，最终也是找出所有符合条件的mapper类，再通过class的方法加载。</p><p>先来看configuration.addMaper()方法</p><pre><code>public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {   //最终是由MapperRegistry对象来完成加载的   mapperRegistry.addMapper(type); }public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {   if (type.isInterface()) {     if (hasMapper(type)) {       throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);     }     boolean loadCompleted = false;     try {       //这里为一个Mapper生成一个代理工厂，这个代理工厂通过JDK动态代理生成一个对象，稍后再详细分析。       knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));       // It&apos;s important that the type is added before the parser is run       // otherwise the binding may automatically be attempted by the       // mapper parser. If the type is already known, it won&apos;t try.       MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);       //Mapper.xml是交由XMLMapperBuilder来解析的       //同样这里使用了MapperAnnotationBuilder来解析注解       parser.parse();       loadCompleted = true;     } finally {       if (!loadCompleted) {         knownMappers.remove(type);       }     }   }</code></pre><h1 id="MapperAnnotationBuilder-parse-方法"><a href="#MapperAnnotationBuilder-parse-方法" class="headerlink" title="MapperAnnotationBuilder.parse()方法"></a>MapperAnnotationBuilder.parse()方法</h1><pre><code>public void parse() {    String resource = type.toString();    if (!configuration.isResourceLoaded(resource)) {      //这里会先去加载相对应的mapper.xml配置文件      //也就是说解析UserDao注解时，如果发现有UserDao.xml配置文件会先加载UesrDao.xml配置文件      loadXmlResource();      configuration.addLoadedResource(resource);      assistant.setCurrentNamespace(type.getName());      parseCache();      parseCacheRef();      //获取class中所有的方法      Method[] methods = type.getMethods();      for (Method method : methods) {        try {          //解析方法          parseStatement(method);        } catch (IncompleteElementException e) {          configuration.addIncompleteMethod(new MethodResolver(this, method));        }      }    }    parsePendingMethods();  }  //这个方法的功能就是读取方法的注解，生成一个MappedStatement对象，然后加入到Configuration中  void parseStatement(Method method) {    Class&lt;?&gt; parameterTypeClass = getParameterType(method);    LanguageDriver languageDriver = getLanguageDriver(method);    //从注解中获取一个SqlSource,之前已经分析过MappedStatement对应一个SqlSource对象，表示配置的Sql    SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);    //如果sqlSource为空，这个方法将直接返回    if (sqlSource != null) {      //读取方法中的Options注解      Options options = method.getAnnotation(Options.class);      //注意这个mappedStatementId的生成规则，Mybatis生成的Mapper代理对象也是根据这个规则来生成一个mappedStatementId，再去Configuration中加载MappedStatement的      final String mappedStatementId = type.getName() + &quot;.&quot; + method.getName();      Integer fetchSize = null;      Integer timeout = null;      StatementType statementType = StatementType.PREPARED;      ResultSetType resultSetType = ResultSetType.FORWARD_ONLY;      SqlCommandType sqlCommandType = getSqlCommandType(method);      boolean isSelect = sqlCommandType == SqlCommandType.SELECT;      //注意这个      //这两个是设置二级缓存的，如果没有设置options注解，将使用如下默认值      //如果是update/insert/delete语句，就行里就会刷新缓存,select语句则不刷新      //如果是select语句是默认使用缓存的      boolean flushCache = !isSelect;      boolean useCache = isSelect;      KeyGenerator keyGenerator;      String keyProperty = &quot;id&quot;;      String keyColumn = null;      //自动生成主键，一般在应用中比较少用      if (SqlCommandType.INSERT.equals(sqlCommandType) || SqlCommandType.UPDATE.equals(sqlCommandType)) {        // first check for SelectKey annotation - that overrides everything else        SelectKey selectKey = method.getAnnotation(SelectKey.class);        if (selectKey != null) {          keyGenerator = handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method), languageDriver);          keyProperty = selectKey.keyProperty();        } else {          if (options == null) {            keyGenerator = configuration.isUseGeneratedKeys() ? new Jdbc3KeyGenerator() : new NoKeyGenerator();          } else {            keyGenerator = options.useGeneratedKeys() ? new Jdbc3KeyGenerator() : new NoKeyGenerator();            keyProperty = options.keyProperty();            keyColumn = options.keyColumn();          }        }      } else {        keyGenerator = new NoKeyGenerator();      }      if (options != null) {        flushCache = options.flushCache();        useCache = options.useCache();        fetchSize = options.fetchSize() &gt; -1 || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : null; //issue #348        timeout = options.timeout() &gt; -1 ? options.timeout() : null;        statementType = options.statementType();        resultSetType = options.resultSetType();      }      //获取对应的resultMap,还可以配置多个，用&quot;,&quot;分隔      String resultMapId = null;      ResultMap resultMapAnnotation = method.getAnnotation(ResultMap.class);      if (resultMapAnnotation != null) {        String[] resultMaps = resultMapAnnotation.value();        StringBuilder sb = new StringBuilder();        for (String resultMap : resultMaps) {          if (sb.length() &gt; 0) sb.append(&quot;,&quot;);          sb.append(resultMap);        }        resultMapId = sb.toString();      } else if (isSelect) {        //如果没有配置resultMap，自动生成一个加入到Configuration中，就像Mapper.xml配置文件中只配置了resultType属性那样        resultMapId = parseResultMap(method);      }      //这里跟加载mapper.xml配置文件中一样，交由助手去生成一个MappedStatement并加入到Configuration中      assistant.addMappedStatement(          mappedStatementId,          sqlSource,          statementType,          sqlCommandType,          fetchSize,          timeout,          null,                             // ParameterMapID          parameterTypeClass,          resultMapId,    // ResultMapID          getReturnType(method),          resultSetType,          flushCache,          useCache,          false, // TODO issue #577          keyGenerator,          keyProperty,          keyColumn,          null,          languageDriver,          null);    }  }</code></pre><p>再来看是怎么生成SqlSource对象的</p><pre><code>private SqlSource getSqlSourceFromAnnotations(Method method, Class&lt;?&gt; parameterType, LanguageDriver languageDriver) {   try {     //获取方法的注解，Select/Update/Insert/Delete中的一种     Class&lt;? extends Annotation&gt; sqlAnnotationType = getSqlAnnotationType(method);     //获取方法的注解，SelectProvider/UpdateProvider/InsertProvider/DeleteProvider中的一种     Class&lt;? extends Annotation&gt; sqlProviderAnnotationType = getSqlProviderAnnotationType(method);     if (sqlAnnotationType != null) {       if (sqlProviderAnnotationType != null) {         //不支持两种注解同时存在         throw new BindingException(&quot;You cannot supply both a static SQL and SqlProvider to method named &quot; + method.getName());       }       Annotation sqlAnnotation = method.getAnnotation(sqlAnnotationType);       //直接读取Select/Update/Insert/Delete中的sql内容       final String[] strings = (String[]) sqlAnnotation.getClass().getMethod(&quot;value&quot;).invoke(sqlAnnotation);       //通过sql创建一个SqlSource,这里的逻辑眼从mapper.xml文件读取里的逻辑差不多，不再讨论       return buildSqlSourceFromStrings(strings, parameterType, languageDriver);     } else if (sqlProviderAnnotationType != null) {       Annotation sqlProviderAnnotation = method.getAnnotation(sqlProviderAnnotationType);       //这个SqlSource主要是通过反射执行SelectProvider/UpdateProvider/InsertProvider/DeleteProvider的方法得到sql内容,也不再讨论       return new ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation);     }     return null;   } catch (Exception e) {     throw new BuilderException(&quot;Could not find value method on SQL annotation.  Cause: &quot; + e, e);   } }</code></pre><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之Mapper生成过程</title>
      <link href="/mybatis3-mapper-generation/"/>
      <url>/mybatis3-mapper-generation/</url>
      
        <content type="html"><![CDATA[<p>Mybatis提供一种mapper形式的访问接口，通过定义接口，再加上简单的注解就能实现数据库操作。 </p><p>下面来看这个mapper是怎么使用的。</p><p>先定义接口</p><pre><code>public interface UserDao{        //告诉Mybatis执行什么Sql    @Select(&quot;select  * from tab_user where user_id=#{USER_ID}&quot;)    public List&lt;Map&lt;String,Object&gt;&gt; queryUser(Map&lt;String,?&gt; param);        //也可以这样子设置，Mybatis会调用UserSqlProvider.getQuerySql()方法获取要执行的sql    @SelectProvider(            type=UserSqlProvider.class,            method=&quot;getQuerySql&quot;    )    public List&lt;Map&lt;String,Object&gt;&gt; queryUser_2(Map&lt;String,?&gt; param);    public static class UserSqlProvider    {        public String getQuerySql()        {            return &quot;select  * from tab_user where user_id=#{USER_ID}&quot;;        }    }}</code></pre><p>在mybatis-config.xml配置文件中增加配置:</p><pre><code>&lt;mappers&gt;        &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;                 //直接设置class，也可以设置package，让mybatis去描述        &lt;mapper class=&quot;com.ashan.mybatis.UserDao&quot;/&gt;    &lt;/mappers&gt;</code></pre><p>然后就直接可以使用了</p><pre><code>public static void mapperTest(SqlSessionFactory sqlSessionFactory)    {        SqlSession sqlSession=sqlSessionFactory.openSession();        UserDao userDao=sqlSession.getMapper(UserDao.class);        System.out.println(userDao);        Map&lt;String,Object&gt; param=new HashMap&lt;&gt;();        param.put(&quot;USER_ID&quot;, &quot;user_01&quot;);        System.out.println(userDao.queryUser_2(param));        System.out.println(userDao.queryUser(param));    }</code></pre><p>输出的结果为</p><pre><code>org.apache.ibatis.binding.MapperProxy@17d99928[{user_id=user_01, user_name=liys, cust_id=cust_01, svc_num=13800138000}][{user_id=user_01, user_name=liys, cust_id=cust_01, svc_num=13800138000}]</code></pre><p>可以看到UserDao对象打印出来为MapperProxy,是一个代理。虽然我们没有实现UserDao接口，但Mybatis为利用JDK的动态代理为我们生成了一个。</p><p>接下来的几个章节，分析如下内容： </p><ol><li>Mybatis是怎么读取相关的注解，并加入到Configuration中去的。</li><li>Mybatis是怎么生成UserDao的代理对象的。</li><li>Mybatis是怎么实现UserDao中的方法的。</li></ol><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之插件解析</title>
      <link href="/mybatis3-plug/"/>
      <url>/mybatis3-plug/</url>
      
        <content type="html"><![CDATA[<p>Mybatis拦截器的使用方法参考官方文档:<a href="http://mybatis.org/mybatis-3/zh/configuration.html#plugins" target="_blank" rel="external nofollow noopener noreferrer">http://mybatis.org/mybatis-3/zh/configuration.html#plugins</a></p><h1 id="JDK动态代理示例"><a href="#JDK动态代理示例" class="headerlink" title="JDK动态代理示例"></a>JDK动态代理示例</h1><p>Mybatis的拦截器是通过jdk的动态代理实现的，只能生成接口的实例。这里先定义一个接口及实现。</p><pre><code>public interface AshanService{    public void service(String name);}public class AshanServiceImpl implements AshanService{    @Override    public void service(String name)    {        System.out.println(&quot;Hello &quot;+name);    }}</code></pre><p>JDK实现动态代理</p><pre><code>public class JdkDynamicProxy{    public static void main(String[] args)    {        //JDK动态代码要求实现InvocationHandler        class AshanInvocationHandler implements InvocationHandler        {            private Object target;            public AshanInvocationHandler(Object obj)            {                this.target=obj;            }            @Override            public Object invoke(Object proxy, Method method, Object[] args)                    throws Throwable            {                System.out.println(&quot;jdk dynamic proxy before..&quot;);                Object ret=method.invoke(this.target, args);                System.out.println(&quot;jdk dynamic proxy after..&quot;);                return ret;            }        }        AshanService service=new AshanServiceImpl();        AshanInvocationHandler handler=new AshanInvocationHandler(service);        //利用proxy生成一个代理对象        AshanService proxy=(AshanService)Proxy.newProxyInstance(service.getClass().getClassLoader(), service.getClass().getInterfaces(), handler);        proxy.service(&quot;jdk dynamic proxy&quot;);    }}</code></pre><p>输出内容为</p><pre><code>jdk dynamic proxy before..Hello jdk dynamic proxyjdk dynamic proxy after..</code></pre><h1 id="Mybatis中的拦截器示例"><a href="#Mybatis中的拦截器示例" class="headerlink" title="Mybatis中的拦截器示例"></a>Mybatis中的拦截器示例</h1><pre><code>//这个注解会被Plugin读取@Intercepts(        {            @Signature//定义方法签名            (                    type=AshanService.class,                    method=&quot;service&quot;,                    args={String.class}            )        })public class AshanInterceptor implements Interceptor{    private String name=&quot;&quot;;    public AshanInterceptor(String name)    {        super();        this.name = name;    }    //只有Intercepts在定义的方法才会被拦截    @Override    public Object intercept(Invocation invocation) throws Throwable    {        System.out.println(&quot;AshanInterceptor[&quot;+name+&quot;]...before...&quot;);        Object obj=invocation.proceed();        System.out.println(&quot;AshanInterceptor[&quot;+name+&quot;]...after...&quot;);        return obj;    }    @Override    public Object plugin(Object target)    {        if(target!=null &amp;&amp; target instanceof AshanService)        {            //Plugin是mybatis提供的            return Plugin.wrap(target, this);        }        return target;    }    @Override    public void setProperties(Properties properties)    {    }    public static void main(String[] args)    {        AshanService service=new AshanServiceImpl();        AshanInterceptor aiNoName=new AshanInterceptor(&quot;no_name&quot;);        //直接用Interceptor.plugin生成一个代理        AshanService proxy1=(AshanService)aiNoName.plugin(service);        proxy1.service(&quot;ashan&quot;);        System.out.println(&quot;######################&quot;);        InterceptorChain chain=new InterceptorChain();        chain.addInterceptor(new AshanInterceptor(&quot;1&quot;));        chain.addInterceptor(new AshanInterceptor(&quot;2&quot;));        chain.addInterceptor(new AshanInterceptor(&quot;3&quot;));        //用InterceptorChain生成一个代理        AshanService proxy2=(AshanService)chain.pluginAll(service);        proxy2.service(&quot;chain&quot;);    }}</code></pre><p>输出结果为</p><pre><code>AshanInterceptor[no_name]...before...Hello ashanAshanInterceptor[no_name]...after...######################AshanInterceptor[3]...before...AshanInterceptor[2]...before...AshanInterceptor[1]...before...Hello chainAshanInterceptor[1]...after...AshanInterceptor[2]...after...AshanInterceptor[3]...after...</code></pre><h1 id="Mybatis中Plugin在实现方式"><a href="#Mybatis中Plugin在实现方式" class="headerlink" title="Mybatis中Plugin在实现方式"></a>Mybatis中Plugin在实现方式</h1><p>先看拦截器接口</p><pre><code>public interface Interceptor {  //jdk动态代码中的InvocationHandler.invoke()方法执行里，这个方法会被调用  Object intercept(Invocation invocation) throws Throwable;  //生成一个代理对象  Object plugin(Object target);  //设置属性  void setProperties(Properties properties);}</code></pre><p>再来看Plugin是怎么使用Interceptor接口的</p><pre><code>public class Plugin implements InvocationHandler {  //Plugin实现了JDK动态代理中的InvocationHandler  //被代理的原始对象  private Object target;  //拦截器  private Interceptor interceptor;  //这里定义了拦截器对原始对象的那些方法有效  private Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;  private Plugin(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) {    this.target = target;    this.interceptor = interceptor;    this.signatureMap = signatureMap;  }  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    try {      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());      if (methods != null &amp;&amp; methods.contains(method)) {        //这里方法在signatureMap中，需要拦截。调用interceptor.intercept()方法,注意这个target已经是原始对象了        return interceptor.intercept(new Invocation(target, method, args));      }      //不需要拦截，直接执行      return method.invoke(target, args);    } catch (Exception e) {      throw ExceptionUtil.unwrapThrowable(e);    }  }}</code></pre><p>AshanInterceptor中是用Plugin类的一个静态方法wap()来生成一个代理对象的</p><pre><code>public static Object wrap(Object target, Interceptor interceptor) {   //对拦截器中取出方法签名,是通过注解来声明需要拦截的方法签名的   Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);   Class&lt;?&gt; type = target.getClass();   //获取被代理/拦截的对象实现的所有接口   Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);   if (interfaces.length &gt; 0) {     //这里最终还是用了JDK的动态代理，如果被代理/拦截的对象没有实现任何接口，JDK将无法代理。     return Proxy.newProxyInstance(         type.getClassLoader(),         interfaces,         new Plugin(target, interceptor, signatureMap));   }   return target; } //从注解中读取方法签名 private static Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) {   Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);   if (interceptsAnnotation == null) { // issue #251     throw new PluginException(&quot;No @Intercepts annotation was found in interceptor &quot; + interceptor.getClass().getName());         }   Signature[] sigs = interceptsAnnotation.value();   Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = new HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;();   for (Signature sig : sigs) {     Set&lt;Method&gt; methods = signatureMap.get(sig.type());     if (methods == null) {       methods = new HashSet&lt;Method&gt;();       signatureMap.put(sig.type(), methods);     }     try {       Method method = sig.type().getMethod(sig.method(), sig.args());       methods.add(method);     } catch (NoSuchMethodException e) {       throw new PluginException(&quot;Could not find method on &quot; + sig.type() + &quot; named &quot; + sig.method() + &quot;. Cause: &quot; + e, e);     }   }   return signatureMap; }</code></pre><h1 id="InterceptorChain"><a href="#InterceptorChain" class="headerlink" title="InterceptorChain"></a>InterceptorChain</h1><p>在Configuration中的个InterceptorChain该对象保存了所有配置的拦截器</p><pre><code>public class InterceptorChain {  //在mybatis-config.xml配置的拦截器  private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;Interceptor&gt;();  //用所有的拦截器生成对象  public Object pluginAll(Object target) {    for (Interceptor interceptor : interceptors) {      //调用了interceptor.plugin()方法来生成代理对象      target = interceptor.plugin(target);    }    return target;  }  public void addInterceptor(Interceptor interceptor) {    interceptors.add(interceptor);  }  public List&lt;Interceptor&gt; getInterceptors() {    return Collections.unmodifiableList(interceptors);  }}</code></pre><p>在来看pluginAll被哪些方法调用 </p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151224235252285"  alt>  </p><p>上图就充分验证发官方的如下描述</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151224235448878"  alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Mybatis是用jdk的动态代理来实现拦截器的，如果你了解jdk的动态代理，拦截器相关的源代码并不复杂，很容易就能看明白。</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之缓存的实现</title>
      <link href="/mybatis3-cache-implementation/"/>
      <url>/mybatis3-cache-implementation/</url>
      
        <content type="html"><![CDATA[<p>Mybatis主要有两种缓存：一级缓存和二级缓存。</p><p>一级缓存的生命周期与SqlSession的生命周期一样。一级缓存是在BaseExecutor中实现。</p><p>二级缓存的生命周期跟SqlSessionFactory一样，通常在整个应用中有效。二级缓存是通过CachingExecutor来实现的。</p><h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><p>Mybatis提供了如下方式来配置一级缓存:</p><pre><code>&lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION|STATEMENT&quot;/&gt;</code></pre><p>SESSION表示在整个SqlSession中有效。</p><p>STATEMENT表示在STATEMENT中有效？暂时理解为不使用一级缓存。</p><p>在BaseExecutor中会有一个localCache对象，就是来保存缓存数据的。</p><pre><code>protected BaseExecutor(Configuration configuration, Transaction transaction) {   this.transaction = transaction;   this.deferredLoads = new ConcurrentLinkedQueue&lt;DeferredLoad&gt;();   //创建一个缓存对象，PerpetualCache并不是线程安全的，但SqlSession和Executor对象在通常情况下只能有一个线程访问，而且访问完成之后马上销毁。   this.localCache = new PerpetualCache(&quot;LocalCache&quot;);   //这是执行过程中的缓存，这里不做分析。   this.localOutputParameterCache = new PerpetualCache(&quot;LocalOutputParameterCache&quot;);   this.closed = false;   this.configuration = configuration;   this.wrapper = this; }</code></pre><p>再来看BaseExecutor中的query方法是怎么实现一级缓存的</p><pre><code>public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {    BoundSql boundSql = ms.getBoundSql(parameter);    //利用sql和执行的参数生成一个key，如果同一sql不同的执行参数的话，将会生成不同的key    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);    return query(ms, parameter, rowBounds, resultHandler, key, boundSql); }  @SuppressWarnings(&quot;unchecked&quot;)  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());    if (closed) throw new ExecutorException(&quot;Executor was closed.&quot;);    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {      clearLocalCache();    }    List&lt;E&gt; list;    try {      queryStack++;      //从缓存中取出数据      list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;      if (list != null) {        //如果缓存中有数据，处理过程的缓存        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);      } else {       //如果缓存中没有数据，将sql执行生成结果，并加入localCache中。        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);      }    } finally {      queryStack--;    }    if (queryStack == 0) {      for (DeferredLoad deferredLoad : deferredLoads) {        deferredLoad.load();      }      deferredLoads.clear(); // issue #601      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {        //如果配置为STATEMENT时，将清除所有缓存。说明STATEMENT类型的查询只有queryFromDatabase方法中有效。        clearLocalCache(); // issue #482      }    }    return list;  }private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {    List&lt;E&gt; list;    localCache.putObject(key, EXECUTION_PLACEHOLDER);    try {      //执行sql生成数据      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);    } finally {      localCache.removeObject(key);    }    //将缓存加入到localCache中    localCache.putObject(key, list);    if (ms.getStatementType() == StatementType.CALLABLE) {      localOutputParameterCache.putObject(key, parameter);    }    return list;  }</code></pre><p>如果执行了update方法，localCache也会被清除：</p><pre><code>public int update(MappedStatement ms, Object parameter) throws SQLException {    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());    if (closed) throw new ExecutorException(&quot;Executor was closed.&quot;);    //每次执行update/insert/delete语句时都会清除一级缓存。    clearLocalCache();    return doUpdate(ms, parameter);  }</code></pre><p>以上代码可以看出一级缓存中的基本策略。</p><ol><li>一级缓存只在同一个SqlSession中共享数据</li><li>在同一个SqlSession对象执行相同的sql并参数也要相同，缓存才有效。</li><li>如果在SqlSession中执行update/insert/detete语句的话，SqlSession中的executor对象会将一级缓存清空。</li></ol><h1 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h1><p>二级缓存对所有的SqlSession对象都有效。需要注意如下几点：</p><ol><li>二级缓存是跟一个命名空间绑定的。</li><li>在一个SqlSession中可以执行多个不同命名空间中的sql,也是就说一个SqlSession需要对多个Cache进行操作。</li><li>调用SqlSession.commit()之后，缓存才会被加入到相应的Cache。</li></ol><p>下面来看CachingExecutor是怎么实现的。</p><pre><code>private TransactionalCacheManager tcm = new TransactionalCacheManager();</code></pre><p>这个manager实现了对多个Cache的管理，SqlSession.commit()之后，数据加入到相应的Cache也是由这个对象来实现的。</p><p>如下是CachingExecutor的commit()和rollback()方法</p><pre><code>public void commit(boolean required) throws SQLException {    //提交数据库的事务    delegate.commit(required);    //将数据刷新到Cache中，使数据对其他的SqlSession也可见    tcm.commit();  }  public void rollback(boolean required) throws SQLException {    try {      delegate.rollback(required);    } finally {      if (required) {        //清除临时的数据，不将数据刷新到Cache中        tcm.rollback();      }    }  }</code></pre><p>如下是TransactionCacheManager的源代码</p><pre><code>public class TransactionalCacheManager {  //管理了多个Cache，每个Cache对应一个TransactionalCache  private Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;Cache, TransactionalCache&gt;();  //清空未commit()的临时数据  public void clear(Cache cache) {    getTransactionalCache(cache).clear();  }  //获取缓存数据  public Object getObject(Cache cache, CacheKey key) {    return getTransactionalCache(cache).getObject(key);  }  //设置缓存数据，数据应该被保存在临时区域，只commit才会保存在cache中  public void putObject(Cache cache, CacheKey key, Object value) {    getTransactionalCache(cache).putObject(key, value);  }  //数据临时数据刷新的Cache中，使用数据对其他的SqlSession对象也可见  public void commit() {    for (TransactionalCache txCache : transactionalCaches.values()) {      txCache.commit();    }  }  //回滚，应该是清除临时区域的数据  public void rollback() {    for (TransactionalCache txCache : transactionalCaches.values()) {      txCache.rollback();    }  }  //获取对应的TransactionalCache,没有就生成一个  private TransactionalCache getTransactionalCache(Cache cache) {    TransactionalCache txCache = transactionalCaches.get(cache);    if (txCache == null) {      txCache = new TransactionalCache(cache);      transactionalCaches.put(cache, txCache);    }    return txCache;  }}</code></pre><p>再看看TransactionCache对象是怎么管理数据缓存数据的</p><pre><code>public class TransactionalCache implements Cache {  private Cache delegate;  //这个对象如果被设置为true，commit时Cache会先清除所有的数据  private boolean clearOnCommit;  //临时区域，提交时需要将数据刷新对Cache  private Map&lt;Object, AddEntry&gt; entriesToAddOnCommit;  //临时区域，提交时需要将数据从Cache中删除  private Map&lt;Object, RemoveEntry&gt; entriesToRemoveOnCommit;  public TransactionalCache(Cache delegate) {    this.delegate = delegate;    this.clearOnCommit = false;    this.entriesToAddOnCommit = new HashMap&lt;Object, AddEntry&gt;();    this.entriesToRemoveOnCommit = new HashMap&lt;Object, RemoveEntry&gt;();  }  @Override  public String getId() {    return delegate.getId();  }  @Override  public int getSize() {    return delegate.getSize();  }  @Override  public Object getObject(Object key) {    if (clearOnCommit) return null; // issue #146    return delegate.getObject(key);  }  @Override  public ReadWriteLock getReadWriteLock() {    return null;  }  @Override  public void putObject(Object key, Object object) {    entriesToRemoveOnCommit.remove(key);    //将数据放到临时区域，提交时再刷新到cache中    entriesToAddOnCommit.put(key, new AddEntry(delegate, key, object));  }  @Override  public Object removeObject(Object key) {    entriesToAddOnCommit.remove(key);    //将数据放到临时区域，提交时再从cache删除    entriesToRemoveOnCommit.put(key, new RemoveEntry(delegate, key));    return delegate.getObject(key);  }  @Override  public void clear() {    reset();    clearOnCommit = true;  }  public void commit() {    if (clearOnCommit) {      //先清除所有的数据      delegate.clear();    } else {      for (RemoveEntry entry : entriesToRemoveOnCommit.values()) {        //从cache中删除数据        entry.commit();      }    }    for (AddEntry entry : entriesToAddOnCommit.values()) {      //将数据刷新到cache      entry.commit();    }    reset();  }  public void rollback() {    reset();  }  //清空临时区域  private void reset() {    clearOnCommit = false;    entriesToRemoveOnCommit.clear();    entriesToAddOnCommit.clear();  }  private static class AddEntry {    private Cache cache;    private Object key;    private Object value;    public AddEntry(Cache cache, Object key, Object value) {      this.cache = cache;      this.key = key;      this.value = value;    }    public void commit() {      //加数据      cache.putObject(key, value);    }  }  private static class RemoveEntry {    private Cache cache;    private Object key;    public RemoveEntry(Cache cache, Object key) {      this.cache = cache;      this.key = key;    }    public void commit() {      //删除数据      cache.removeObject(key);    }  }}</code></pre><p>总结以上代码重要的几点</p><ol><li><p>TransactionCache.put()方法是先将数据保存在临时的数据区域,并未在Cache加入数据  </p></li><li><p>TransactionCache.remove()方法是先在一个临时区域中保存要删除的数据，并未在Cache中删除数据  </p></li><li><p>TransactionCache.commit()方法将保存在临时区域的数据真正加入Cache中，将临时区域中需要删除的数据真正删除  </p></li><li><p>TransactionCache.rollback()方法，只是清除了临时区域中的数据  </p></li><li><p>TransactionCache.clear()方法，告诉commit()方法，先清除缓存的数据，再执行后续操作。但clear方法本身不会清除缓存中的数据  </p></li></ol><p>下面来看CachingExecutor是怎么利用这几个方法实现缓存的</p><pre><code>&lt;p style=&quot;margin-top: 0px; margin-bottom: 0px; font-family: Monaco;&quot;&gt;&lt;/p&gt;&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {    BoundSql boundSql = ms.getBoundSql(parameterObject);    //生成一个key    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);  }  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)      throws SQLException {    //从MappedStatement获取一个Cache，如果对象的命名空间没有配置cache或cache-ref节点,cache将为空，表示不使用缓存    Cache cache = ms.getCache();    if (cache != null) {      //如果需要刷新缓存的话就刷新：flushCache=&quot;true&quot;      flushCacheIfRequired(ms);      if (ms.isUseCache() &amp;&amp; resultHandler == null) {        //userCache=&quot;true&quot;        ensureNoOutParams(ms, parameterObject, boundSql);        @SuppressWarnings(&quot;unchecked&quot;)        //从Cache获取数据        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);        if (list == null) {          //如果缓存中没有，就执行SQL生成数据          list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);          //将数据加入到临时区域          tcm.putObject(cache, key, list); // issue #578. Query must be not synchronized to prevent deadlocks        }        return list;      }    }    return delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);  }public int update(MappedStatement ms, Object parameterObject) throws SQLException {    //如果需要刷新缓存的话就刷新：flushCache=&quot;true&quot;    flushCacheIfRequired(ms);    return delegate.update(ms, parameterObject);  }private void flushCacheIfRequired(MappedStatement ms) {    Cache cache = ms.getCache();    if (cache != null &amp;&amp; ms.isFlushCacheRequired()) {        //commit()方法之后会清除所有的缓存          tcm.clear(cache);    }  }</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li>一级缓存只在一个SqlSession中有效，执行update/insert/delete语句后，一级缓存将会被清除。</li><li>二级缓存对所有的SqlSession有效，执行flushCache=”true”的语句后，二级缓存将会被清除。</li></ol><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之ResultSetHandler</title>
      <link href="/mybatis3-resultsethandler/"/>
      <url>/mybatis3-resultsethandler/</url>
      
        <content type="html"><![CDATA[<p>在PreparedStatementHandler中的query()方法中，是用ResultSetHandler来完成结果集的映射的。</p><pre><code>public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {   PreparedStatement ps = (PreparedStatement) statement;   ps.execute();   return resultSetHandler.&lt;E&gt; handleResultSets(ps); }</code></pre><p>Mybatis中只提供了一个ResultSetHandler的实现，那就是DefaultResultSetHandler。下面来看看他的handleResultSets()方法</p><pre><code>public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException {    final List&lt;Object&gt; multipleResults = new ArrayList&lt;Object&gt;();    int resultSetCount = 0;    //获取第一个ResultSet,通常只会有一个    ResultSetWrapper rsw = getFirstResultSet(stmt);    //从配置中读取对应的ResultMap，通常也只会有一个    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();    int resultMapCount = resultMaps.size();    validateResultMapsCount(rsw, resultMapCount);    while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) {      ResultMap resultMap = resultMaps.get(resultSetCount);      //完成映射，将结果加到入multipleResults中      handleResultSet(rsw, resultMap, multipleResults, null);      rsw = getNextResultSet(stmt);      cleanUpAfterHandlingResultSet();      resultSetCount++;    }    String[] resultSets = mappedStatement.getResulSets();    if (resultSets != null) {      while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) {        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);        if (parentMapping != null) {          String nestedResultMapId = parentMapping.getNestedResultMapId();          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);          handleResultSet(rsw, resultMap, null, parentMapping);        }        rsw = getNextResultSet(stmt);        cleanUpAfterHandlingResultSet();        resultSetCount++;      }    }    //如果只有一个映射，返回第一个    return collapseSingleResultList(multipleResults);  }</code></pre><p>在实际运行过程中，通常情况下一个Sql语句只返回一个结果集，对多个结果集的情况不做分析 。实际很少用到。</p><p>继续看handleResultSet方法</p><pre><code>private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException {    try {      if (parentMapping != null) {        //子映射        handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);      } else {        //一般情况resultHandler都为空,见ResultHandler.NO_RESULT_HANDLER        if (resultHandler == null) {          DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory);          //生成对象，并加到defaultResultHandler.resultList集合中          handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);          //将结果加入multipleResults中          multipleResults.add(defaultResultHandler.getResultList());        } else {          handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);        }      }    } finally {      //关闭结果集      closeResultSet(rsw.getResultSet()); // issue #228 (close resultsets)    }  }private void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException {    if (resultMap.hasNestedResultMaps()) {      //有子映射或内映射的情况      ensureNoRowBounds();      checkResultHandler();      handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);    } else {      //没有子映射或内映射      handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);    }  }  </code></pre><p>简单映射handleRowValuesForSimpleResultMap  </p><p>========================================</p><pre><code>private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping)      throws SQLException {    DefaultResultContext resultContext = new DefaultResultContext();    skipRows(rsw.getResultSet(), rowBounds);    while (shouldProcessMoreRows(rsw.getResultSet(), resultContext, rowBounds)) {      //discriminator的处理,可以根据条件选择不同的映射      ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null);      //真正从ResultSet中映射出一个对象      Object rowValue = getRowValue(rsw, discriminatedResultMap);      //加入resultHandler.resultList中      storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());    }  }   //没有内映射   private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap) throws SQLException {    final ResultLoaderMap lazyLoader = new ResultLoaderMap();    //实例化一个对象,类型为resultMap.getType(),最终调用了ObjectFactory.create()方法    Object resultObject = createResultObject(rsw, resultMap, lazyLoader, null);    if (resultObject != null &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) {      //设置对象属性      final MetaObject metaObject = configuration.newMetaObject(resultObject);      boolean foundValues = resultMap.getConstructorResultMappings().size() &gt; 0;      if (shouldApplyAutomaticMappings(resultMap, !AutoMappingBehavior.NONE.equals(configuration.getAutoMappingBehavior()))) {         //自动映射,结果集中有的column，但resultMap中并没有配置           foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, null) || foundValues;      }      //映射result节点      foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, null) || foundValues;      foundValues = lazyLoader.size() &gt; 0 || foundValues;      resultObject = foundValues ? resultObject : null;      return resultObject;    }    return resultObject;  }</code></pre><p>以上代码开始总结出简单映射(没有内映射)的逻辑</p><ol><li>每条结果都会生成一个java对象</li><li>根据构造方法实例化对象</li><li>自动映射(结果集有但在resultMap里没有配置的字段)，有两情况会发生自动映射<ol><li>在resultMap上配置了autoMapping=”true”属性</li><li>在mybatis-config.xml配置了autoMappingBehavior=”PARTIAL|FULL”，默认为PARTIAL。<br>在实际应用中，都会使用自动映射，减少配置的工作。自动映射在Mybatis中也是默认开启的。</li></ol></li><li>最后再映射属性。</li></ol><h2 id="根据构造方法实例化对象"><a href="#根据构造方法实例化对象" class="headerlink" title="根据构造方法实例化对象"></a>根据构造方法实例化对象</h2><pre><code>&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException {    //构造方法中的参数类型    final List&lt;Class&lt;?&gt;&gt; constructorArgTypes = new ArrayList&lt;Class&lt;?&gt;&gt;();    //构造方法中具体值    final List&lt;Object&gt; constructorArgs = new ArrayList&lt;Object&gt;();    //根据构造方法生成对象    final Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);    if (resultObject != null &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) {      final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();      for (ResultMapping propertyMapping : propertyMappings) {        if (propertyMapping.getNestedQueryId() != null &amp;&amp; propertyMapping.isLazy()) { // issue gcode #109 &amp;&amp; issue #149          return configuration.getProxyFactory().createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);        }      }    }    return resultObject;  }  private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix)      throws SQLException {    final Class&lt;?&gt; resultType = resultMap.getType();    //resultMap配置中的construnctor节点    final List&lt;ResultMapping&gt; constructorMappings = resultMap.getConstructorResultMappings();    if (typeHandlerRegistry.hasTypeHandler(resultType)) {      return createPrimitiveResultObject(rsw, resultMap, columnPrefix);    } else if (constructorMappings.size() &gt; 0) {      //construnctor节点有配置      return createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix);    } else {     //construnctor节点没有配置，调用无参的构造方法      return objectFactory.create(resultType);    }  }  private Object createParameterizedResultObject(ResultSetWrapper rsw, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; constructorMappings, List&lt;Class&lt;?&gt;&gt; constructorArgTypes,      List&lt;Object&gt; constructorArgs, String columnPrefix) throws SQLException {    boolean foundValues = false;    for (ResultMapping constructorMapping : constructorMappings) {      final Class&lt;?&gt; parameterType = constructorMapping.getJavaType();      final String column = constructorMapping.getColumn();      final Object value;      //取出参数类型和具体的值      if (constructorMapping.getNestedQueryId() != null) {        value = getNestedQueryConstructorValue(rsw.getResultSet(), constructorMapping, columnPrefix);      } else if (constructorMapping.getNestedResultMapId() != null) {        final ResultMap resultMap = configuration.getResultMap(constructorMapping.getNestedResultMapId());        value = getRowValue(rsw, resultMap);      } else {        final TypeHandler&lt;?&gt; typeHandler = constructorMapping.getTypeHandler();        value = typeHandler.getResult(rsw.getResultSet(), prependPrefix(column, columnPrefix));      }      constructorArgTypes.add(parameterType);      constructorArgs.add(value);      foundValues = value != null || foundValues;    }     //创建对象    return foundValues ? objectFactory.create(resultType, constructorArgTypes, constructorArgs) : null;  }</code></pre><h2 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h2><pre><code>private boolean applyAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix) throws SQLException {  //获取结果集中在resultMap中没有配置的列名  //如果resultMap中只设置了resultType=&quot;java.util.HashMap&quot;的话，全都会在这里完成映射  final List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);  boolean foundValues = false;  for (String columnName : unmappedColumnNames) {    //属性名就是列名    String propertyName = columnName;    if (columnPrefix != null &amp;&amp; columnPrefix.length() &gt; 0) {      // When columnPrefix is specified,      // ignore columns without the prefix.      if (columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) {        propertyName = columnName.substring(columnPrefix.length());      } else {        continue;      }    }    //是否有对应的属性    final String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase());    //是否有对应的set方法    if (property != null &amp;&amp; metaObject.hasSetter(property)) {      final Class&lt;?&gt; propertyType = metaObject.getSetterType(property);      if (typeHandlerRegistry.hasTypeHandler(propertyType)) {        final TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName);        final Object value = typeHandler.getResult(rsw.getResultSet(), columnName);        if (value != null || configuration.isCallSettersOnNulls()) { // issue #377, call setter on nulls          if (value != null || !propertyType.isPrimitive()) {            //直接设置            metaObject.setValue(property, value);          }          foundValues = true;        }      }    }  }  return foundValues;}</code></pre><h2 id="映射result节点"><a href="#映射result节点" class="headerlink" title="映射result节点"></a>映射result节点</h2><pre><code>private boolean applyPropertyMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, ResultLoaderMap lazyLoader, String columnPrefix)     throws SQLException {   final List&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);   boolean foundValues = false;   //获取需要映射的ResultMapping   final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();   for (ResultMapping propertyMapping : propertyMappings) {     final String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);     if (propertyMapping.isCompositeResult()          || (column != null &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH)))          || propertyMapping.getResultSet() != null) {       //在结果中的获取对应的值       Object value = getPropertyMappingValue(rsw.getResultSet(), metaObject, propertyMapping, lazyLoader, columnPrefix);       final String property = propertyMapping.getProperty(); // issue #541 make property optional       if (value != NO_VALUE &amp;&amp; property != null &amp;&amp; (value != null || configuration.isCallSettersOnNulls())) { // issue #377, call setter on nulls         if (value != null || !metaObject.getSetterType(property).isPrimitive()) {           //设置属性           metaObject.setValue(property, value);         }         foundValues = true;       }     }   }   return foundValues; }private Object getPropertyMappingValue(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)     throws SQLException {   if (propertyMapping.getNestedQueryId() != null) {     //子查询，这里就是会产生N+1次查询的地方，每个记录都会再执行一个子查询。子查询的过程这里就不在讨论了。     return getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);   } else if (propertyMapping.getResultSet() != null) {     addPendingChildRelation(rs, metaResultObject, propertyMapping);     return NO_VALUE;   } else if (propertyMapping.getNestedResultMapId() != null) {     // the user added a column attribute to a nested result map, ignore it     return NO_VALUE;   } else {     final TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();     final String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);     //直接从结果集里获取。     return typeHandler.getResult(rs, column);   } }</code></pre><h1 id="复杂映射-内映射-handleRowValuesForNestedResultMap"><a href="#复杂映射-内映射-handleRowValuesForNestedResultMap" class="headerlink" title="复杂映射(内映射)handleRowValuesForNestedResultMap"></a>复杂映射(内映射)handleRowValuesForNestedResultMap</h1><p>处理这种映射的逻辑比较复杂。这里先举例说明:</p><p>配置如下resultMap</p><pre><code>&lt;resultMap type=&quot;com.ashan.mybatis.User&quot; id=&quot;detailUserResultMap&quot;&gt;&lt;!-- 整个resultMap会被解析成一个ResultMap对应 --&gt;        &lt;constructor&gt;            &lt;idArg column=&quot;user_id&quot; javaType=&quot;String&quot;/&gt;&lt;!-- idArg会被解析成一个resultMapping对象 --&gt;            &lt;arg column=&quot;user_name&quot; javaType=&quot;String&quot;/&gt;&lt;!-- resultMapping对象 --&gt;        &lt;/constructor&gt;        &lt;result property=&quot;svcnum&quot; column=&quot;svc_num&quot; /&gt; &lt;!-- resultMapping对象 --&gt;        &lt;association property=&quot;cust&quot; javaType=&quot;com.ashan.mybatis.Cust&quot;&gt; &lt;!-- resultMapping对象 这个resultMapping对象指向了另一个ResultMap--&gt;            &lt;id property=&quot;id&quot; column=&quot;cust_id&quot;/&gt;            &lt;result property=&quot;custname&quot; column=&quot;cust_name&quot;/&gt;            &lt;result property=&quot;certNo&quot; column=&quot;cert_no&quot;/&gt;        &lt;/association&gt;        &lt;collection property=&quot;accts&quot; ofType=&quot;com.ashan.mybatis.Acct&quot;&gt;            &lt;id property=&quot;id&quot; column=&quot;acct_id&quot; /&gt;            &lt;result property=&quot;payName&quot; column=&quot;pay_name&quot;/&gt;            &lt;result property=&quot;bankNo&quot; column=&quot;bank_no&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;</code></pre><p>假设需要映射的结果集:</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151223232813379"  alt><br>可以看出，这个结果集将最终会映射成两个对象User对象，两个User对象对应的Cust对应都是cust_01，id为user_01对应的accts为：acct_01,acct_02,acct_04;user_02对应的acct只有一个acct_03。</p><h2 id="User对象映射过程"><a href="#User对象映射过程" class="headerlink" title="User对象映射过程"></a>User对象映射过程</h2><p>下面来看Mybatis是怎么生成这两个User对象的。</p><pre><code>private void handleRowValuesForNestedResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException {    final DefaultResultContext resultContext = new DefaultResultContext();    skipRows(rsw.getResultSet(), rowBounds);    Object rowValue = null;    while (shouldProcessMoreRows(rsw.getResultSet(), resultContext, rowBounds)) {      //开始处理一行新的结果集记录            final ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null);      //为这行记录生成一个key,createRowKey方法会利用idResultMapping(即idArg,和id节点)和resultMap的id来生成key      //例子中第1、2、4条记录生成的key都是一样的,大概内容为detailUserResultMap:user_01      //第3条记录生成的key大概内容为detailUserResultMap:user_02      final CacheKey rowKey = createRowKey(discriminatedResultMap, rsw, null);      //nestedResultObjects是一个HashMap对象，在映射过程中所有生成的映射对象(包括内映射对象)，都会生成一个key并保存在这里。      //例子中生成映射对象有三类：User,Cust,Acct      Object partialObject = nestedResultObjects.get(rowKey);      //如果是处理第1、3条记录，这里的parialObject为null值      //如果是处理第2、4条记录，这里的parialObject不为null      //      if (mappedStatement.isResultOrdered()) { // issue #577 &amp;&amp; #542        //先不讨论        if (partialObject == null &amp;&amp; rowValue != null) {          nestedResultObjects.clear();          storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());        }        rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, rowKey, null, partialObject);      } else {        //这个方法把结果集的记录映射成java对象        //处理第一条记录时，rowValue是新生成的User对象(user_01)其中属性cust为cust_01,accts里只有一个acct_01        //处理第二条记录时，rowValue对象就是第一条记录生成里的User对象，不过这时accts里多了一条acct_02        //处理第三条记录时，rowValue为新生成的User对象(user_02)，cust属性为cust_01,accts只有一个acct_03        //处理第四条记录时，rowValue对象就是第一条记录生成里的User对象，这时accts里又多了一条acct_04        rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, rowKey, null, partialObject);        //只有第一条记录和第三条记录partialObject才会为null        if (partialObject == null) {          //把User对象加入到resultHandler.resultList中，这里也可以看出，虽然有四条记录，但只会被映射成两个User对象          storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());        }      }    }    if (rowValue != null &amp;&amp; mappedStatement.isResultOrdered()) {      storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());    }  }</code></pre><p>接下来继续看User对象的生成过程</p><pre><code>private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, CacheKey combinedKey, CacheKey absoluteKey, String columnPrefix, Object partialObject) throws SQLException {   final String resultMapId = resultMap.getId();   Object resultObject = partialObject;   //第一和第三条记录时，partialObject为null, resultObject也为null   if (resultObject != null) {     //处理第二、四条记录里会执行这里     final MetaObject metaObject = configuration.newMetaObject(resultObject);     putAncestor(absoluteKey, resultObject, resultMapId, columnPrefix);     //直接调用内映射，即设置处理cust和accts，例子中主要是加入一个acct,因为cust只有一个，在user对象创建里就会被创建     applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, false);     ancestorObjects.remove(absoluteKey);   } else {     //处理第一、三条记录里会执行这里,说明需要创建一个新的User对象     final ResultLoaderMap lazyLoader = new ResultLoaderMap();     //创建一个user对象，跟简单映射的处理方式一样     resultObject = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);     if (resultObject != null &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) {       final MetaObject metaObject = configuration.newMetaObject(resultObject);       boolean foundValues = resultMap.getConstructorResultMappings().size() &gt; 0;       if (shouldApplyAutomaticMappings(resultMap, AutoMappingBehavior.FULL.equals(configuration.getAutoMappingBehavior()))) {         //自动映射，跟简单映射的处理方式一样,跟简单映射的处理方式一样,例子中不会执行这一步         foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;       }          //映射reulst节点，跟简单映射的处理方式一样,跟简单映射的处理方式一样 ,例子中主要映射svc_num           foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;       putAncestor(absoluteKey, resultObject, resultMapId, columnPrefix);       //调用内映射，即生成cust和acct对象并设置到User对象中       foundValues = applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, true) || foundValues;       ancestorObjects.remove(absoluteKey);       foundValues = lazyLoader.size() &gt; 0 || foundValues;       resultObject = foundValues ? resultObject : null;     }     //注意这里，生成User对象里combinedKey就是User对象的key,将新创建的两个User对象加入nestedResultObjects中，以便后续处理使用，在处理第二、四条记录里就可以使用对应的User对象了。     if (combinedKey != CacheKey.NULL_CACHE_KEY) nestedResultObjects.put(combinedKey, resultObject);   }   return resultObject; }</code></pre><p>上面是User对象的生成过程。nestedResultObjects在处理过程的作用很重要，由这个容器来控制是否需要创建新的User对象。</p><h2 id="Cust对象映射过程"><a href="#Cust对象映射过程" class="headerlink" title="Cust对象映射过程"></a>Cust对象映射过程</h2><p>再来看Cust对象是怎么生成并加入到User对象中的</p><pre><code> //处理内映射，生成内映射对象，并加入到上层对象中。这里主要根据例子分析Cust对象的生成，上层对象为Userprivate boolean applyNestedResultMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String parentPrefix, CacheKey parentRowKey, boolean newObject) {   boolean foundValues = false;   for (ResultMapping resultMapping : resultMap.getPropertyResultMappings()) {     final String nestedResultMapId = resultMapping.getNestedResultMapId();     if (nestedResultMapId != null &amp;&amp; resultMapping.getResultSet() == null) {        //resultMap中的collection,association节点都会被生成一个nestedResultMap,这里分析Cust对象，也就是association       try {         final String columnPrefix = getColumnPrefix(parentPrefix, resultMapping);         //获取内映射的ResultMap         final ResultMap nestedResultMap = getNestedResultMap(rsw.getResultSet(), nestedResultMapId, columnPrefix);         CacheKey rowKey = null;         Object ancestorObject = null;         if (ancestorColumnPrefix.containsKey(nestedResultMapId)) {           //第二、三、四记录时会执行,ancestorColumnPrefi也是一个HashMap,保存的是什么内容下面再看           //第一条记录时，肯定不会有这个对应关系           rowKey = createRowKey(nestedResultMap, rsw, ancestorColumnPrefix.get(nestedResultMapId));           //这个ancestorObjects是一个HashMap跟名字一样只会保存原始对应，也就是上层对象，这里cust和acct对象是最下层的对象了。也就是说cust和acct没有内映射了           //所以例子中ancestorObjects只会保留User对象           ancestorObject = ancestorObjects.get(rowKey);         }         if (ancestorObject != null) {            if (newObject) metaObject.setValue(resultMapping.getProperty(), ancestorObject);         } else {           //映射四条记录的Cust对应都会执行这里           //这里是生成内映射Cust的key,大概是这样的:Cust:cust_01           rowKey = createRowKey(nestedResultMap, rsw, columnPrefix);           //这里的combineKeys是跟上层对象组合成的一个key           //parentRowKey为上层对象(User对象)的key,第一、二、四条记录为user_01,第三条记录为user_02           //这样combineKey值大概为:第一、二、四条记录为user_01:cust_01,第三条记录为user_02:cust_01           final CacheKey combinedKey = combineKeys(rowKey, parentRowKey);              //从nestedResultObjects获取           //第一、三条记录rowValue是为null的,第二、四条记录与第一条记录的combinedKey一样，所以rowValue的值不一样                    Object rowValue = nestedResultObjects.get(combinedKey);           boolean knownValue = (rowValue != null);           //检查要映射的对象是否为Collection类型，这里是Cust类型，collectionProperty为null           final Object collectionProperty = instantiateCollectionPropertyIfAppropriate(resultMapping, metaObject);                       if (anyNotNullColumnHasValue(resultMapping, columnPrefix, rsw.getResultSet())) {             //生成Cust对象             //注意入参的rowValue，第一、三条记录为null             rowValue = getRowValue(rsw, nestedResultMap, combinedKey, rowKey, columnPrefix, rowValue);             if (rowValue != null &amp;&amp; !knownValue) {               //第一、三条记录时才会执行这里，第二、四条记录用的是第一条中的Cust对象，不用重复设置                                if (collectionProperty != null) {                 //User.cust属性不是集合，不会执行这里                 final MetaObject targetMetaObject = configuration.newMetaObject(collectionProperty);                 targetMetaObject.add(rowValue);               } else {                 //将生成的Cust对象设置到User对象中                 metaObject.setValue(resultMapping.getProperty(), rowValue);               }               foundValues = true;             }           }         }       } catch (SQLException e) {         throw new ExecutorException(&quot;Error getting nested result map values for &apos;&quot; + resultMapping.getProperty() + &quot;&apos;.  Cause: &quot; + e, e);       }     }   }   return foundValues; }</code></pre><p>再来看getRowValue是怎么处理Cust对象的,这个getRowValue上前讲Cust对象时的代码一样的，只不过这次是对Cust对象为分析</p><pre><code>private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, CacheKey combinedKey, CacheKey absoluteKey, String columnPrefix, Object partialObject) throws SQLException {  //partialObject，第一、三条为null,第二、四条用是的第一条里的Cust，不为null  final String resultMapId = resultMap.getId();  Object resultObject = partialObject;  if (resultObject != null) {    //第二、四条记录    final MetaObject metaObject = configuration.newMetaObject(resultObject);    putAncestor(absoluteKey, resultObject, resultMapId, columnPrefix);    //这个时间只需要处理Cust里的内映射就行了，例子中Cust没有内映射，这里将什么都不会发生    //相当对处理第二、四条记录时，这个方法什么都没做    applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, false);    ancestorObjects.remove(absoluteKey);  } else {    //第一、三条记录    final ResultLoaderMap lazyLoader = new ResultLoaderMap();    //实例化    resultObject = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);    if (resultObject != null &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) {      final MetaObject metaObject = configuration.newMetaObject(resultObject);      boolean foundValues = resultMap.getConstructorResultMappings().size() &gt; 0;      if (shouldApplyAutomaticMappings(resultMap, AutoMappingBehavior.FULL.equals(configuration.getAutoMappingBehavior()))) {        //自动映射        foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;      }              //映射result节点      foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;      putAncestor(absoluteKey, resultObject, resultMapId, columnPrefix);      //内映射，例子中Cust没有内映射      foundValues = applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, true) || foundValues;      ancestorObjects.remove(absoluteKey);      foundValues = lazyLoader.size() &gt; 0 || foundValues;      resultObject = foundValues ? resultObject : null;    }    //将新创建的Cust对象加入nestedResultObjects中    if (combinedKey != CacheKey.NULL_CACHE_KEY) nestedResultObjects.put(combinedKey, resultObject);  }  return resultObject;}</code></pre><p>从上面的代码可以看出，虽然四条记录对应的cust_id都为cust_01，按一般的ORM映射来说，在内存中四个User对象的Cust属性应该是同一个，但在这里个例子中会生成两个Cust对象。这是因为nestedResltOjects是用CombineKey，至于为什么这样做，还不知道！  </p><h2 id="Acct对象映射过程"><a href="#Acct对象映射过程" class="headerlink" title="Acct对象映射过程"></a>Acct对象映射过程</h2><p>Acct对象映射过程,还是applyNestedResultMapping方法</p><pre><code>private boolean applyNestedResultMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String parentPrefix, CacheKey parentRowKey, boolean newObject) {    boolean foundValues = false;    for (ResultMapping resultMapping : resultMap.getPropertyResultMappings()) {      final String nestedResultMapId = resultMapping.getNestedResultMapId();      if (nestedResultMapId != null &amp;&amp; resultMapping.getResultSet() == null) {        try {          final String columnPrefix = getColumnPrefix(parentPrefix, resultMapping);          final ResultMap nestedResultMap = getNestedResultMap(rsw.getResultSet(), nestedResultMapId, columnPrefix);          CacheKey rowKey = null;          Object ancestorObject = null;          if (ancestorColumnPrefix.containsKey(nestedResultMapId)) {            rowKey = createRowKey(nestedResultMap, rsw, ancestorColumnPrefix.get(nestedResultMapId));            ancestorObject = ancestorObjects.get(rowKey);          }          if (ancestorObject != null) {             if (newObject) metaObject.setValue(resultMapping.getProperty(), ancestorObject);          } else {            //四条记录都会执行这里            //四条记录都生成不同的rowKey的,大概为acct_01,acct_02,acct_03,acct_04            rowKey = createRowKey(nestedResultMap, rsw, columnPrefix);            //parentRowKey为User对象的key            //四条记录的combinedKey大概为user_01:acct_01,user_01:acct_02,user_02:acct_03,user_01:acct_04            final CacheKey combinedKey = combineKeys(rowKey, parentRowKey);                        Object rowValue = nestedResultObjects.get(combinedKey);            boolean knownValue = (rowValue != null);            //实例化集合属性            //这里User.accts对象为一个集体，instantiateCollectionPropertyIfAppropriate方法会取出accts属性的值，如果为null则创建一个,并设置到User对象中            //第一、二、四条记录返回的都是同一个，因为他们对应同一个User对象            final Object collectionProperty = instantiateCollectionPropertyIfAppropriate(resultMapping, metaObject);                        if (anyNotNullColumnHasValue(resultMapping, columnPrefix, rsw.getResultSet())) {              //生成Acct对象              rowValue = getRowValue(rsw, nestedResultMap, combinedKey, rowKey, columnPrefix, rowValue);              if (rowValue != null &amp;&amp; !knownValue) {                if (collectionProperty != null) {                  final MetaObject targetMetaObject = configuration.newMetaObject(collectionProperty);                  //加入到集合中                  targetMetaObject.add(rowValue);                } else {                  metaObject.setValue(resultMapping.getProperty(), rowValue);                }                foundValues = true;              }            }          }        } catch (SQLException e) {          throw new ExecutorException(&quot;Error getting nested result map values for &apos;&quot; + resultMapping.getProperty() + &quot;&apos;.  Cause: &quot; + e, e);        }      }    }    return foundValues;  }  private Object instantiateCollectionPropertyIfAppropriate(ResultMapping resultMapping, MetaObject metaObject) {    //属性名，这里为accts    final String propertyName = resultMapping.getProperty();    //设置值    Object propertyValue = metaObject.getValue(propertyName);    if (propertyValue == null) {      //如果为空，先看他的类型      Class&lt;?&gt; type = resultMapping.getJavaType();      if (type == null) {        type = metaObject.getSetterType(propertyName);      }      try {        if (objectFactory.isCollection(type)) {          //如果是集合类型          //生成一个集合对象          propertyValue = objectFactory.create(type);          //设置到User对象中，即User.setAccts(list)方法          metaObject.setValue(propertyName, propertyValue);          return propertyValue;        }      } catch (Exception e) {        throw new ExecutorException(&quot;Error instantiating collection property for result &apos;&quot; + resultMapping.getProperty() + &quot;&apos;.  Cause: &quot; + e, e);      }    } else if (objectFactory.isCollection(propertyValue.getClass())) {      return propertyValue;    }    return null;  }</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到此，Mybatis是怎么利用ResultSet生成对象的过程已经分析完毕。分为简单映射和复杂映射。</p><p>简单映射就是不包含内映射的resultMap</p><p>复杂映射就是包含内映射的resultMap。</p><p>复杂映射的过程比较复杂，源代码也没有一行注释，本人是写了个实例，再通过eclipse中的debuger一步步来分析的。</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之Statement初始化和参数设置</title>
      <link href="/mybatis3-statement-initialization/"/>
      <url>/mybatis3-statement-initialization/</url>
      
        <content type="html"><![CDATA[<p>在SimpleExecutor中，执行SQL时调用preareStatement()方法来对statement进行初始化及参数设置。</p><pre><code> private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {  Statement stmt;  Connection connection = getConnection(statementLog);  //初始化  stmt = handler.prepare(connection);  //参数设置`  handler.parameterize(stmt);  return stmt;}</code></pre><p>这里PreparedStatementHandler为例。详细分析这两个过程。</p><h1 id="Statement初始化"><a href="#Statement初始化" class="headerlink" title="Statement初始化"></a>Statement初始化</h1><p>这是BaseStatementHandler.prepare()方法</p><pre><code>public Statement prepare(Connection connection) throws SQLException {    ErrorContext.instance().sql(boundSql.getSql());    Statement statement = null;    try {      //通过connection得到一个statement      statement = instantiateStatement(connection);      //设置执行超时时间      setStatementTimeout(statement);      setFetchSize(statement);      return statement;    } catch (SQLException e) {      closeStatement(statement);      throw e;    } catch (Exception e) {      closeStatement(statement);      throw new ExecutorException(&quot;Error preparing statement.  Cause: &quot; + e, e);    }  }</code></pre><p>再看PreparedStatementHandler.instantiateStatement()方法</p><pre><code>protected Statement instantiateStatement(Connection connection) throws SQLException {    //被执行的SQL    String sql = boundSql.getSql();    if (mappedStatement.getKeyGenerator() instanceof Jdbc3KeyGenerator) {      String[] keyColumnNames = mappedStatement.getKeyColumns();      if (keyColumnNames == null) {        return connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);      } else {        return connection.prepareStatement(sql, keyColumnNames);      }    } else if (mappedStatement.getResultSetType() != null) {      return connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);    } else {      //直接使用jdbc的方式获取了一个PreparedStatement对象      return connection.prepareStatement(sql);    }  }</code></pre><h1 id="Statement参数设置"><a href="#Statement参数设置" class="headerlink" title="Statement参数设置"></a>Statement参数设置</h1><p>如下是PreparedStatementHandler.parameterize()方法</p><pre><code>public void parameterize(Statement statement) throws SQLException {    //直接调用了ParameterHandler的方法设置    parameterHandler.setParameters((PreparedStatement) statement);  }</code></pre><p>DefaultParamterHandler.parameterize()方法</p><pre><code>public void setParameters(PreparedStatement ps) throws SQLException {    ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());    //取出sql中的参数映射列表    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();    if (parameterMappings != null) {      for (int i = 0; i &lt; parameterMappings.size(); i++) {        ParameterMapping parameterMapping = parameterMappings.get(i);        if (parameterMapping.getMode() != ParameterMode.OUT) {          Object value;          String propertyName = parameterMapping.getProperty();          if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask first for additional params            value = boundSql.getAdditionalParameter(propertyName);          } else if (parameterObject == null) {            value = null;          } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {            value = parameterObject;          } else {            //主要通过MetaObject对象从参数出取数据，MetaObject前面已经详细分析过！            MetaObject metaObject = configuration.newMetaObject(parameterObject);            //根据参数名称获取值            value = metaObject.getValue(propertyName);          }          TypeHandler typeHandler = parameterMapping.getTypeHandler();          JdbcType jdbcType = parameterMapping.getJdbcType();          if (value == null &amp;&amp; jdbcType == null) jdbcType = configuration.getJdbcTypeForNull();          //调用对应的typeHandler设置参数          typeHandler.setParameter(ps, i + 1, value, jdbcType);        }      }    }  }</code></pre><p>TypeHandler主要有两个功能：</p><ol><li><p>设置sql执行时的参数</p></li><li><p>从结果集中取数据</p><p>public interface TypeHandler<t> {<br>  //设置参数<br>  void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;<br>  //取数据<br>  T getResult(ResultSet rs, String columnName) throws SQLException;<br>  //取数据<br>  T getResult(ResultSet rs, int columnIndex) throws SQLException;<br>  //取数据<br>  T getResult(CallableStatement cs, int columnIndex) throws SQLException;</t></p><p>}</p></li></ol><p>来看看类关系图就更清楚啦</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151222132641666"  alt></p><p>这些都Mybatis内置的TypeHandler，我们也可以自定义一个！处置枚举类型可能很有用。具体的TypeHandler不做讨论。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>分析到这里，如果是执行update/insert/delete语句，那么整个过程基本上已经完成。如果是执行select语句，还有重要的两步：结果集映射及缓存！</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之StatementHandler</title>
      <link href="/mybatis3-statementhandler/"/>
      <url>/mybatis3-statementhandler/</url>
      
        <content type="html"><![CDATA[<h1 id="SimpleExecutor执行sql过程"><a href="#SimpleExecutor执行sql过程" class="headerlink" title="SimpleExecutor执行sql过程"></a>SimpleExecutor执行sql过程</h1><p>BoundSql加载完成之后，下一步就可以执行select/update/insert/delete语句了。在SimpleExecutor中执行语句最终会由doQuery和doUpdate方法完成。</p><pre><code> public int doUpdate(MappedStatement ms, Object parameter) throws SQLException {    Statement stmt = null;    try {      Configuration configuration = ms.getConfiguration();       //生成一个StatementHandler      StatementHandler handler = configuration.newStatementHandler(this, ms, parameter, RowBounds.DEFAULT, null, null);      //执行之前的准备      stmt = prepareStatement(handler, ms.getStatementLog());      //执行sql      return handler.update(stmt);    } finally {      closeStatement(stmt);    }  }  public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {    Statement stmt = null;    try {      Configuration configuration = ms.getConfiguration();      //生成一个StatementHandler      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);      //执行之前的准备      stmt = prepareStatement(handler, ms.getStatementLog());      //执行sql      return handler.&lt;E&gt;query(stmt, resultHandler);    } finally {      closeStatement(stmt);    }  }private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {    Statement stmt;    //获取一个连接    Connection connection = getConnection(statementLog);    //由StatementHandler从connection获取一个StatementHandler    stmt = handler.prepare(connection);    //设置执行参数    handler.parameterize(stmt);    return stmt;  }</code></pre><p>从以上代码中可以到出Executor是怎么利用StatementHandler执行SQL的</p><ol><li>获取一个数据库连接</li><li>调用StatementHandler.prepare()方法获取一个statement</li><li>调用StatementHandler.parameterize()方法设置sql执行时所需要的参数</li><li>调用StatementHandler.update或query方法执行sql</li></ol><h1 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h1><p>这个接口定义了执行sql的基本操作</p><pre><code>public interface StatementHandler {  //从连接中获取一个Statement  Statement prepare(Connection connection)      throws SQLException;  //设置statement执行里所需的参数  void parameterize(Statement statement)      throws SQLException;  //批量  void batch(Statement statement)      throws SQLException;  //更新：update/insert/delete语句  int update(Statement statement)      throws SQLException;  //执行查询  &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)      throws SQLException;  BoundSql getBoundSql();  ParameterHandler getParameterHandler();}</code></pre><p>再来看他的类关系图</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151222110355356"  alt>  </p><p>跟Executor的实现非常相似。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151222111137138"  alt>  </p><p>RoutingStatementHandler  </p><p>==========================</p><p>这个类只是根据MappedStatement的配置，生成一个对应的StatementHandler(delegate),然后所有的实现都由delegate完成。</p><pre><code>private final StatementHandler delegate;  public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {    switch (ms.getStatementType()) {      case STATEMENT:        delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);        break;      case PREPARED:        delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);        break;      case CALLABLE:        delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);        break;      default:        throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());    }  }</code></pre><h1 id="BaseStatementHandler"><a href="#BaseStatementHandler" class="headerlink" title="BaseStatementHandler"></a>BaseStatementHandler</h1><p>这个类是一个模板类。其中有两个主要的属性和一个主要的方法。先来看两个属性。</p><pre><code>  //处理结果的Handler  protected final ResultSetHandler resultSetHandler;  //设置参数的Handler  protected final ParameterHandler parameterHandler;public interface ResultSetHandler {  //转换结果集  &lt;E&gt; List&lt;E&gt; handleResultSets(Statement stmt) throws SQLException;  void handleOutputParameters(CallableStatement cs) throws SQLException;}public interface ParameterHandler {  Object getParameterObject();  //设置SQL执行的参数  void setParameters(PreparedStatement ps)      throws SQLException;}</code></pre><p>这ParameterHandler和ResultSetHandler在Mybatis中都只有一个实现：DefaultParameterHandler和DefaultResultSetHandler。之后会有详细有分析。</p><p>Prepare方法</p><pre><code>public Statement prepare(Connection connection) throws SQLException {    ErrorContext.instance().sql(boundSql.getSql());    Statement statement = null;    try {      //这个方法是抽象的，由子类实现      statement = instantiateStatement(connection);      //设置执行的超时时间      setStatementTimeout(statement);      //fetchSize，对大的结果集才有明显的效果      setFetchSize(statement);      return statement;    } catch (SQLException e) {      closeStatement(statement);      throw e;    } catch (Exception e) {      closeStatement(statement);      throw new ExecutorException(&quot;Error preparing statement.  Cause: &quot; + e, e);    }  }</code></pre><h1 id="BaseStatementHandler子类"><a href="#BaseStatementHandler子类" class="headerlink" title="BaseStatementHandler子类"></a>BaseStatementHandler子类</h1><ol><li>PreparedStatementHandler,处理PreparedStatement对象，即带参数运行的SQL,这个类以后详细分析。</li><li>CallableStatementHandler,处理CallableStatement对象，即执行过程的SQL,不做讨论。</li><li>SimpleStatementHandler,处理Statement对象，即不带参数运行的SQL,不做讨论。</li></ol><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之BoundSql的加载-2</title>
      <link href="/mybatis3-boundsql-load-2/"/>
      <url>/mybatis3-boundsql-load-2/</url>
      
        <content type="html"><![CDATA[<p>前面分析到SqlNode.apply()后，Sql还是个半成品。只处理了”${}”这种占位符，”#{}”这种占位符还没有处理，而且Sql执行时的参数也没有生成。</p><p>再来看DynamicSqlSource.getBoundSql()方法</p><pre><code> public BoundSql getBoundSql(Object parameterObject) {  DynamicContext context = new DynamicContext(configuration, parameterObject);  //这里只处理了&quot;${}&quot;占位符  rootSqlNode.apply(context);  SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);  Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass();  //这里就是处理&quot;#{}&quot;占位符的地方  SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());  //这个BoundSql就是数据库可执行的Sql,同时还包含了运行时的参数。  BoundSql boundSql = sqlSource.getBoundSql(parameterObject);  for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) {    boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());  }  return boundSql;}</code></pre><p>sqlSourceParser.parse()方法，处理方式跟前面处理”${}”占位符的基本一致。</p><pre><code>public SqlSource parse(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters) {    //处理占位符的handler    ParameterMappingTokenHandler handler = new ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);    //要处理什么样的占位符    GenericTokenParser parser = new GenericTokenParser(&quot;#{&quot;, &quot;}&quot;, handler);    //开始处理    String sql = parser.parse(originalSql);     //这个SqlSource就是一个简单的java对象    return new StaticSqlSource(configuration, sql, handler.getParameterMappings());  }</code></pre><p>再来看ParameterMappingTokenHandler是怎么处理占位符的</p><pre><code>public String handleToken(String content) {     //从参数中获取具体的值，并加入parameterMappings中     parameterMappings.add(buildParameterMapping(content));    //直接替换成一个&quot;?&quot;    //这里可以看到有多少个&quot;#{}&quot;占位符，就会生成对应个&quot;?&quot;,同时还会生成对应的parameterMappings     return &quot;?&quot;;   }   private ParameterMapping buildParameterMapping(String content) {     //这里content可以是这样子的:#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}     //parseParameterMapping()就是把这种复杂的复杂解析成Map方式     Map&lt;String, String&gt; propertiesMap = parseParameterMapping(content);     String property = propertiesMap.get(&quot;property&quot;);     //解析参数的类型,String,int or boolean ...     Class&lt;?&gt; propertyType;     if (metaParameters.hasGetter(property)) { // issue #448 get type from additional params       //在这里大部分的应该都能确定下来       propertyType = metaParameters.getGetterType(property);     } else if (typeHandlerRegistry.hasTypeHandler(parameterType)) {       propertyType = parameterType;     } else if (JdbcType.CURSOR.name().equals(propertiesMap.get(&quot;jdbcType&quot;))) {       propertyType = java.sql.ResultSet.class;     } else if (property != null) {       MetaClass metaClass = MetaClass.forClass(parameterType);       if (metaClass.hasGetter(property)) {         propertyType = metaClass.getGetterType(property);       } else {         propertyType = Object.class;       }     } else {       propertyType = Object.class;     }     //构建一个ParameterMapping对象，ParameterMapping描述的是java对象的属性与sql执行参数的对应关系。跟ResultMapping对象差不多     ParameterMapping.Builder builder = new ParameterMapping.Builder(configuration, property, propertyType);     Class&lt;?&gt; javaType = propertyType;     String typeHandlerAlias = null;     for (Map.Entry&lt;String, String&gt; entry : propertiesMap.entrySet()) {       String name = entry.getKey();       String value = entry.getValue();       //示例:#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}       if (&quot;javaType&quot;.equals(name)) {         javaType = resolveClass(value);         builder.javaType(javaType);       } else if (&quot;jdbcType&quot;.equals(name)) {         builder.jdbcType(resolveJdbcType(value));       } else if (&quot;mode&quot;.equals(name)) {         builder.mode(resolveParameterMode(value));       } else if (&quot;numericScale&quot;.equals(name)) {         builder.numericScale(Integer.valueOf(value));       } else if (&quot;resultMap&quot;.equals(name)) {         builder.resultMapId(value);       } else if (&quot;typeHandler&quot;.equals(name)) {         typeHandlerAlias = value;       } else if (&quot;jdbcTypeName&quot;.equals(name)) {         builder.jdbcTypeName(value);       } else if (&quot;property&quot;.equals(name)) {         // Do Nothing       } else if (&quot;expression&quot;.equals(name)) {         throw new BuilderException(&quot;Expression based parameters are not supported yet&quot;);       } else {         throw new BuilderException(&quot;An invalid property &apos;&quot; + name + &quot;&apos; was found in mapping #{&quot; + content + &quot;}.  Valid properties are &quot; + parameterProperties);       }     }     if (typeHandlerAlias != null) {       builder.typeHandler(resolveTypeHandler(javaType, typeHandlerAlias));     }     return builder.build();   }</code></pre><p>分析到这里，SqlSession在执行sql里已经生成了BoundSql：可执行的sql及相应的参数。下一步应该就是直接操作数据库了，如生成Statement，执行参数等等。</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之MetaObject解析</title>
      <link href="/mybatis3-metaobject/"/>
      <url>/mybatis3-metaobject/</url>
      
        <content type="html"><![CDATA[<h1 id="MetaObject"><a href="#MetaObject" class="headerlink" title="MetaObject"></a>MetaObject</h1><p>MetaObject类相当于一个工具类，Mybatis在sql参数设置和结果集映射里经常使用到这个对象。下面来详细分析一下这类。</p><p>这个类有四个属性，其中两个基本不用看。</p><pre><code>//原始的对象private Object originalObject;//对原始对象的一个包装private ObjectWrapper objectWrapper;//这两个属性基本不用，因为在Mybatis中都找不到ObjectWrapperFactory的有效实现类private ObjectFactory objectFactory;private ObjectWrapperFactory objectWrapperFactory;</code></pre><p>再看他的方法</p><pre><code>  //构造方法  private MetaObject(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory) {   this.originalObject = object;   this.objectFactory = objectFactory;   this.objectWrapperFactory = objectWrapperFactory;   if (object instanceof ObjectWrapper) {     this.objectWrapper = (ObjectWrapper) object;   } else if (objectWrapperFactory.hasWrapperFor(object)) {     this.objectWrapper = objectWrapperFactory.getWrapperFor(this, object);   } else if (object instanceof Map) {     this.objectWrapper = new MapWrapper(this, (Map) object);   } else if (object instanceof Collection) {     this.objectWrapper = new CollectionWrapper(this, (Collection) object);   } else {     this.objectWrapper = new BeanWrapper(this, object);   } } public String findProperty(String propName, boolean useCamelCaseMapping) {   return objectWrapper.findProperty(propName, useCamelCaseMapping); } public String[] getGetterNames() {   return objectWrapper.getGetterNames(); } public String[] getSetterNames() {   return objectWrapper.getSetterNames(); } public Class&lt;?&gt; getSetterType(String name) {   return objectWrapper.getSetterType(name); } public Class&lt;?&gt; getGetterType(String name) {   return objectWrapper.getGetterType(name); } public boolean hasSetter(String name) {   return objectWrapper.hasSetter(name); } public boolean hasGetter(String name) {   return objectWrapper.hasGetter(name); } //从originalObject获取属性值 public Object getValue(String name) {   PropertyTokenizer prop = new PropertyTokenizer(name);   if (prop.hasNext()) {     MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());     if (metaValue == SystemMetaObject.NULL_META_OBJECT) {       return null;     } else {       return metaValue.getValue(prop.getChildren());     }   } else {     return objectWrapper.get(prop);   } } //设置originalObject属性值 public void setValue(String name, Object value) {   PropertyTokenizer prop = new PropertyTokenizer(name);   if (prop.hasNext()) {     MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());     if (metaValue == SystemMetaObject.NULL_META_OBJECT) {       if (value == null &amp;&amp; prop.getChildren() != null) {         return; // don&apos;t instantiate child path if value is null       } else {         metaValue = objectWrapper.instantiatePropertyValue(name, prop, objectFactory);       }     }     metaValue.setValue(prop.getChildren(), value);   } else {     objectWrapper.set(prop, value);   } }//应该是对collection的操作public void add(Object element) {   objectWrapper.add(element); } //应该是对collection的操作 public &lt;e&gt; void addAll(List&lt;e&gt; list) {   objectWrapper.addAll(list); }</code></pre><p>从上面代码中可以看出MetaObject主要是封装了originalObject对象，提供了get和set的方法用于获取和设置originalObject的属性值。其中originalObject最主要的有三种类型:</p><ol><li>Map类型</li><li>Collection类型</li><li>普通的java对象，有get和set方法的对象</li></ol><p>getValue和setValue中的name参数支持复杂的属性访问：例如user.cust.custId,user.acts[0].acctId！</p><pre><code> public Object getValue(String name) {  PropertyTokenizer prop = new PropertyTokenizer(name);  if (prop.hasNext()) {    MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());    if (metaValue == SystemMetaObject.NULL_META_OBJECT) {      return null;    } else {      //这里相当于递归调用，直到最后一层。例如user.cust.custId      //第一次递归cust.custId      //第二次递归custId，这个就是真正访问要返回的      return metaValue.getValue(prop.getChildren());    }  } else {    return objectWrapper.get(prop);  }}</code></pre><p>getValue,setValue,add,addAll方法都是委托objectWrapper对象实现的。下面详细分析objectWrapper对象。</p><h1 id="MapWrapper"><a href="#MapWrapper" class="headerlink" title="MapWrapper"></a>MapWrapper</h1><pre><code>   public Object get(PropertyTokenizer prop) {    if (prop.getIndex() != null) {//accts[0]这种方式      Object collection = resolveCollection(prop, map);      return getCollectionValue(prop, collection);    } else {//userId这种方式      return map.get(prop.getName());    }  }public void set(PropertyTokenizer prop, Object value) {    if (prop.getIndex() != null) {&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px;&quot;&gt;//accts[0]这种方式&lt;/span&gt;      Object collection = resolveCollection(prop, map);      setCollectionValue(prop, collection, value);    } else {//userId这种方式      map.put(prop.getName(), value);    }  }</code></pre><p>集合类的不支持</p><pre><code>public void add(Object element) {    throw new UnsupportedOperationException();  }  public &lt;E&gt; void addAll(List&lt;E&gt; element) {    throw new UnsupportedOperationException();  }</code></pre><h1 id="CollectionWrapper"><a href="#CollectionWrapper" class="headerlink" title="CollectionWrapper"></a>CollectionWrapper</h1><p>最支持如下两个方法，其他不支持</p><pre><code>public void add(Object element) {    object.add(element);  }  public &lt;E&gt; void addAll(List&lt;E&gt; element) {    object.addAll(element);  }</code></pre><h1 id="BeanWrapper"><a href="#BeanWrapper" class="headerlink" title="BeanWrapper"></a>BeanWrapper</h1><pre><code>public Object get(PropertyTokenizer prop) {    if (prop.getIndex() != null) {//accts[0]方式      Object collection = resolveCollection(prop, object);      return getCollectionValue(prop, collection);    } else {//userId方式,反射      return getBeanProperty(prop, object);    }  } public void set(PropertyTokenizer prop, Object value) {    if (prop.getIndex() != null) {//accts[0]方式      Object collection = resolveCollection(prop, object);      setCollectionValue(prop, collection, value);    } else {//userId方法，反射      setBeanProperty(prop, object, value);    }  }</code></pre><p>集合类的不支持  </p><pre><code>public void add(Object element) {  throw new UnsupportedOperationException();}public &lt;E&gt; void addAll(List&lt;E&gt; list) {  throw new UnsupportedOperationException();}</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>MetaObject是一个工具类，提供了类似ognl和jstl这样的方式去访问map,collection及javabean。</p><p>这里举三个例子来总结MetaObject最主要的功能</p><h2 id="对Map操作"><a href="#对Map操作" class="headerlink" title="对Map操作"></a>对Map操作</h2><pre><code>&lt;span style=&quot;white-space:pre&quot;&gt;        &lt;/span&gt;Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();        MetaObject metaObject=MetaObject.forObject(map, objectFactory, objectWrapperFactory);        metaObject.setValue(&quot;UESR_ID&quot;, &quot;123412&quot;);        //相当于执行了map.put(&quot;USER_ID&quot;,&quot;123412&quot;);        Object obj=metaObject.getValue(&quot;UESR_ID&quot;);        //相当于执行了map.get(&quot;UESR_ID&quot;);</code></pre><h1 id="对JavaBean操作"><a href="#对JavaBean操作" class="headerlink" title="对JavaBean操作"></a>对JavaBean操作</h1><pre><code>&lt;span style=&quot;white-space:pre&quot;&gt;        &lt;/span&gt;User user=new User();        MetaObject metaObject=MetaObject.forObject(user, objectFactory, objectWrapperFactory);        metaObject.setValue(&quot;userId&quot;, &quot;123412&quot;);        //相当于执行了user.setUserId(&quot;123412&quot;);        Object obj=metaObject.getValue(&quot;userId&quot;);        //相当于执行了user.getUserId</code></pre><h2 id="对Collection操作"><a href="#对Collection操作" class="headerlink" title="对Collection操作"></a>对Collection操作</h2><pre><code>&lt;span style=&quot;white-space:pre&quot;&gt;    &lt;/span&gt;List&lt;Object&gt; list=new ArrayList&lt;&gt;();        MetaObject metaObject=MetaObject.forObject(list, objectFactory, objectWrapperFactory);        metaObject.add(&quot;ashan&quot;);        //相当于执行了list.add(&quot;ashan&quot;);        metaObject.getValue(&quot;[0]&quot;);        //相当于执行了list.get(0);</code></pre><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之BoundSql的加载-1</title>
      <link href="/mybatis3-boundsql-1/"/>
      <url>/mybatis3-boundsql-1/</url>
      
        <content type="html"><![CDATA[<p>整理完SqlSession和Executor的关系之后，接下来看看一条sql是怎么被解析执行的。</p><p>如下例:</p><pre><code>public static void queryUser(SqlSessionFactory sqlSessionFactory)    {        SqlSession sqlSession=sqlSessionFactory.openSession();        try        {            Map&lt;String,Object&gt; param=new HashMap&lt;&gt;();            param.put(&quot;userId&quot;, &quot;21458594739&quot;);            //sqlSession.selectList方法就是要详细分析的方法            List&lt;User&gt; list=sqlSession.selectList(&quot;com.ashan.user.selectUserDetail&quot;, param);            System.out.println(list);            sqlSession.commit();        }        catch(Exception e)        {            sqlSession.rollback();        }        finally        {            sqlSession.close();        }    }</code></pre><p>对应的配置文件:</p><pre><code>&lt;resultMap type=&quot;com.ashan.mybatis.User&quot; id=&quot;detailUserResultMap&quot;&gt;        &lt;constructor&gt;            &lt;idArg column=&quot;user_id&quot; javaType=&quot;String&quot;/&gt;            &lt;arg column=&quot;user_name&quot;/&gt;        &lt;/constructor&gt;        &lt;result property=&quot;password&quot; column=&quot;user_pwd&quot; /&gt;        &lt;result property=&quot;type&quot; column=&quot;user_type&quot; javaType=&quot;com.ashan.mybatis.UserType&quot;                typeHandler=&quot;com.ashan.mybatis.UserTypeHandler&quot;/&gt;        &lt;result property=&quot;svcnum&quot; column=&quot;svc_num&quot; /&gt;         &lt;association property=&quot;cust&quot; javaType=&quot;com.ashan.mybatis.Cust&quot;&gt;             &lt;id property=&quot;id&quot; column=&quot;cust_id&quot;/&gt;            &lt;result property=&quot;custname&quot; column=&quot;cust_name&quot;/&gt;            &lt;result property=&quot;certNo&quot; column=&quot;cert_no&quot;/&gt;        &lt;/association&gt;        &lt;collection property=&quot;accts&quot; ofType=&quot;com.ashan.mybatis.Acct&quot;&gt;            &lt;id property=&quot;id&quot; column=&quot;acct_id&quot; /&gt;            &lt;result property=&quot;payName&quot; column=&quot;pay_name&quot;/&gt;            &lt;result property=&quot;bankNo&quot; column=&quot;bank_no&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectUserDetail&quot; resultMap=&quot;detailUserResultMap&quot;&gt;        &lt;![CDATA[            select user_id,user_name,user_type,cust_id                from tf_f_user a                 where a.user_id=#${userId}         ]]&gt;    &lt;/select&gt;</code></pre><h1 id="DefaultSqlSession-selectList方法"><a href="#DefaultSqlSession-selectList方法" class="headerlink" title="DefaultSqlSession.selectList方法"></a>DefaultSqlSession.selectList方法</h1><pre><code>public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) {  //RowBounds表示查询的范围，一般在分页时用到  return this.selectList(statement, parameter, RowBounds.DEFAULT);}public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {  try {     //从Configuration获取一个MappedStatement配置    MappedStatement ms = configuration.getMappedStatement(statement);    //直接调用executor.query()方法    List&lt;E&gt; result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);    return result;  } catch (Exception e) {    throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);  } finally {    ErrorContext.instance().reset();  }}</code></pre><p>从上可以看到sqlSession.selectList方法非常简单，他是用executor来完成查询的。再看看BaseExecutor对查询的实现:</p><pre><code>public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {    //获取一个BoundSql，这个BoundSql的获取过程就是本节要详细讨论的    BoundSql boundSql = ms.getBoundSql(parameter);    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);    return query(ms, parameter, rowBounds, resultHandler, key, boundSql); }</code></pre><h1 id="BoundSql类定义"><a href="#BoundSql类定义" class="headerlink" title="BoundSql类定义"></a>BoundSql类定义</h1><p>如下是BoundSql的源代码</p><pre><code>/** * An actual SQL String got form an {@link SqlSource} after having processed any dynamic content. * The SQL may have SQL placeholders &quot;?&quot; and an list (ordered) of an parameter mappings  * with the additional information for each parameter (at least the property name of the input object to read  * the value from).  * &lt;/br&gt; * Can also have additional parameters that are created by the dynamic language (for loops, bind...). *//** * @author Clinton Begin */public class BoundSql {  //经过处理的sql,这个sql已经可以被数据库执行了  private String sql;  //sql中的参数映射，只是映射，没有包含实际的值  private List&lt;ParameterMapping&gt; parameterMappings;  //客户端执行sql时传入的参数  private Object parameterObject;  //暂时不讨论  private Map&lt;String, Object&gt; additionalParameters;  //暂时不讨论  private MetaObject metaParameters;  public BoundSql(Configuration configuration, String sql, List&lt;ParameterMapping&gt; parameterMappings, Object parameterObject) {    this.sql = sql;    this.parameterMappings = parameterMappings;    this.parameterObject = parameterObject;    this.additionalParameters = new HashMap&lt;String, Object&gt;();    this.metaParameters = configuration.newMetaObject(additionalParameters);  }  public String getSql() {    return sql;  }  public List&lt;ParameterMapping&gt; getParameterMappings() {    return parameterMappings;  }  public Object getParameterObject() {    return parameterObject;  }  public boolean hasAdditionalParameter(String name) {    return metaParameters.hasGetter(name);  }  public void setAdditionalParameter(String name, Object value) {    metaParameters.setValue(name, value);  }  public Object getAdditionalParameter(String name) {    return metaParameters.getValue(name);  }}</code></pre><p>从源代码可以看出，BoundSql只是一个简单的java对象，有两个属性比较重要</p><ol><li>sql:从解析时可以看出这个sql不是配置文件中的sql,这个sql已经经过了处理(如:占用位符的处理、动态语句的解析if、foreach等待)</li><li>parameterMappings:sql对应的参数列表</li></ol><p>举例:</p><pre><code>&lt;![CDATA[            select user_id,user_name,user_type,cust_id                from tf_f_user a                 where a.user_id=#{userId}         ]]&gt;        &lt;if test=&quot;userName!=null&quot;&gt;             and             user_name=#{userName}         &lt;/if&gt;</code></pre><p>如果执行这条sql里参数中的userName属性为空，那么sql的值将会是</p><pre><code>select user_id,user_name,user_type,cust_id                from tf_f_user a                 where a.user_id=?</code></pre><p>parameterMappings.size()大小为1，只记录了userId这个参数映射</p><p>如果userName不为空，那么sql的值将会是</p><pre><code>select user_id,user_name,user_type,cust_id                from tf_f_user a                 where a.user_id=?    and user_name=?</code></pre><p>parameterMappings.size()大小为2，记录了userId和userName两个参数映射</p><h1 id="MappedStatement-getBoundSql-方法"><a href="#MappedStatement-getBoundSql-方法" class="headerlink" title="MappedStatement.getBoundSql()方法"></a>MappedStatement.getBoundSql()方法</h1><pre><code>public BoundSql getBoundSql(Object parameterObject) {    //通过sqlSource对象获取    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);    //parameterMap一般不会配置，如下内容不讨论    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();    if (parameterMappings == null || parameterMappings.size() &lt;= 0) {      boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject);    }    // check for nested result maps in parameter mappings (issue #30)    for (ParameterMapping pm : boundSql.getParameterMappings()) {      String rmId = pm.getResultMapId();      if (rmId != null) {        ResultMap rm = configuration.getResultMap(rmId);        if (rm != null) {          hasNestedResultMaps |= rm.hasNestedResultMaps();        }      }    }    return boundSql;  }</code></pre><p>还记得sqlSource是怎么被创建的吗？(前面章节有详细说明)</p><pre><code>public SqlSource parseScriptNode() {    List&lt;SqlNode&gt; contents = parseDynamicTags(context);    MixedSqlNode rootSqlNode = new MixedSqlNode(contents);    SqlSource sqlSource = null;    if (isDynamic) {      sqlSource = new DynamicSqlSource(configuration, rootSqlNode);    } else {      sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType);    }    return sqlSource;  }</code></pre><h1 id="DynamicSqlSource-getBoundSql-方法"><a href="#DynamicSqlSource-getBoundSql-方法" class="headerlink" title="DynamicSqlSource.getBoundSql()方法"></a>DynamicSqlSource.getBoundSql()方法</h1><pre><code>public class DynamicSqlSource implements SqlSource {  private Configuration configuration;  private SqlNode rootSqlNode;  public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) {    this.configuration = configuration;    this.rootSqlNode = rootSqlNode;  }  public BoundSql getBoundSql(Object parameterObject) {    DynamicContext context = new DynamicContext(configuration, parameterObject);    //sqlNode使用组合模式实现，他有多个SqlNode对象    //每个SqlNode的apply方法调用时，都为将sql加到context中，最终通过context.getSql()得到完整的sql    rootSqlNode.apply(context);    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);    Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass();    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);    for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) {      boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());    }    return boundSql;  }}</code></pre><p>DynamicContext可以看成是一个sql的容器，sqlNode的apply()方法会往这个容器上加sql.</p><p>DynamicContext动态上下文  </p><p>======================</p><p>这个类有两重要的属性</p><pre><code>//参数上下文，ContextMap为一个Mapprivate final ContextMap bindings;//sql,sqlNode中的apply()方法调用了appendSql(text)方法，最终会将sql保存在这个属性中private final StringBuilder sqlBuilder = new StringBuilder(); public void appendSql(String sql) {  sqlBuilder.append(sql);  sqlBuilder.append(&quot; &quot;);}public String getSql() {  return sqlBuilder.toString().trim();}</code></pre><p>再看看参数上下文</p><pre><code>static class ContextMap extends HashMap&lt;String, Object&gt; {    private static final long serialVersionUID = 2977601501966151582L;    //这个对运行时的参数进行了包装    private MetaObject parameterMetaObject;    public ContextMap(MetaObject parameterMetaObject) {      this.parameterMetaObject = parameterMetaObject;    }    @Override    public Object put(String key, Object value) {      return super.put(key, value);    }    //这个方法才是最重要的    @Override    public Object get(Object key) {      String strKey = (String) key;      //如果自身的map里      if (super.containsKey(strKey)) {        return super.get(strKey);      }      if (parameterMetaObject != null) {        //从参数里找        Object object = parameterMetaObject.getValue(strKey);        // issue #61 do not modify the context when reading//        if (object != null) { //          super.put(strKey, object);//        }        return object;      }      return null;    }</code></pre><p>这里举两个例子来说明ContextMap,其中MetaObject将在下一章节详细讨论</p><ol><li><p>参数为Map类型</p><pre><code>Map paraMap=new HashMap();paraMap.put(&quot;userId&quot;,&quot;12341234&quot;);paraMap.put(&quot;userName&quot;,&quot;ashan&quot;);List&lt;User&gt; list=sqlSession.selectList(&quot;dao.selectUser&quot;,paraMap);</code></pre></li></ol><ol start="2"><li>参数为为一个普通的java对象</li></ol><pre><code>   User user=new User();user.setUserId(&quot;12341234&quot;);user.setUserName(&quot;ashan&quot;);                    List&lt;User&gt; list=sqlSession.selectList(&quot;dao.selectUser&quot;,user);</code></pre><p>以上两种方式是最常见的参数设置方式，调用ContextMap.get(“userId”)方法之后，都能得到”12341234”！这就是ContextMap提供的功能。  </p><p>SqlSource与SqlNode  </p><p>====================</p><p>下面详细分析apply()方法。</p><p>例如：DynamicSqlSource是从如下配置加载的</p><pre><code>&lt;![CDATA[            select user_id,user_name,user_type,cust_id                from tf_f_user a                 where a.user_id=#{userId}         ]]&gt;        &lt;if test=&quot;userName!=null&quot;&gt;             and             user_name=${userName}         &lt;/if&gt;</code></pre><p>这个DynamicSqlSoure的结构如下(以上面的SQL为例),</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151221105942363"  alt>  </p><p>结合例子说明一下sql在sqlNode中是怎么分布的</p><ol><li>StaticTextSqlNode1:保存了”select user_id,user_name,user_type,cust_id”</li><li>StaticTextSqlNode2:保存了”from tf_f_user a”</li><li>TextSqlNode3:保存了”where a.user_id=#{userId}”,同时标识为动态的,因为他有占位符</li><li>StaticTextSqlNode4:保存了”and”</li><li>TextSqlNode5:保存了”user_name=#{userName}”</li><li>IfSqlNode:保存了其test属性值，StaticTextSqlNode4和TextSqlNode5是否加入的context中也是由其控制的</li></ol><p>接下来看看每一种SqlNode是怎么解析sql并生成parameterMapping的</p><h1 id="StaticTextSqlNode-apply-方法"><a href="#StaticTextSqlNode-apply-方法" class="headerlink" title="StaticTextSqlNode.apply()方法"></a>StaticTextSqlNode.apply()方法</h1><pre><code>public boolean apply(DynamicContext context) {   context.appendSql(text);   return true; }</code></pre><p>只是简单的把对应的test追加到context中。</p><p>所以StaticTextSqlNode1和StaticTextSqlNode2的apply方法执行后,DynamicContext中的sql内容为:</p><pre><code>select  user_id,user_name,user_type,cust_id from tf_f_user a</code></pre><h1 id="TextSqlNode-apply-方法"><a href="#TextSqlNode-apply-方法" class="headerlink" title="TextSqlNode.apply()方法"></a>TextSqlNode.apply()方法</h1><pre><code>public boolean apply(DynamicContext context) {    //GenericTokenParser为一个占用符解析器    //BindingTokenParsery为一个TohenHandler:解析具体的占位符    GenericTokenParser parser = createParser(new BindingTokenParser(context));    context.appendSql(parser.parse(text));    return true;  } private GenericTokenParser createParser(TokenHandler handler) {    //解析${tab_name}这种占位符，注意不是这种#{propertyName}    return new GenericTokenParser(&quot;${&quot;, &quot;}&quot;, handler);  }</code></pre><p>再看看GenericTokenParser.parse()方法:</p><pre><code>public String parse(String text) {    StringBuilder builder = new StringBuilder();    if (text != null &amp;&amp; text.length() &gt; 0) {      char[] src = text.toCharArray();      int offset = 0;      int start = text.indexOf(openToken, offset);      while (start &gt; -1) {        if (start &gt; 0 &amp;&amp; src[start - 1] == &apos;\\&apos;) {          // the variable is escaped. remove the backslash.          builder.append(src, offset, start - 1).append(openToken);          offset = start + openToken.length();        } else {          int end = text.indexOf(closeToken, start);          if (end == -1) {            builder.append(src, offset, src.length - offset);            offset = src.length;          } else {            builder.append(src, offset, start - offset);            offset = start + openToken.length();            String content = new String(src, offset, end - offset);            //关键是这句，调用了handler.handleToken()方法            builder.append(handler.handleToken(content));            offset = end + closeToken.length();          }        }        start = text.indexOf(openToken, offset);      }      if (offset &lt; src.length) {        builder.append(src, offset, src.length - offset);      }    }    return builder.toString();  }</code></pre><p>认真分析上面的代码，最关键的是调用了handler.handleToken(content)方法</p><p>如果text为:select ${primary_key},${col_name} from ${tab_name)，那么handler.handleToken()方法会被调用三次，分别为：</p><ol><li>handler.handleToken(“primary_key”)</li><li>handler.handleToken(“col_name”)</li><li>handler.handleToken(“tab_name”)</li></ol><p>再来看BindingTokenParser.handleToken()方法</p><pre><code>public String handleToken(String content) {      Object parameter = context.getBindings().get(&quot;_parameter&quot;);      if (parameter == null) {        context.getBindings().put(&quot;value&quot;, null);      } else if (SimpleTypeRegistry.isSimpleType(parameter.getClass())) {        context.getBindings().put(&quot;value&quot;, parameter);      }      //从ContextMap中取出content对应的值返回      Object value = OgnlCache.getValue(content, context.getBindings());      return (value == null ? &quot;&quot; : String.valueOf(value)); // issue #274 return &quot;&quot; instead of &quot;null&quot;    }</code></pre><p>从上面可以看到TextSqlNode.apply()，只会处理”${}”这种占位符，而不会处理这种占位符:”#{}”</p><p>所以当TextSqlNode3.apply()执行完成之后，DynamicContext中的sql内容为:</p><pre><code>select  user_id,user_name,user_type,cust_id from tf_f_user a where user_id=#{userId}</code></pre><h1 id="IfSqlNode-apply-方法"><a href="#IfSqlNode-apply-方法" class="headerlink" title="IfSqlNode.apply()方法"></a>IfSqlNode.apply()方法</h1><pre><code>public boolean apply(DynamicContext context) {  //动态执行test属性中表达式，如果返回true，才会执行对应的SqlNode.apply()方法  if (evaluator.evaluateBoolean(test, context.getBindings())) {    contents.apply(context);    return true;  }  return false;`}</code></pre><p>结合上例，当IfSqlNode.apply()方法执行后，有两种情况：</p><p>如果参数中的userName不为空的话,DynamicContext中的sql内容为:</p><pre><code>select  user_id,user_name,user_type,cust_id from tf_f_user a where user_id=#{userId} and user_name=#{userName}</code></pre><p>如果参数呻的userName为空的话，DynamicContext中的sql内容为:</p><pre><code>select  user_id,user_name,user_type,cust_id from tf_f_user a where user_id=#{userId}</code></pre><p>ForEachSqlNode和ChooseSqlNode的实现原理跟IfSqlNode实现差不多，这里不做讨论!  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>SqlNode.apply()方法生成的sql也只是半成品，并没有处理”#{}”占位符！这个占位符的处理后续再分析。</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之Executor接口实现方式</title>
      <link href="/mybatis3-executor/"/>
      <url>/mybatis3-executor/</url>
      
        <content type="html"><![CDATA[<p>之前介绍过，Executor接口定义了对象操作库操作的基本方法：select/update/insert/delete/commit/rollbak/close。Mybatis对Executor接口的实现主要采用了模板模式和装饰模式两种设计模式。</p><h1 id="Executor类关系"><a href="#Executor类关系" class="headerlink" title="Executor类关系"></a>Executor类关系</h1><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151220223216683"  alt>  </p><p>其中CloseExecutor为一个类的内部了，而且是private的，先不讨论！</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151220224146815"  alt>  </p><ol><li>BaseExecutor为模板模式中的模板类。这个类在Executor接口实现中非常重要，其实现了Executor的大部分方法。他的子类只要实现三个方法即可，其中两个是doUpdate和doSelect方法，子类在实现这两个方法时直接操作数据库即可，其余的工作交由BaseExecutor完成。</li><li>CachingExecutor是一个Executor的装饰器，给一个Executor增加了缓存的功能。</li></ol><p>模板模式和装饰模式前面分析加载Configuration中也用到，说明这个设计模式的重要性，这两种设计模式也在Spring中很多地方采用。作为java程序员应该详细解读并应用这两种设计模式！</p><h1 id="Executor接口主要方法"><a href="#Executor接口主要方法" class="headerlink" title="Executor接口主要方法"></a>Executor接口主要方法</h1><pre><code>public interface Executor {   //执行update/insert/delete  int update(MappedStatement ms, Object parameter) throws SQLException;  //执行查询  &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql) throws SQLException;  //执行查询  &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException;  //以后有机会在分析   List&lt;BatchResult&gt; flushStatements() throws SQLException;  //事务提交  void commit(boolean required) throws SQLException;  //事务回滚  void rollback(boolean required) throws SQLException;  //生成缓存的key  CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql);  boolean isCached(MappedStatement ms, CacheKey key);  void clearLocalCache();  void deferLoad(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType);  Transaction getTransaction();  void close(boolean forceRollback);  boolean isClosed();  void setExecutorWrapper(Executor executor);}</code></pre><h1 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h1><p>再来看看BaseExcutor模板是怎么实现Executor的</p><p>BaseExecutor有两个主要的属性:事务及本地缓存</p><pre><code>protected BaseExecutor(Configuration configuration, Transaction transaction) {    //transaction，实现commit/rollback/close    this.transaction = transaction;    this.deferredLoads = new ConcurrentLinkedQueue&lt;DeferredLoad&gt;();    //本地缓存，也就是一级缓存    this.localCache = new PerpetualCache(&quot;LocalCache&quot;);    this.localOutputParameterCache = new PerpetualCache(&quot;LocalOutputParameterCache&quot;);    this.closed = false;    this.configuration = configuration;    this.wrapper = this;  }</code></pre><p>再来看看BaseExecutor是怎么实现查询和更新的</p><pre><code>public int update(MappedStatement ms, Object parameter) throws SQLException {    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());    if (closed) throw new ExecutorException(&quot;Executor was closed.&quot;);    clearLocalCache();    //调用了doUpdate方法完成更新，这个方法是抽象的，由子类实现    return doUpdate(ms, parameter);  } protected abstract int doUpdate(MappedStatement ms, Object parameter)      throws SQLException;   //查询  private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {    List&lt;E&gt; list;    localCache.putObject(key, EXECUTION_PLACEHOLDER);    try {     //调用doQuery方法，这个方法也是抽象的      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);    } finally {      localCache.removeObject(key);    }    localCache.putObject(key, list);    if (ms.getStatementType() == StatementType.CALLABLE) {      localOutputParameterCache.putObject(key, parameter);    }    return list;  }protected abstract &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)      throws SQLException;</code></pre><h1 id="CachingExecutor实现缓存"><a href="#CachingExecutor实现缓存" class="headerlink" title="CachingExecutor实现缓存"></a>CachingExecutor实现缓存</h1><pre><code>public CachingExecutor(Executor delegate) {   //操作数据库的动作都是由这个Executor来完成的。   this.delegate = delegate;   delegate.setExecutorWrapper(this); }</code></pre><p>对于Mybatis的缓存以后再详细分析。</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之SqlSession创建及简要说明</title>
      <link href="/mybatis3-sqlsession-creation/"/>
      <url>/mybatis3-sqlsession-creation/</url>
      
        <content type="html"><![CDATA[<h1 id="SqlSession的使用简单"><a href="#SqlSession的使用简单" class="headerlink" title="SqlSession的使用简单"></a>SqlSession的使用简单</h1><p>在得到SqlSessionFactory之后就可以创建一个SqlSession对象了，SqlSession对象的生命周期通常像如下方法所示：</p><pre><code>public static void useSqlSession(SqlSessionFactory sqlSessionFactory)    {        //在通过SqlSessionFactory获取一个SqlSession        SqlSession sqlSession=sqlSessionFactory.openSession();        //用标准的try/catch/finally写法操作数据库        try        {            //select            //update等待操作            //提交事务            sqlSession.commit();        }        catch(Exception e)        {            //出错，回滚事务            sqlSession.rollback();        }        finally        {            //关闭            sqlSession.close();        }    }</code></pre><h1 id="SqlSession接口定义"><a href="#SqlSession接口定义" class="headerlink" title="SqlSession接口定义"></a>SqlSession接口定义</h1><p>SqlSession定义了操作数据库的基本，这个Mybatis定义的用户层接口，使用该接口基本能满足用户(调用客户端)访问数据库的基本要求。由于接口定义的代码和注释比较多，这里就不贴了。其主要的方法如下:</p><ol><li>select类方法</li><li>update/insert/delete方法</li><li>commit()</li><li>rollback()</li><li>close()</li></ol><p>如果了解过jdbc,肯定知道这些方法的用途！</p><h1 id="SqlSession的创建过程"><a href="#SqlSession的创建过程" class="headerlink" title="SqlSession的创建过程"></a>SqlSession的创建过程</h1><p>SqlSessionFactoryBuilder.build()方法会创建一个DefaultSqlSessionFactory对象</p><pre><code>public SqlSessionFactory build(Configuration config) {   return new DefaultSqlSessionFactory(config); }</code></pre><p>我们再来看DefaultSqlSessionFactory.openSession()方法</p><pre><code>public SqlSession openSession() {   return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false); } //这个是最终创建SqlSession对象的方法，需要三个参数 //execType,这个示例使用的是configuration.getDefaultExecutorType(),即在Configuration默认配置的 //事务隔离等级，我们对数据库操作里一般都不会带这个属性，这个属性由数据库分配即可 //autoCommit:这个一般都是false，不然事务将没有意义 private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {   Transaction tx = null;   try {     final Environment environment = configuration.getEnvironment();     //获取一个事务工厂，这个也是在配置文件中配置的     final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);     //通过事务工厂获取一个事务     tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);     //根据execType获取一个Executor,这个稍后再详细讨论     final Executor executor = configuration.newExecutor(tx, execType);     //创建SqlSession对象，这里创建的DefaultSqlSession     return new DefaultSqlSession(configuration, executor, autoCommit);   } catch (Exception e) {     closeTransaction(tx); // may have fetched a connection so lets call close()     throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);   } finally {     ErrorContext.instance().reset();   } }</code></pre><p>查看XMLConfigBuilder，可以看到默认的execType为SIMPLE</p><pre><code>configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty(&quot;defaultExecutorType&quot;, &quot;SIMPLE&quot;)));</code></pre><p>即为SimpleExecutor</p><pre><code>public Executor newExecutor(Transaction transaction, ExecutorType executorType) {    executorType = executorType == null ? defaultExecutorType : executorType;    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;    Executor executor;    if (ExecutorType.BATCH == executorType) {      executor = new BatchExecutor(this, transaction);    } else if (ExecutorType.REUSE == executorType) {      executor = new ReuseExecutor(this, transaction);    } else {      //默认      executor = new SimpleExecutor(this, transaction);    }    if (cacheEnabled) {      executor = new CachingExecutor(executor);    }    executor = (Executor) interceptorChain.pluginAll(executor);    return executor;  }</code></pre><p>而事务工厂则是通过xml里配置的,也就是JdbcTransactionFactory</p><pre><code>&lt;environment id=&quot;development&quot;&gt;&lt;!-- 开发环境 --&gt;                        //事务工厂            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;</code></pre><p>再来看DefaultSqlSession中五个重要的方法</p><pre><code> //执行查询语句 public &lt;e&gt; List&lt;e&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {  try {    MappedStatement ms = configuration.getMappedStatement(statement);   //交由executor处理    List&lt;e&gt; result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);    return result;  } catch (Exception e) {    throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);  } finally {    ErrorContext.instance().reset();  }}//操作update/insert/delete语句public int update(String statement, Object parameter) {  try {    dirty = true;    MappedStatement ms = configuration.getMappedStatement(statement);    //交由executor处理    return executor.update(ms, wrapCollection(parameter));  } catch (Exception e) {    throw ExceptionFactory.wrapException(&quot;Error updating database.  Cause: &quot; + e, e);  } finally {    ErrorContext.instance().reset();  }} //事务提交 public void commit(boolean force) {  try {   //交由executor处理    executor.commit(isCommitOrRollbackRequired(force));    dirty = false;  } catch (Exception e) {    throw ExceptionFactory.wrapException(&quot;Error committing transaction.  Cause: &quot; + e, e);  } finally {    ErrorContext.instance().reset();  }} //事务回滚 public void rollback(boolean force) {  try {   //交由executor处理    executor.rollback(isCommitOrRollbackRequired(force));    dirty = false;  } catch (Exception e) {    throw ExceptionFactory.wrapException(&quot;Error rolling back transaction.  Cause: &quot; + e, e);  } finally {    ErrorContext.instance().reset();  }} //关闭 public void close() {  try {   //交由executor处理    executor.close(isCommitOrRollbackRequired(false));    dirty = false;  } finally {    ErrorContext.instance().reset();  }}</code></pre><p>由上面方法可以看出，DefaultSqlSession主要的操作都是交由Executor处理，这应该是设计模式中的适配器模式！  </p><p>在看executor的五个方法，可以整理出如下关系。</p><ol><li>DefaultSqlSession持有一个Executor对象，默认为SimpleExecutor，如果没有设置缓存的话。</li><li>Executor持有一个Transaction对象</li><li>DefaultSqlSession将select/update/insert/delete/commit/rollback/close交由Executor处理</li><li>Executor又将commit/rollback/close方法交由Transaction处理</li><li>DefaultSqlSession/Executor/Transaction对象都在DefaultSqlSessionFactory.openSessionFromDataSource方法中创建</li></ol><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151220000322839"  alt></p><h1 id="SqlSessionFactory和SqlSession对象的范围和线程安全"><a href="#SqlSessionFactory和SqlSession对象的范围和线程安全" class="headerlink" title="SqlSessionFactory和SqlSession对象的范围和线程安全"></a>SqlSessionFactory和SqlSession对象的范围和线程安全</h1><p>如下是官方的说明</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151220093213267"  alt>  </p><p>可以看到</p><ol><li>SqlSessionFactory可以在整个应用程序中保持一个单例，也就是它是线程安全的</li><li>SqlSession则需要每个线程持有不同的对象，也就是说它不是线程安全的。</li></ol><p>我们来看代码验证上面两点</p><h2 id="DefaultSqlSessionFactory生成SqlSession的方法"><a href="#DefaultSqlSessionFactory生成SqlSession的方法" class="headerlink" title="DefaultSqlSessionFactory生成SqlSession的方法"></a>DefaultSqlSessionFactory生成SqlSession的方法</h2><pre><code>private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {    Transaction tx = null;    try {      final Environment environment = configuration.getEnvironment();      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);      final Executor executor = configuration.newExecutor(tx, execType);      return new DefaultSqlSession(configuration, executor, autoCommit);    } catch (Exception e) {      closeTransaction(tx); // may have fetched a connection so lets call close()      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);    } finally {      ErrorContext.instance().reset();    }  }</code></pre><p>上面代码采用了线程封闭的技术，也就是说将对象封闭在当前线程范围内，保证这些对象其他线程不可见，这样就保证了自已的线程安全性。但有一个例外：就是用到了Congifuration，它是对其他线程可见的，但这个Configuration对象是实际不可变的，所以DefaultSqlSessionFactory是线程安全的。线程封闭和实际不可变对象，这两个概念在&lt;&lt;java并发编程实践&gt;&gt;一书有详细的说明。</p><h2 id="DefaultSqlSession线程安全性分析"><a href="#DefaultSqlSession线程安全性分析" class="headerlink" title="DefaultSqlSession线程安全性分析 "></a>DefaultSqlSession线程安全性分析 </h2><p>DefaultSqlSession有一个Executor对象的引用，对其的访问也没有使用线程安全的机制：</p><pre><code>public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {    try {      MappedStatement ms = configuration.getMappedStatement(statement);      //这里没有用synchronized或lock      List&lt;E&gt; result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);      return result;    } catch (Exception e) {      throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);    } finally {      ErrorContext.instance().reset();    }  }</code></pre><p>而再看BaseExecutor，这个并不是线程安全的</p><pre><code>protected BaseExecutor(Configuration configuration, Transaction transaction) {    this.transaction = transaction;    this.deferredLoads = new ConcurrentLinkedQueue&lt;DeferredLoad&gt;();    //前面对PerpetualCache已经分析过，PerpetualCache是用HashMap实现的，并不是线程安全的    this.localCache = new PerpetualCache(&quot;LocalCache&quot;);    this.localOutputParameterCache = new PerpetualCache(&quot;LocalOutputParameterCache&quot;);    this.closed = false;    this.configuration = configuration;    this.wrapper = this;  }</code></pre><p>再看他对cache的访问，也没用使用同步</p><pre><code>try {      queryStack++;      //这里访问localCache.getObject()并没有使用同步      list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;      if (list != null) {        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);      } else {        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);      }    } finally {      queryStack--;    }</code></pre><p>根据以上分析：Executor不是一线程安全的，SqlSession对他的访问没有使用同步机制，所以SqlSession并不是线程安全的。</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之加载Configuration使用到的设计模式</title>
      <link href="/mybatis3-configuration-pattern/"/>
      <url>/mybatis3-configuration-pattern/</url>
      
        <content type="html"><![CDATA[<p>设计模式无处不在，在分析Mybatis加载Configuration的过程中，发现Mybatis使用了多种的设计模式。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>下面的例子准确的来说是一个抽象工厂！</p><p>Configuration中有个属性:</p><pre><code>protected ObjectFactory objectFactory = new DefaultObjectFactory();</code></pre><p>Mybatis使用这个工厂去创建所有需要被创建的对象。</p><pre><code>/** * MyBatis uses an ObjectFactory to create all needed new Objects. *  * @author Clinton Begin */</code></pre><p>其最主要的一个方法，也就是俗称的工厂方法:</p><pre><code>/**   * Creates a new object with the specified constructor and params.   * @param type Object type   * @param constructorArgTypes Constructor argument types   * @param constructorArgs Constructor argument values   * @return   */  &lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs);</code></pre><p>这个方法主要是根据Class对象去创建实例，可以肯定这个方法的实现需要使用java的反射机制。</p><p>再看这个方法的默认实现:</p><pre><code>public &lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) {    Class&lt;?&gt; classToCreate = resolveInterface(type);    @SuppressWarnings(&quot;unchecked&quot;)    // we know types are assignable    T created = (T) instantiateClass(classToCreate, constructorArgTypes, constructorArgs);    return created;  }private &lt;T&gt; T instantiateClass(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) {    try {      Constructor&lt;T&gt; constructor;      if (constructorArgTypes == null || constructorArgs == null) {        //使用不带参数的构造方法        constructor = type.getDeclaredConstructor();        if (!constructor.isAccessible()) {          constructor.setAccessible(true);        }        //利用反射构建对象        return constructor.newInstance();      }       //带参的构造方法      constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(new Class[constructorArgTypes.size()]));      if (!constructor.isAccessible()) {        constructor.setAccessible(true);      }       //利用反射构建对象      return constructor.newInstance(constructorArgs.toArray(new Object[constructorArgs.size()]));    } catch (Exception e) {      StringBuilder argTypes = new StringBuilder();      if (constructorArgTypes != null) {        for (Class&lt;?&gt; argType : constructorArgTypes) {          argTypes.append(argType.getSimpleName());          argTypes.append(&quot;,&quot;);        }      }      StringBuilder argValues = new StringBuilder();      if (constructorArgs != null) {        for (Object argValue : constructorArgs) {          argValues.append(String.valueOf(argValue));          argValues.append(&quot;,&quot;);        }      }      throw new ReflectionException(&quot;Error instantiating &quot; + type + &quot; with invalid types (&quot; + argTypes + &quot;) or values (&quot; + argValues + &quot;). Cause: &quot; + e, e);    }  }</code></pre><p>我们完全可以实现一个ObjectFactory，通过如下配置让Mybatis使用自定义的ObjectFacotry</p><pre><code>&lt;!-- mybatis-config.xml --&gt;&lt;objectFactory type=&quot;com.ashan.mybatis.AshanObjectFactory&quot;&gt;  &lt;property name=&quot;myProperty&quot; value=&quot;myvalue&quot;/&gt;&lt;/objectFactory&gt;</code></pre><h1 id="构建者-Builder-模式"><a href="#构建者-Builder-模式" class="headerlink" title="构建者(Builder)模式"></a>构建者(Builder)模式</h1><p>还记得XMLMapperBuilder的助手MapperBuilderAssisant吗？他就是使用构建者模式来创建ResultMap/ResultMapping/MappedStatement/Cache对象的，应该说是这个类提供了构建者模式给MapperBuilderAssisant使用。如ResultMapp.Builder：</p><pre><code>public ResultMap build() {      if (resultMap.id == null) {        throw new IllegalArgumentException(&quot;ResultMaps must have an id&quot;);      }      resultMap.mappedColumns = new HashSet&lt;String&gt;();      resultMap.idResultMappings = new ArrayList&lt;ResultMapping&gt;();      resultMap.constructorResultMappings = new ArrayList&lt;ResultMapping&gt;();      resultMap.propertyResultMappings = new ArrayList&lt;ResultMapping&gt;();      for (ResultMapping resultMapping : resultMap.resultMappings) {        resultMap.hasNestedQueries = resultMap.hasNestedQueries || resultMapping.getNestedQueryId() != null;        resultMap.hasNestedResultMaps = resultMap.hasNestedResultMaps || (resultMapping.getNestedResultMapId() != null &amp;&amp; resultMapping.getResultSet() == null);        final String column = resultMapping.getColumn();        if (column != null) {          resultMap.mappedColumns.add(column.toUpperCase(Locale.ENGLISH));        } else if (resultMapping.isCompositeResult()) {          for (ResultMapping compositeResultMapping : resultMapping.getComposites()) {            final String compositeColumn = compositeResultMapping.getColumn();            if (compositeColumn != null) {              resultMap.mappedColumns.add(compositeColumn.toUpperCase(Locale.ENGLISH));            }          }        }        if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) {          resultMap.constructorResultMappings.add(resultMapping);        } else {          resultMap.propertyResultMappings.add(resultMapping);        }        if (resultMapping.getFlags().contains(ResultFlag.ID)) {          resultMap.idResultMappings.add(resultMapping);        }      }      if (resultMap.idResultMappings.isEmpty()) {        resultMap.idResultMappings.addAll(resultMap.resultMappings);      }      // lock down collections      resultMap.resultMappings = Collections.unmodifiableList(resultMap.resultMappings);      resultMap.idResultMappings = Collections.unmodifiableList(resultMap.idResultMappings);      resultMap.constructorResultMappings = Collections.unmodifiableList(resultMap.constructorResultMappings);      resultMap.propertyResultMappings = Collections.unmodifiableList(resultMap.propertyResultMappings);      resultMap.mappedColumns = Collections.unmodifiableSet(resultMap.mappedColumns);      return resultMap;    }</code></pre><p>从上的代码来看，这个build方法比较复杂一些！</p><p>这里就都看出工厂模式与构建者模式的一个区别：工厂模式一般都是构建简单的对象，而构建者模式用来构建比较复杂的对象，不单要实例化对象，还要进行初始化、校验及其他工作。</p><h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><p>Mybatis中的Cache对象就是利用装饰器模式实现的，非常精彩！装饰器模式一般有三种角色</p><ol><li>抽象类(方法)</li><li>原始实现类</li><li>装饰实现类-利用原始实现类去实现抽象类的同时增加新功能。这个类持有一个原始实现对象，同时也实现了抽象类。</li></ol><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151219181655713"  alt>  </p><p>Mybatis中的Cache即为一个抽象接口</p><pre><code>public interface Cache {  /**   * @return The identifier of this cache   */  String getId();  /**   * @param key Can be any object but usually it is a {@link CacheKey}   * @param value The result of a select.   */  void putObject(Object key, Object value);  /**   * @param key The key   * @return The object stored in the cache.   */  Object getObject(Object key);  /**   * Optional. It is not called by the core.   *    * @param key The key   * @return The object that was removed   */  Object removeObject(Object key);  /**   * Clears this cache instance   */    void clear();  /**   * Optional. This method is not called by the core.   *    * @return The number of elements stored in the cache (not its capacity).   */  int getSize();  /**    * Optional. As of 3.2.6 this method is no longer called by the core.   *     * Any locking needed by the cache must be provided internally by the cache provider.   *    * @return A ReadWriteLock    */  ReadWriteLock getReadWriteLock();}</code></pre><p>PerpetualCache即为原始的实现。</p><pre><code>public class PerpetualCache implements Cache {  private String id;  private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;();  public PerpetualCache(String id) {    this.id = id;  }  public String getId() {    return id;  }  public int getSize() {    return cache.size();  }  public void putObject(Object key, Object value) {    cache.put(key, value);  }  public Object getObject(Object key) {    return cache.get(key);  }  public Object removeObject(Object key) {    return cache.remove(key);  }  public void clear() {    cache.clear();  }  public ReadWriteLock getReadWriteLock() {    return null;  }  public boolean equals(Object o) {    if (getId() == null) throw new CacheException(&quot;Cache instances require an ID.&quot;);    if (this == o) return true;    if (!(o instanceof Cache)) return false;    Cache otherCache = (Cache) o;    return getId().equals(otherCache.getId());  }  public int hashCode() {    if (getId() == null) throw new CacheException(&quot;Cache instances require an ID.&quot;);    return getId().hashCode();  }}</code></pre><p>对Cache的装饰实现在Mybatis中就有很多了，打开类关系图可以看到</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151219182211383"  alt></p><p>上图中除了PerpetualCache其他都是利用装饰模式实现Cache的。我们来看一个最简单的SynchronizedCache，这个类提供了线程安全的访问。</p><pre><code>public class SynchronizedCache implements Cache {  //真正实现Cache还得靠这个家伙,这个类只会把精力集中在线程安全上。  private Cache delegate;  public SynchronizedCache(Cache delegate) {    this.delegate = delegate;  }  @Override  public String getId() {    return delegate.getId();  }  @Override  public synchronized int getSize() {    return delegate.getSize();  }  //只是用了synchronized关键字  @Override  public synchronized void putObject(Object key, Object object) {    delegate.putObject(key, object);  }  @Override  public synchronized Object getObject(Object key) {    return delegate.getObject(key);  }  @Override  public synchronized Object removeObject(Object key) {    return delegate.removeObject(key);  }  @Override  public synchronized void clear() {    delegate.clear();  }  @Override  public int hashCode() {    return delegate.hashCode();  }  @Override  public boolean equals(Object obj) {    return delegate.equals(obj);  }  @Override  public ReadWriteLock getReadWriteLock() {    return null;  }}</code></pre><p>这里可以看出，装饰模式就是流水线的加工一样，使用原材料并加入特定的功能，这样经过整条流水线一来，产品的功能将越来越丰富。</p><h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>模板模式就是由父类(一般是抽象类，也叫模板类)提供一些实用的模板方法给子类使用。Spring提供的各种DaoSupport就是利用了模板模式，这样使用子类实现起来非常的爽。同时模板方法也会定义一些重要的业务流程，并且声明为final，这样方便子类的同时也约定了子类的行为。Spring中的事务管理就有这样子的运用。</p><p>在Mybatis中的XMLConfigBuilder和XMLMapperBuilder及他的助手就是用模板模式实现的。</p><p>来看看这几个类的关系图</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151219184741118"  alt>  </p><p>这个BaseBuilder就是一个模板类，提供了很多模板方法。子类有实现功能时都会用到这学模板方法。</p><pre><code> //模板类一般是抽象的 public abstract class BaseBuilder {  protected final Configuration configuration;  protected final TypeAliasRegistry typeAliasRegistry;  protected final TypeHandlerRegistry typeHandlerRegistry;  public BaseBuilder(Configuration configuration) {    this.configuration = configuration;    this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();    this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();  }  public Configuration getConfiguration() {    return configuration;  }  //如下定义的全部都是模板方法，给子类提供了便利  protected Boolean booleanValueOf(String value, Boolean defaultValue) {    return value == null ? defaultValue : Boolean.valueOf(value);  }  protected Integer integerValueOf(String value, Integer defaultValue) {    return value == null ? defaultValue : Integer.valueOf(value);  }  protected Set&lt;String&gt; stringSetValueOf(String value, String defaultValue) {    value = (value == null ? defaultValue : value);    return new HashSet&lt;String&gt;(Arrays.asList(value.split(&quot;,&quot;)));  }  protected JdbcType resolveJdbcType(String alias) {    if (alias == null) return null;    try {      return JdbcType.valueOf(alias);    } catch (IllegalArgumentException e) {      throw new BuilderException(&quot;Error resolving JdbcType. Cause: &quot; + e, e);    }  }  protected ResultSetType resolveResultSetType(String alias) {    if (alias == null) return null;    try {      return ResultSetType.valueOf(alias);    } catch (IllegalArgumentException e) {      throw new BuilderException(&quot;Error resolving ResultSetType. Cause: &quot; + e, e);    }  }  protected ParameterMode resolveParameterMode(String alias) {    if (alias == null) return null;    try {      return ParameterMode.valueOf(alias);    } catch (IllegalArgumentException e) {      throw new BuilderException(&quot;Error resolving ParameterMode. Cause: &quot; + e, e);    }  }  protected Object createInstance(String alias) {    Class&lt;?&gt; clazz = resolveClass(alias);    if (clazz == null) return null;    try {      return resolveClass(alias).newInstance();    } catch (Exception e) {      throw new BuilderException(&quot;Error creating instance. Cause: &quot; + e, e);    }  }  protected Class&lt;?&gt; resolveClass(String alias) {    if (alias == null) return null;    try {      return resolveAlias(alias);    } catch (Exception e) {      throw new BuilderException(&quot;Error resolving class. Cause: &quot; + e, e);    }  }  protected TypeHandler&lt;?&gt; resolveTypeHandler(Class&lt;?&gt; javaType, String typeHandlerAlias) {    if (typeHandlerAlias == null) return null;    Class&lt;?&gt; type = resolveClass(typeHandlerAlias);    if (type != null &amp;&amp; !TypeHandler.class.isAssignableFrom(type)) {      throw new BuilderException(&quot;Type &quot; + type.getName() + &quot; is not a valid TypeHandler because it does not implement TypeHandler interface&quot;);    }    @SuppressWarnings( &quot;unchecked&quot; ) // already verified it is a TypeHandler    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerType = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;) type;    return resolveTypeHandler(javaType, typeHandlerType);  }  protected TypeHandler&lt;?&gt; resolveTypeHandler(Class&lt;?&gt; javaType, Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerType) {    if (typeHandlerType == null) return null;    // javaType ignored for injected handlers see issue #746 for full detail    TypeHandler&lt;?&gt; handler = typeHandlerRegistry.getMappingTypeHandler(typeHandlerType);    if (handler == null) {      // not in registry, create a new one      handler = typeHandlerRegistry.getInstance(javaType, typeHandlerType);    }    return handler;  }  protected Class&lt;?&gt; resolveAlias(String alias) {    return typeAliasRegistry.resolveAlias(alias);  }}</code></pre><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式就是把多个对象组合成一个对象，简化对多个对象的访问。</p><p>看看Mybatis的SqlNode类</p><pre><code>public interface SqlNode {  boolean apply(DynamicContext context);}</code></pre><p>一条Sql会被解析成多个SqlNode对象，有IfSqlNode、TextSqlNode、ForEachSqlNode，那么访问这条sql时是不是要对每一个sqlNode都访问呢？</p><p>Mybatis提供了一个MixedSqlNode,将多个SqlNode组合成一个。</p><pre><code>public class MixedSqlNode implements SqlNode {  private List&lt;SqlNode&gt; contents;  public MixedSqlNode(List&lt;SqlNode&gt; contents) {    this.contents = contents;  }  public boolean apply(DynamicContext context) {    for (SqlNode sqlNode : contents) {      sqlNode.apply(context);    }    return true;  }}</code></pre><p>这里可以看出，组合模式可以简单化对多个对象的访问。Dom4J中对XML的定义也可以说是用了组合模式。</p><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>外观模式是提供统一接口给客户端访问，使用所有的客户都有相同的功能。这个做一个最大的好处就是以后的功能扩展。</p><p>在Configuration中一组newExecutor、newMetaObject、newStatementHandler、newResultSetHandler、newParameterHandler方法，其他类需要这些对象时都使用这些方法创建。</p><pre><code>public MetaObject newMetaObject(Object object) {    return MetaObject.forObject(object, objectFactory, objectWrapperFactory);  }  public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);    return parameterHandler;  }  public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,      ResultHandler resultHandler, BoundSql boundSql) {    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);    return resultSetHandler;  }  public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);    return statementHandler;  }  public Executor newExecutor(Transaction transaction) {    return newExecutor(transaction, defaultExecutorType);  }  public Executor newExecutor(Transaction transaction, ExecutorType executorType) {    executorType = executorType == null ? defaultExecutorType : executorType;    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;    Executor executor;    if (ExecutorType.BATCH == executorType) {      executor = new BatchExecutor(this, transaction);    } else if (ExecutorType.REUSE == executorType) {      executor = new ReuseExecutor(this, transaction);    } else {      executor = new SimpleExecutor(this, transaction);    }    if (cacheEnabled) {      executor = new CachingExecutor(executor);    }    executor = (Executor) interceptorChain.pluginAll(executor);    return executor;  }</code></pre><p>再来看看其中的newMetaObject方法都有哪些调用者</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151230100225325"  alt>  </p><p>这样做的一个好处就是需要扩展MetaObject类时，只需要修改newMetaObject方法即可，不用修改如此多的调用者代码。</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之Configuration总结</title>
      <link href="/mybatis3-configuration-finish/"/>
      <url>/mybatis3-configuration-finish/</url>
      
        <content type="html"><![CDATA[<h1 id="Configuration中的配置信息"><a href="#Configuration中的配置信息" class="headerlink" title="Configuration中的配置信息"></a>Configuration中的配置信息</h1><p>下图是官方文档中对Configuration的介绍</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151219085115235"  alt>  </p><p>这里xml配置是由两个对象加载Configuration对象中</p><ol><li>XMLConfigBuilder。这个对象负责加载除mappers映射器之外的所有配置。</li><li>XMLMapperBuilder。这个对象只负责加载mappers映射器中的配置。其中他还有个助手:MapperBuilderAssisant。XMLMapperBuilder与MapperBuilderAssisant有明确的分工。</li></ol><h1 id="XMLConfigBuilder加载配置"><a href="#XMLConfigBuilder加载配置" class="headerlink" title="XMLConfigBuilder加载配置"></a>XMLConfigBuilder加载配置</h1><p>这个加载过程比较简单，主要是读取配置，再创建对象，最后把对象加入Configruation中。而创建对象主要有两方式:</p><ol><li><p>通过类名加载对象。</p><ol><li>从配置中加载类名或类的别名</li><li>通过类名实例化对象</li><li>设置对象属性</li><li>将对象加入Configuration中</li></ol><p>如下例：</p></li></ol><pre><code> //解析对象工厂 private void objectFactoryElement(XNode context) throws Exception {  if (context != null) {   //从配置中读取类名    String type = context.getStringAttribute(&quot;type&quot;);    //从配置中读取改造    Properties properties = context.getChildrenAsProperties();    //根据类名创建对象    ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance();   //设置对象属性    factory.setProperties(properties);    //加入到Configuration中    configuration.setObjectFactory(factory);  }}</code></pre><ol start="2"><li><p>通过配置的内容(字符串)加载对象。这种对象一般都结构简单的，如枚举类型，Boolean类型等.</p><ol><li>读取配置的字符串内容</li><li>调用valueOf方法得一个对象</li></ol><p>如下例:</p><pre><code>configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty(&quot;autoMappingBehavior&quot;, &quot;PARTIAL&quot;)));</code></pre></li></ol><h1 id="XMLMapperBuilder加载配置"><a href="#XMLMapperBuilder加载配置" class="headerlink" title="XMLMapperBuilder加载配置"></a>XMLMapperBuilder加载配置</h1><p>XMLMapperBuilder主要加载如下三个配置，其他的比较少用。</p><ol><li>cache</li><li>resultMap</li><li>select/update/insert/delete</li></ol><h2 id="XMLMapperBuillder的助手XMLMapperAssiant"><a href="#XMLMapperBuillder的助手XMLMapperAssiant" class="headerlink" title="XMLMapperBuillder的助手XMLMapperAssiant"></a>XMLMapperBuillder的助手XMLMapperAssiant</h2><p>一个XMLMapperBuilder就会有一个助手。两个对象有明确的分工。XMLMapperBuilder对象负责从XML读取配置，而他的助手负责创建对象并加载到Configuration中。例如：</p><pre><code>private ResultMapping buildResultMappingFromContext(XNode context, Class&lt;?&gt; resultType, ArrayList&lt;ResultFlag&gt; flags) throws Exception {    //XMLapperBuilder负责从xml读取配置    String property = context.getStringAttribute(&quot;property&quot;);    String column = context.getStringAttribute(&quot;column&quot;);    String javaType = context.getStringAttribute(&quot;javaType&quot;);    String jdbcType = context.getStringAttribute(&quot;jdbcType&quot;);    String nestedSelect = context.getStringAttribute(&quot;select&quot;);    String nestedResultMap = context.getStringAttribute(&quot;resultMap&quot;,        processNestedResultMappings(context, Collections.&lt;ResultMapping&gt; emptyList()));    String notNullColumn = context.getStringAttribute(&quot;notNullColumn&quot;);    String columnPrefix = context.getStringAttribute(&quot;columnPrefix&quot;);    String typeHandler = context.getStringAttribute(&quot;typeHandler&quot;);    String resulSet = context.getStringAttribute(&quot;resultSet&quot;);    String foreignColumn = context.getStringAttribute(&quot;foreignColumn&quot;);    boolean lazy = &quot;lazy&quot;.equals(context.getStringAttribute(&quot;fetchType&quot;, configuration.isLazyLoadingEnabled() ? &quot;lazy&quot; : &quot;eager&quot;));    Class&lt;?&gt; javaTypeClass = resolveClass(javaType);    @SuppressWarnings(&quot;unchecked&quot;)    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;) resolveClass(typeHandler);    JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);    //助手负责创建对象并加入Configuration    return builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resulSet, foreignColumn, lazy);  }</code></pre><p>这个助手创建对象时，利用对象提供的build()方法，这是构建者模式，这种模式负责构建复杂的对象</p><pre><code>public ParameterMapping buildParameterMapping(      Class&lt;?&gt; parameterType,      String property,      Class&lt;?&gt; javaType,      JdbcType jdbcType,      String resultMap,      ParameterMode parameterMode,      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler,      Integer numericScale) {    resultMap = applyCurrentNamespace(resultMap, true);    // Class parameterType = parameterMapBuilder.type();    Class&lt;?&gt; javaTypeClass = resolveParameterJavaType(parameterType, property, javaType, jdbcType);    TypeHandler&lt;?&gt; typeHandlerInstance = resolveTypeHandler(javaTypeClass, typeHandler);     //利用Builder来创建对象    ParameterMapping.Builder builder = new ParameterMapping.Builder(configuration, property, javaTypeClass);    builder.jdbcType(jdbcType);    builder.resultMapId(resultMap);    builder.mode(parameterMode);    builder.numericScale(numericScale);    builder.typeHandler(typeHandlerInstance);    return builder.build();  }</code></pre><h1 id="Configuration中默认的Cache对象"><a href="#Configuration中默认的Cache对象" class="headerlink" title="Configuration中默认的Cache对象"></a>Configuration中默认的Cache对象</h1><p>Cache对象采用装饰模式实现，对PerpetualCache层层装饰，实现最终需要实现的功能</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151219132913600"  alt>  </p><h1 id="Configuration中的resultMaps属性"><a href="#Configuration中的resultMaps属性" class="headerlink" title="Configuration中的resultMaps属性"></a>Configuration中的resultMaps属性</h1><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20151219141032756"  alt>  </p><ol><li><p>一个resultMap元素对应一个ResultMap对象</p></li><li><p>resultMap元素中的idArg/id/result/association/collection元素对应一个ResultMapping对象，所有resultMap会有多个ResultMapping对象</p></li><li><p>association/collection元素对应一个内映射的ResultMap  </p></li><li><p>不管是ResultMap对应还是内映射的ResultMap对象都会被加入到Configuration.resultMaps属性</p></li></ol><h1 id="Configuration-mappedStatements属性"><a href="#Configuration-mappedStatements属性" class="headerlink" title="Configuration.mappedStatements属性"></a>Configuration.mappedStatements属性</h1><p>select/update/insert/detele元素会被解析成一个MappedStatement对象，这个对象有一个SqlSource属性，这个属性代表了sql具体的定义。SqlSource又由多个SqlNode组成，这个SqlNode是用组合模式实现的。BoundSql和SqlNode对象在以后分析sql执行时再讨论。</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis3源码分析之缓存配置加载</title>
      <link href="/mybatis3-configuration-load/"/>
      <url>/mybatis3-configuration-load/</url>
      
        <content type="html"><![CDATA[<p>Mybatis中的mapper配置文件中，除了经常配置select/update/insert/delete/resultMap节点之外，我们可能还会为Mybatis配置一个或几个缓存。接下来分析一下Mybatis是怎么将mapper配置文件中的缓存配置加载到Configuration对象中的。</p><h1 id="Mybatis中的缓存类型"><a href="#Mybatis中的缓存类型" class="headerlink" title="Mybatis中的缓存类型"></a>Mybatis中的缓存类型</h1><p>Mybatis支持两种缓存</p><ol><li>一级缓存，也叫本地缓存。这个缓存是在sqlSession中的实现的,sqlSession关闭之后这个缓存也将不存在，默认是开启的，当然了也可以在Mybatis-config配置文件中关闭。对于这个缓存策略后面会析到。</li><li>二级缓存。这个缓存是在命名空间有效，可以被多个sqlSession共享。开启这个缓存是在mapper.xml中配置的，这里主要是讨论缓存的配置怎么样加载到Configuration中。缓存的具体实现以后再讨论。</li></ol><p>本章节下面的文档如出现”缓存”，如果没有特别说明，指的就是二级缓存。</p><h1 id="缓存的配置方式"><a href="#缓存的配置方式" class="headerlink" title="缓存的配置方式"></a>缓存的配置方式</h1><p>这里有非常详细的说明:<a href="http://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache" target="_blank" rel="external nofollow noopener noreferrer">http://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache</a></p><p>主要有两种方式配置</p><ol><li><p><cache eviction="FIFO" flushinterval="60000" size="512" readonly="true"></cache></p><p>为当前的命名空间配置缓存</p></li><li><cache-ref namespace="com.someone.application.data.SomeMapper"><p>引用其他命名空间中的缓存</p></cache-ref></li></ol><h1 id="cache节点缓存配置读取"><a href="#cache节点缓存配置读取" class="headerlink" title="cache节点缓存配置读取"></a>cache节点缓存配置读取</h1><pre><code>private void cacheElement(XNode context) throws Exception {    if (context != null) {      //读取想着属性      //缓存类型，默认为PERPETUAL,为永久的，当回收策略会再包装一下，变化可回收的啦      String type = context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);      Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);      //回收策略，LRU,最少使用的被回收      String eviction = context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);      Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);      Long flushInterval = context.getLongAttribute(&quot;flushInterval&quot;);      Integer size = context.getIntAttribute(&quot;size&quot;);      boolean readWrite = !context.getBooleanAttribute(&quot;readOnly&quot;, false);      Properties props = context.getChildrenAsProperties();      //构建一个Cache对象，并加入Configuration      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, props);    }  }public Cache useNewCache(Class&lt;? extends Cache&gt; typeClass,      Class&lt;? extends Cache&gt; evictionClass,      Long flushInterval,      Integer size,      boolean readWrite,      Properties props) {    typeClass = valueOrDefault(typeClass, PerpetualCache.class);    evictionClass = valueOrDefault(evictionClass, LruCache.class);    //交由Builder处理,命名空间作为cache的id    Cache cache = new CacheBuilder(currentNamespace)        .implementation(typeClass)        .addDecorator(evictionClass)//这里的evictionClass也是一个Cache,设计模型中的装饰模式        .clearInterval(flushInterval)        .size(size)        .readWrite(readWrite)        .properties(props)        .build();    //将cache加入configuration中    configuration.addCache(cache);    //设置当前命名空间的缓存，在之后的解析select/update/insert/delete节点设置缓存里使用currentCache    currentCache = cache;    return cache;  }public Cache build() {    setDefaultImplementations();    //生成基本的Cache实现    Cache cache = newBaseCacheInstance(implementation, id);    setCacheProperties(cache);    if (PerpetualCache.class.equals(cache.getClass())) { // issue #352, do not apply decorators to custom caches      for (Class&lt;? extends Cache&gt; decorator : decorators) {        //使策略生效        cache = newCacheDecoratorInstance(decorator, cache);        setCacheProperties(cache);      }      //为cache加上一些指定的额外的服务，如、日志及线程安全      cache = setStandardDecorators(cache);    }    return cache;  }</code></pre><p>PerpetualCache实现</p><p>这个类就是利用HashMap实现的。</p><pre><code>public class PerpetualCache implements Cache {  private String id;  private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;();  public PerpetualCache(String id) {    this.id = id;  }  public String getId() {    return id;  }  public int getSize() {    return cache.size();  }  public void putObject(Object key, Object value) {    cache.put(key, value);  }  public Object getObject(Object key) {    return cache.get(key);  }  public Object removeObject(Object key) {    return cache.remove(key);  }  public void clear() {    cache.clear();  }  public ReadWriteLock getReadWriteLock() {    return null;  }  public boolean equals(Object o) {    if (getId() == null) throw new CacheException(&quot;Cache instances require an ID.&quot;);    if (this == o) return true;    if (!(o instanceof Cache)) return false;    Cache otherCache = (Cache) o;    return getId().equals(otherCache.getId());  }  public int hashCode() {    if (getId() == null) throw new CacheException(&quot;Cache instances require an ID.&quot;);    return getId().hashCode();  }}</code></pre><h2 id="LruCache实现"><a href="#LruCache实现" class="headerlink" title="LruCache实现"></a>LruCache实现</h2><p>利用LinkedHashMap实现了缓存策略。LinkedHashMap能非常方便实现LRU缓存机制，sun api上有详细说明。</p><pre><code>public class LruCache implements Cache {  private final Cache delegate;  private Map&lt;Object, Object&gt; keyMap;  private Object eldestKey;  public LruCache(Cache delegate) {    this.delegate = delegate;    setSize(1024);  }  @Override  public String getId() {    return delegate.getId();  }  @Override  public int getSize() {    return delegate.getSize();  }  public void setSize(final int size) {    //注意：第三个参数为true，LinkedHashMap会以访问顺序排序，最近使用的排在最前面    keyMap = new LinkedHashMap&lt;Object, Object&gt;(size, .75F, true) {      private static final long serialVersionUID = 4267176411845948333L;      //当put()方法被调用里，这个方法会触发，返回true，eldest将会被删除      protected boolean removeEldestEntry(Map.Entry&lt;Object, Object&gt; eldest) {        boolean tooBig = size() &gt; size;        if (tooBig) {          //保证被删除的key,下面的cycleKeyList方法有用          eldestKey = eldest.getKey();        }        return tooBig;      }    };  }  //一个新的key加入时，需要检查是否要把旧的删除  @Override  public void putObject(Object key, Object value) {    delegate.putObject(key, value);    cycleKeyList(key);  }  @Override  public Object getObject(Object key) {    keyMap.get(key); //touch    return delegate.getObject(key);  }  @Override  public Object removeObject(Object key) {    return delegate.removeObject(key);  }  @Override  public void clear() {    delegate.clear();    keyMap.clear();  }  public ReadWriteLock getReadWriteLock() {    return null;  }  private void cycleKeyList(Object key) {    //触发重排序    keyMap.put(key, key);    if (eldestKey != null) {      //删除最旧的那个key      delegate.removeObject(eldestKey);      eldestKey = null;    }  }}</code></pre><p>这两个cache的实现都不是线程安全的，但这个缓存是多个sqlSession共享的，对缓存的访问必须是线程安全的。在下面这个方法里便实现了cache的线程安全。 这个方法在CacheBuilder.build()方法创建cache里被调用。</p><pre><code>private Cache setStandardDecorators(Cache cache) {    try {      MetaObject metaCache = SystemMetaObject.forObject(cache);      if (size != null &amp;&amp; metaCache.hasSetter(&quot;size&quot;)) {        //设置缓存大小        metaCache.setValue(&quot;size&quot;, size);      }      if (clearInterval != null) {        //增加定时清理的功能        cache = new ScheduledCache(cache);        ((ScheduledCache) cache).setClearInterval(clearInterval);      }      if (readWrite) {        cache = new SerializedCache(cache);      }      //增加日志功能      cache = new LoggingCache(cache);       //实现线程安全，看了SynchronizedCache的源代码之后，有一点没想明白，这个类的同步机制采用了synchronized方法实现，为什么不用ReadWriteLock呢?      cache = new SynchronizedCache(cache);      return cache;    } catch (Exception e) {      throw new CacheException(&quot;Error building standard cache decorators.  Cause: &quot; + e, e);    }  }</code></pre><p>cache-ref节点读取  </p><p>================</p><pre><code>  private void cacheRefElement(XNode context) {    if (context != null) {      //向Configuration注册一个缓存引用      configuration.addCacheRef(builderAssistant.getCurrentNamespace(), context.getStringAttribute(&quot;namespace&quot;));      CacheRefResolver cacheRefResolver = new CacheRefResolver(builderAssistant, context.getStringAttribute(&quot;namespace&quot;));      try {           //获取另一个命名空间的缓存，并加入Configruation中          cacheRefResolver.resolveCacheRef();      } catch (IncompleteElementException e) {          configuration.addIncompleteCacheRef(cacheRefResolver);      }    }  }public Cache useCacheRef(String namespace) {    if (namespace == null) {      throw new BuilderException(&quot;cache-ref element requires a namespace attribute.&quot;);    }    try {      unresolvedCacheRef = true;      //获取加一个命名空间的缓存      Cache cache = configuration.getCache(namespace);      if (cache == null) {        throw new IncompleteElementException(&quot;No cache for namespace &apos;&quot; + namespace + &quot;&apos; could be found.&quot;);      }       //设置当前命名空间的缓存，在之后的解析select/update/insert/delete节点设置缓存里使用currentCache      currentCache = cache;      unresolvedCacheRef = false;      return cache;    } catch (IllegalArgumentException e) {      throw new IncompleteElementException(&quot;No cache for namespace &apos;&quot; + namespace + &quot;&apos; could be found.&quot;, e);    }  }</code></pre><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis3源码之MappedStatement加载过程</title>
      <link href="/mybatis3-source-code-mappedStatement/"/>
      <url>/mybatis3-source-code-mappedStatement/</url>
      
        <content type="html"><![CDATA[<h1 id="MappedStatement说明"><a href="#MappedStatement说明" class="headerlink" title="MappedStatement说明"></a>MappedStatement说明</h1><p>一个MappedStatement对象对应Mapper配置文件中的一个select/update/insert/delete节点，主要描述的是一条SQL语句。其属性有</p><pre><code>//节点中的id属性加要命名空间private String id;//直接从节点属性中取private Integer fetchSize;//直接从节点属性中取private Integer timeout;private StatementType statementType;private ResultSetType resultSetType;//对应一条SQL语句private SqlSource sqlSource;//每条语句都对就一个缓存，如果有的话。private Cache cache;//这个已经过时了private ParameterMap parameterMap;private List&lt;ResultMap&gt; resultMaps;private boolean flushCacheRequired;private boolean useCache;private boolean resultOrdered;//SQL的类型,select/update/insert/deteteprivate SqlCommandType sqlCommandType;private KeyGenerator keyGenerator;private String[] keyProperties;private String[] keyColumns;//是否有内映射private boolean hasNestedResultMaps;private String databaseId;private Log statementLog;private LanguageDriver lang;private String[] resultSets;</code></pre><p>上面属性都比较简单，复杂的是SqlSource,下面有详细的描述！</p><h1 id="XMLStatementBuilder-parseStatementNode-方法"><a href="#XMLStatementBuilder-parseStatementNode-方法" class="headerlink" title="XMLStatementBuilder.parseStatementNode()方法"></a>XMLStatementBuilder.parseStatementNode()方法</h1><p>resultMap元素的解析已经分析完毕。与resultMap不一样，XmlMapperBuilder在解析select/update/insert/delete的元素时会创建一个XMLStatementBuilder对象，解析的工作交由其方法parseStatementNode()方法完成。</p><pre><code>private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) {    for (XNode context : list) {      //一个select/update/insert/delete元素创建一个XMLStatementBuilder对象      final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);      try {        //将元素解析成MappedStatemenet对象，并加入到Configuration中去        statementParser.parseStatementNode();      } catch (IncompleteElementException e) {        configuration.addIncompleteStatement(statementParser);      }    }</code></pre><p>如下是parseStatementNode()方法的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String id = context.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">    String databaseId = context.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Integer fetchSize = context.getIntAttribute(<span class="string">"fetchSize"</span>);</span><br><span class="line">    Integer timeout = context.getIntAttribute(<span class="string">"timeout"</span>);</span><br><span class="line">    String parameterMap = context.getStringAttribute(<span class="string">"parameterMap"</span>);</span><br><span class="line">    String parameterType = context.getStringAttribute(<span class="string">"parameterType"</span>);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line">    String resultMap = context.getStringAttribute(<span class="string">"resultMap"</span>);</span><br><span class="line">    String resultType = context.getStringAttribute(<span class="string">"resultType"</span>);</span><br><span class="line">    String lang = context.getStringAttribute(<span class="string">"lang"</span>);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    String resultSetType = context.getStringAttribute(<span class="string">"resultSetType"</span>);</span><br><span class="line">    <span class="comment">//Statement的类型，对应jdbc里的三个类型:Statement、PreparedStatement、CallableStatement，默认使用PreparedStatement</span></span><br><span class="line">    StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">"statementType"</span>, StatementType.PREPARED.toString()));</span><br><span class="line">    <span class="comment">//这个也是跟jdbc里相对应的，一般采用默认即可</span></span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//Sql的类型，select/update/insert/delete</span></span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    <span class="comment">//是否刷新缓存</span></span><br><span class="line">    <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">"flushCache"</span>, !isSelect);</span><br><span class="line">    <span class="comment">//是否使用缓存</span></span><br><span class="line">    <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">"useCache"</span>, isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">"resultOrdered"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不做分析</span></span><br><span class="line">    <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">    XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line">    <span class="comment">//不做分析</span></span><br><span class="line">    <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成SqlSource对象，这个对象非常重要，接下来详细分析</span></span><br><span class="line">    <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">    String resultSets = context.getStringAttribute(<span class="string">"resultSets"</span>);</span><br><span class="line">    String keyProperty = context.getStringAttribute(<span class="string">"keyProperty"</span>);</span><br><span class="line">    String keyColumn = context.getStringAttribute(<span class="string">"keyColumn"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动生成key，这里也不做讨论</span></span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">      keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      keyGenerator = context.getBooleanAttribute(<span class="string">"useGeneratedKeys"</span>,</span><br><span class="line">          configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">          ? <span class="keyword">new</span> Jdbc3KeyGenerator() : <span class="keyword">new</span> NoKeyGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成MappedStatement对象，并加到Configuration中</span></span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered, </span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上在方法里附件解析一些基本的属性外还有两个主要的部分</p><ol><li><p>SqlSource的构建过程  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br></pre></td></tr></table></figure></li><li><p>MappedStatement的构建过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">       fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">       resultSetTypeEnum, flushCache, useCache, resultOrdered, </span><br><span class="line">       keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br></pre></td></tr></table></figure></li></ol><h1 id="SqlSource构建过程"><a href="#SqlSource构建过程" class="headerlink" title="SqlSource构建过程"></a>SqlSource构建过程</h1><h2 id="SqlSource接口"><a href="#SqlSource接口" class="headerlink" title="SqlSource接口"></a>SqlSource接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents the content of a mapped statement read from an XML file or an annotation. </span></span><br><span class="line"><span class="comment"> * It creates the SQL that will be passed to the database out of the input parameter received from the user.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SqlSource表示从mapper.xml或注解中读取的sql内容,该sql一般还不能都被直接执行,例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUserDetail"</span> <span class="attr">resultMap</span>=<span class="string">"detailUserResultMap"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--CDATA里内容会都解析成一个SqlSource对象--&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">    select user_id,user_name,user_type,cust_id from tf_f_user a where a.user_id=#$&#123;userId&#125;</span><br><span class="line">]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SqlSource只有一个方法:getBoundSql(paramenterObject),其中paramenterObject为运行sql里的实际参数</p><h2 id="BoundSql"><a href="#BoundSql" class="headerlink" title="BoundSql"></a>BoundSql</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An actual SQL String got form an &#123;<span class="doctag">@link</span> SqlSource&#125; after having processed any dynamic content.</span></span><br><span class="line"><span class="comment"> * The SQL may have SQL placeholders "?" and an list (ordered) of an parameter mappings </span></span><br><span class="line"><span class="comment"> * with the additional information for each parameter (at least the property name of the input object to read </span></span><br><span class="line"><span class="comment"> * the value from). </span></span><br><span class="line"><span class="comment"> * &lt;/br&gt;</span></span><br><span class="line"><span class="comment"> * Can also have additional parameters that are created by the dynamic language (for loops, bind...).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundSql</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String sql;</span><br><span class="line">  <span class="keyword">private</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line">  <span class="keyword">private</span> Object parameterObject;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, Object&gt; additionalParameters;</span><br><span class="line">  <span class="keyword">private</span> MetaObject metaParameters;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundSql</span><span class="params">(Configuration configuration, String sql, List&lt;ParameterMapping&gt; parameterMappings, Object parameterObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sql = sql;</span><br><span class="line">    <span class="keyword">this</span>.parameterMappings = parameterMappings;</span><br><span class="line">    <span class="keyword">this</span>.parameterObject = parameterObject;</span><br><span class="line">    <span class="keyword">this</span>.additionalParameters = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="keyword">this</span>.metaParameters = configuration.newMetaObject(additionalParameters);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sql;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;ParameterMapping&gt; <span class="title">getParameterMappings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parameterMappings;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getParameterObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parameterObject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAdditionalParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> metaParameters.hasGetter(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdditionalParameter</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">    metaParameters.setValue(name, value);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getAdditionalParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> metaParameters.getValue(name); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SqlBound代码并不多，就是一个普通的java对象，有两个属性非常重要</p><ol><li>sql:看代码里的注解，这个sql已经是经过了一些处理，可以被jdbc执行的了。xml里配置的sql可能有占位符#{username},这里的sql占位符已经被替换成”?”号了。</li><li>parameterMappings:执行sql对象的实际的参数。由此可以判断，每执行一条sql都会创建一个BoundSql对象。</li></ol><p>SqlSource和BoundSql本身并不复杂，复杂的是这两个对象被创建的过程。</p><h2 id="LanguageDriver"><a href="#LanguageDriver" class="headerlink" title="LanguageDriver"></a>LanguageDriver</h2><p>SqlSource对象是通过LanguageDriver对象构建的，在mapper.xml配置sql里可以通过lang属性指定一个LanguageDriver，但我们通常不会这样子做。当lang属性没有配置时，Mybatis会属性默认给一个。这个默认的LanguageDriver在Configuration的构造方法中定义的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Configuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    languageRegistry.setDefaultDriverClass(XMLLanguageDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    languageRegistry.register(RawLanguageDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>马上来看XMLLanguageDriver.createSqlSource()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">    XMLScriptBuilder builder = <span class="keyword">new</span> XMLScriptBuilder(configuration, script, parameterType);</span><br><span class="line">    <span class="keyword">return</span> builder.parseScriptNode();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>XMLScriptBuilder  </p><hr><p>XMLScriptBuilder.parseScriptNode()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将一个sql内容解析成多个SqlNode</span></span><br><span class="line">    List&lt;SqlNode&gt; contents = parseDynamicTags(context);</span><br><span class="line">    <span class="comment">//将多个SqlNode组合一个SqlNode</span></span><br><span class="line">    MixedSqlNode rootSqlNode = <span class="keyword">new</span> MixedSqlNode(contents);</span><br><span class="line">    SqlSource sqlSource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//判断sql是否是动态的</span></span><br><span class="line">    <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">      <span class="comment">//生成动态的SqlSource</span></span><br><span class="line">      sqlSource = <span class="keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//生成静态的SqlSource</span></span><br><span class="line">      sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sqlSource;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>再看parseDynamicTagS(context)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SqlNode&gt; <span class="title">parseDynamicTags</span><span class="params">(XNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一个sql会被解析成多个SqlNode，稍后会有示例详细说明</span></span><br><span class="line">    List&lt;SqlNode&gt; contents = <span class="keyword">new</span> ArrayList&lt;SqlNode&gt;();</span><br><span class="line">    NodeList children = node.getNode().getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">      XNode child = node.newXNode(children.item(i));</span><br><span class="line">      <span class="keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">        <span class="comment">//如果这个Node只包含文本</span></span><br><span class="line">        String data = child.getStringBody(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">//生成一个TextSqlNode</span></span><br><span class="line">        TextSqlNode textSqlNode = <span class="keyword">new</span> TextSqlNode(data);</span><br><span class="line">        <span class="comment">//判断是否是动态的,如果文本里包含占位符，如#&#123;username&#125;或&#123;table_name&#125;,isDynamic()方法就会返回true</span></span><br><span class="line">        <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">          contents.add(textSqlNode);</span><br><span class="line">          isDynamic = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          contents.add(<span class="keyword">new</span> StaticTextSqlNode(data));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="comment">// issue #628</span></span><br><span class="line">        <span class="comment">//如果是有xml标签的Node,交由Handler处理，同时被认为是动态的</span></span><br><span class="line">        String nodeName = child.getNode().getNodeName();</span><br><span class="line">        NodeHandler handler = nodeHandlers.get(nodeName);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Unknown element &lt;"</span> + nodeName + <span class="string">"&gt; in SQL statement."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        handler.handleNode(child, contents);</span><br><span class="line">    </span><br><span class="line">        isDynamic = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> contents;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>再看看nodeHandlers都有那些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, NodeHandler&gt; nodeHandlers = <span class="keyword">new</span> HashMap&lt;String, NodeHandler&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7123056019193266281L</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//Mybatis3动态sql都支持那些配置，这里就很清楚啦</span></span><br><span class="line">      put(<span class="string">"trim"</span>, <span class="keyword">new</span> TrimHandler());</span><br><span class="line">      put(<span class="string">"where"</span>, <span class="keyword">new</span> WhereHandler());</span><br><span class="line">      put(<span class="string">"set"</span>, <span class="keyword">new</span> SetHandler());</span><br><span class="line">      put(<span class="string">"foreach"</span>, <span class="keyword">new</span> ForEachHandler());</span><br><span class="line">      put(<span class="string">"if"</span>, <span class="keyword">new</span> IfHandler());</span><br><span class="line">      put(<span class="string">"choose"</span>, <span class="keyword">new</span> ChooseHandler());</span><br><span class="line">      put(<span class="string">"when"</span>, <span class="keyword">new</span> IfHandler());</span><br><span class="line">      put(<span class="string">"otherwise"</span>, <span class="keyword">new</span> OtherwiseHandler());</span><br><span class="line">      put(<span class="string">"bind"</span>, <span class="keyword">new</span> BindHandler());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>看到这里基本上能了解sql是怎么被解析的啦！举例说明:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUserDetail"</span> <span class="attr">resultMap</span>=<span class="string">"detailUserResultMap"</span>&gt;</span></span><br><span class="line">&lt;![CDATA[</span><br><span class="line">select user_id,user_name,user_type,cust_id --这里一行会解析成一个StaticTextSqlNode</span><br><span class="line">from tf_f_user a --这里一行也会解析成一个StaticTextSqlNode</span><br><span class="line">where a.user_id=#&#123;userId&#125; --这行会被解析成TextSqlNode,并且isDynamic被设置成true,因为有占位符</span><br><span class="line">                          --这个空行也解析成一个StaticTextSqlNode</span><br><span class="line">]]&gt;<span class="comment">&lt;!-- 这四个SqlNode会被组合成一个MixedSqlNode --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再来个动态sql的:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUserDetail"</span> <span class="attr">resultMap</span>=<span class="string">"detailUserResultMap"</span>&gt;</span></span><br><span class="line">&lt;![CDATA[</span><br><span class="line">select user_id,user_name,user_type,cust_id --这里一行会解析成一个StaticTextSqlNode</span><br><span class="line">from tf_f_user a --这里一行也会解析成一个StaticTextSqlNode</span><br><span class="line">where a.user_id=#&#123;userId&#125; --这行会被解析成TextSqlNode,并且isDynamic被设置成true,因为有占位符</span><br><span class="line">                          --这个空行也解析成一个StaticTextSqlNode</span><br><span class="line">]]&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"user_name!=null"</span>&gt;</span> <span class="comment">&lt;!-- 这个标签里的内容会交给IfHandler处理 --&gt;</span></span><br><span class="line">and --这里的解析与上行的一样，解析成一个StaticTextSqlNode</span><br><span class="line">user_name=#&#123;userName&#125; --这里的解析与上行的一样，也会被解析成一个TextSqlNode,并且isDynamic被设置成true,因为有占位符</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span><span class="comment">&lt;!-- IfHandler会将这里面的内个SqlNode组成MixedSqlNode再组成一个IfSqlNode --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="comment">&lt;!-- 这五个SqlNode会被组合成一个MixedSqlNode --&gt;</span></span><br></pre></td></tr></table></figure><p>附上IfHandler的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">IfHandler</span> <span class="keyword">implements</span> <span class="title">NodeHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNode</span><span class="params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//解析子节点</span></span><br><span class="line">      List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle);</span><br><span class="line">      <span class="comment">//组合</span></span><br><span class="line">      MixedSqlNode mixedSqlNode = <span class="keyword">new</span> MixedSqlNode(contents);</span><br><span class="line">      String test = nodeToHandle.getStringAttribute(<span class="string">"test"</span>);</span><br><span class="line">      <span class="comment">//生成IfSqlNode</span></span><br><span class="line">      IfSqlNode ifSqlNode = <span class="keyword">new</span> IfSqlNode(mixedSqlNode, test);</span><br><span class="line">      targetContents.add(ifSqlNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其他的nodeHandler在这里就不讨论了，实现方式与IfHandler差不多。如下两个方法也不在这里做讨论</p><ol><li>SqlSource.getBoundSql()方法</li><li>SqlNode.apply(DynamicContextcontext)方法</li></ol><p>因为这两个方法都是在sql被执行时才调用。在后续的SqlSession实现章节再讨论！</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之工厂模式</title>
      <link href="/factory/"/>
      <url>/factory/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>简单工厂模式（Simple Factory Pattern）是值一个工厂对象觉得创建出哪一种产品类的实例。<br>属于创建型模式，但是它不属于GOF 23种设计模式。<br>简单工厂使用于工厂类负责创建的对象较少的场景，并且客户端值需要传入工厂类的参数，对于如何创建对象的逻辑不需要关系。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>我们以我们生活中常见的小汽车为例，小汽车有宝马、奔驰、玛萨拉蒂等等品牌，那么我么可以定义一个小汽车的标准接口ICar：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生产汽车</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个宝马汽车的示例BMW：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======生产宝马汽车======"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端在调用的时候，我们一般是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ICar car = <span class="keyword">new</span> BMW();</span><br><span class="line">    car.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，父类ICar指向了子类BMW的引用。一般我们这样写没什么问题，但是如果在业务需要扩展，需要创建更多的品牌的汽车时，那么我们的客户端依赖会变得越来越臃肿，要减弱客户端的依赖，那我们就需要将创建细节隐藏，使用一个简单工厂类来优化我们的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICar <span class="title">create</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"BMW"</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BMW();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"benz"</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Benz();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改客户端调用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CarFactory carFactory = <span class="keyword">new</span> CarFactory();</span><br><span class="line">        ICar car = carFactory.create(<span class="string">"BMW"</span>);</span><br><span class="line">        car.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用是简单了，但是我们的工厂类违反了开闭原则，因为在有新的汽车要生产时，我们需要修改 <code>CarFactory</code>  中的 <code>create</code> 方法。我们可以用反射技术，来对工厂类进行优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICar <span class="title">create</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (ICar) clazz.newInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，我们调用时只需要传入 <code>Class</code> 对象即可，这样既避免了在客户端调用时传错参数，也可以避免工厂类的修改。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>工厂方法模式（Fatory Method Pattern）是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。<br>工厂方法模式主要解决产品扩展的问题，在简单工厂中，随着产品链的丰富，如果每个汽车的创建逻辑有区别的话，工厂的职责会变得越来越多，有点像万能工厂，并不便于维护。根据单一职责原则我们将职能继续拆分，专人干专事。 宝马汽车有宝马工厂创建，奔驰汽车由奔驰工厂创建，这样无论汽车的生产有怎样特殊的需求，都不影响其他汽车的生产。</p><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p>我们先对工厂做一个顶层抽象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">ICar <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分别创建子工厂，BMWFactory和BenzFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span> <span class="keyword">implements</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICar <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BMW();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzFactory</span> <span class="keyword">implements</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICar <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Benz();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ICarFactory factory = <span class="keyword">new</span> BMWFactory();</span><br><span class="line">        ICar bmw = factory.create();</span><br><span class="line">        bmw.create();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ICarFactory factory2 = <span class="keyword">new</span> BenzFactory();</span><br><span class="line">        ICar benz = factory2.create();</span><br><span class="line">        benz.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>工厂方法使用于以下场景：</p><ol><li>创建对象需要大量的重复代码</li><li>客户端不依赖于产品类实例如何被创建、实现等细节</li><li>一个类通过其子类来指定创建的对象。<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3>虽然工厂方法简单，清晰，但是当需要创建的产品过多时会导致类爆炸。要解决类爆炸的问题，就需要用到抽象工厂模式。<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3>抽象工厂模式（Abastract Factory Pattern）是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节，强调的是一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。需要提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。<br>在讲解抽象工厂模式之前，我们需要先了解两个概念：产品族和产品等级结构。</li></ol><p><strong>产品族：</strong>所谓的产品族即是同一个厂家生产的多个产品。<br><strong>产品等级结构：</strong>产品等级结构即有多个厂家可以生成相同的产品。<br>比如工厂A能够生产 A、B、C三种产品，工厂B也能生产A、B、C三种产品，那么A、B、C就表示一个产品族，工厂A 生产 A 和工厂B生产的A就表示一个产品等级结构。</p><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><p>我们还是以汽车为例，一个汽车的组成是有发动机、车身、变速箱等等部件组成。我们先来创建一个ICarFactory的工厂接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">ICarBody <span class="title">createBody</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEngine <span class="title">createEngine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IGearbox <span class="title">createGearbox</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建需要使用到的产品接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICarBody</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEngine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGearbox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些产品的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWBody</span> <span class="keyword">implements</span> <span class="title">ICarBody</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产bmw车身"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWEngine</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产bmw 引擎"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWGearbox</span> <span class="keyword">implements</span> <span class="title">IGearbox</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产bmw变速箱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产品族工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BmwFactory</span> <span class="keyword">implements</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICarBody <span class="title">createBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BMWBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BMWEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IGearbox <span class="title">createGearbox</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BMWGearbox();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ICarFactory carFactory = <span class="keyword">new</span> BmwFactory();</span><br><span class="line">        carFactory.createBody().create();</span><br><span class="line">        carFactory.createEngine().create();</span><br><span class="line">        carFactory.createGearbox().create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它产品族的工厂和产品定义类似。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>抽象工厂虽然能一定程度上解决类爆炸的问题，但是很显然它不符合开闭原则。这是因为我们在产品族中加入一个产品时，从抽象工厂到具体实现都需要修改。因此抽象工厂也是优缺点点。<br>1、规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口 。<br>2、增加了系统的抽象性和理解难度 。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Spring IOC</title>
      <link href="/deep-understanding-of-spring-ioc/"/>
      <url>/deep-understanding-of-spring-ioc/</url>
      
        <content type="html"><![CDATA[<p>Spring IOC作为Spring中第一核心概念，我们在学习Spring之初就接触过了。但是我们在研究探索Spring IOC源码之前，还是需要对Spring IOC的概念做一个深入的理解。此篇作为【Spring源码解析】系列的真正的第一篇，我们来对IOC做一个深入的理解和探究。</p><h3 id="什么是Spring-IOC"><a href="#什么是Spring-IOC" class="headerlink" title="什么是Spring IOC"></a>什么是Spring IOC</h3><p>什么是Spring IOC？这是一道在面试中会经常被问道的题目。IOC的全称是<code>Inversion of Control</code>，被译为“控制反转”，它还有一个别名叫做依赖注入DI（<code>dependency injection</code>）。但是在有的书中，会将依赖注入当做是IOC的一种实现方式，但是博主在查看Spring的官方文档时，它是这样说的：</p><blockquote><p>  IoC is also known as dependency injection (DI)</p></blockquote><p>我们可以看到，Spring的官方文档上将依赖注入（ID）和IOC（控制反转）当做的是同一个概念。以后我们可以大胆的告诉面试官，IOC就是依赖注入，只是同一个概念不同的说法而已。回到IOC（<code>控制反转</code>）上面，要搞懂IOC（<code>控制反转</code>）首先要搞懂以下几个问题：</p><ol><li>谁控制了谁？</li><li>怎么控制的？</li><li>何为反转？</li></ol><p>在回答上面的问题之前，我们先看一个简单的示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Human human = <span class="keyword">new</span> Human();</span><br><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">human.setCar(car);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中是我们通常的做法，在我们需要依赖某个类或者服务时，通常的做法就是将其直接创建出来（<code>new Car()</code>）,然后将创建出来的对象提供给使用者让其使用。这就使得我们的对象和其依赖的对象紧紧的耦合在一起了，如果有一天，我们想对其依赖的对象进行更换，那将是一个极其痛苦的事情。</p><p>再回头想想，我们是否真的有必要在每次使用到依赖对象的时候，将其主动的创建出来？我们在使用到依赖对象时，只是使用到依赖对象提供的某项服务而已，只要在我们用到这个依赖对象的服务时，它能够准备就绪就好，至于这个依赖对象是我们主动创建还是由别人提供的我们并不关心，再说，相对于我们自己主动创建还需要大费周折的维护它，由别人提供不是会更好吗？</p><p>在这里，提供我们东西的“人”就是IOC，在上面的示例中，IOC就相当于租车公司，你要什么车，只要你把要求告诉给租车公司，它就会提供你什么车，我们只需要关注怎么使用就行了，完全不需要我们再去造一个车出来然后再使用。所以说简单点，IOC的理念就是，让别人为你服务。如下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/image-20200508220836602.png"  alt="image-20200508220836602"></p><p>在没有引入IOC之前，被注入的对象会直接依赖于依赖对象，在使用了IOC后，两者及其他们关系都是通过<code>IOC Service Provider</code>来统一维护管理的。被注入的对象需要什么，直接跟 <code>IOC Service Provider</code> 打招呼，后者就会把相应的被依赖对象注入到被注入对象中，从而达到 <code>IOC Service Provider</code> 为备注入对象提供提供服务的目的。<strong>其实IOC就是这么简单！原来需要什么东西自己去拿，现在是需要什么东西就让别人送过来。</strong></p><p>明白<code>IOC</code> 的核心理念，现在我们来回答上面的问题就非常简单了。</p><p><strong>谁控制了谁：</strong>IOC容器控制对象，不论是被注入对象还是依赖对象都是交给IOC容器来管理的。</p><p><strong>怎么控制的：</strong> IOC容器提供了3种方式来完成将依赖对象注入到被注入对象中，至于是哪三种方式，我们后面会说到。</p><p><strong>何为反转：</strong> 在IOC出现之前，我们都是主动的去创建依赖对象，这是正传。在使用IOC之后，所有依赖的对象都是由IOC容器创建后提供给被注入对象的，依赖的对象从主动的创建变成被动的接受，这就是反转。</p><h3 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h3><p>前面提到过，IOC容器提供了3种方式来完成将依赖对象注入到被注入对象中，这3种方式分别是：</p><ul><li>构造注入</li><li>setter方法注入</li><li>接口注入</li></ul><p>下面我们来看看每种方式是如何完成的。</p><h4 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h4><p>构造注入，顾名思义就是在构造方法中完成将依赖对象注入到被注入对象中去。被注入的对象可以在构造函数中声明依赖对象的参数列表，让IOC容器知道它需要哪些依赖对象。还是以上面为例，构造注入的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用 。</p><h4 id="Setter方法注入"><a href="#Setter方法注入" class="headerlink" title="Setter方法注入"></a>Setter方法注入</h4><p>对于JavaBean对象来说，我们通常都是通过setter和getter方法来访问和设置相应的属性，所以被注入对象只需要提供依赖对象的setter方法，IOC容器就会将依赖对象注入到被注入对象中去。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比较于<code>构造注入</code>， <code>setter方法注入</code>会显得更宽松一些，它可以在对象构造完成后的任何时间点注入，只需要在使用依赖对象之前即可。</p><h4 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h4><p>相比较于前2种注入方式，接口注入显得更加的霸道和侵入性。因为它需要被注入对象实现一个接口，这个接口中提供一个方法，用来为其注入依赖对象。这种方式基本处于“退役状态”，并且在Spring中也并没有实现接口注入，所以博主在这里就不演示了。</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>我们在上面深入的分析了IOC的核心概念后，我们再来看看组成Spring IOC组成的核心组件。</p><h4 id="ApplicationContext体系"><a href="#ApplicationContext体系" class="headerlink" title="ApplicationContext体系"></a>ApplicationContext体系</h4><p>首先我们来看下我们大名鼎鼎的<code>applicationContext</code>的类图。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/ApplicationContext.png"  alt="ApplicationContext"></p><p>从上面 <code>applicationContext</code>的类图中，我们可以看到 <code>applicationContext</code> 即继承了顶级接口 <code>ResourceLoader</code> 又继承了顶级接口 <code>BeanFactory</code>。</p><p>因此<code>applicationContext</code> 与<code>BeanFactory</code>的区别在于，<code>applicationContext</code> 不仅能够完成对<code>Bean</code>的管理而且还额外的提供了如下功能：</p><ul><li><strong>资源访问（如URL和文件）</strong></li><li><strong>事件机制</strong></li><li><strong>解决消息的能力，支持国际化</strong></li></ul><p>对于<code>applicationContext</code> 我们最熟悉的莫过于<code>ClassPathXmlApplicationContext</code>和<code>AnnotationConfigApplicationContext</code>了，<code>ClassPathXmlApplicationContext</code>是用于加载xml文件，并解析xml,然后将xml文件中配置的类实例化并装载到容器中。<code>AnnotationConfigApplicationContext</code>和<code>ClassPathXmlApplicationContext</code>原理类似，只不过<code>AnnotationConfigApplicationContext</code>是用来加载注解类的。除了这2个类外，还有一些其它的实现，比如<code>FileSystemXmlApplicationContext</code>、<code>GenericGroovyApplicationContext</code>、<code>GenericXmlApplicationContext</code>等等，只不过相比于前面2个，这些都不是很常用而已。</p><p>说完了<code>applicationContext</code> ，我们再来看看<code>applicationContext</code> 类图中的2个顶级接口。</p><h4 id="Resource体系"><a href="#Resource体系" class="headerlink" title="Resource体系"></a>Resource体系</h4><p>ResourceLoader是用于加载resources的一个策略，我们先来看看ResourceLoader接口的定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定的资源，返回Resource对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> location</span></span><br><span class="line"><span class="comment"> * 例如：file:C:/test.dat</span></span><br><span class="line"><span class="comment"> * classpath:test.dat</span></span><br><span class="line"><span class="comment"> * WEB-INF/test.dat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取ClassLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面<code>ResourceLoader</code>的源码中我们可以看到，其主要的功能就是将一个资源文件路径装加载为<code>Resource</code>对象。然后通过<code>BeanDefinitionReader</code>将<code>Resource</code>中的类信息加载成<code>BeanDefinition</code>。</p><p><code>Resource</code>和<code>ResouceLoader</code>的类图如下：</p><h5 id="Resource类图"><a href="#Resource类图" class="headerlink" title="Resource类图"></a>Resource类图</h5><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/Resource.png"  alt="Resource"></p><h5 id="ResourceLoader类图"><a href="#ResourceLoader类图" class="headerlink" title="ResourceLoader类图"></a>ResourceLoader类图</h5><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/ResourceLoader.png"  alt="ResourceLoader"></p><h4 id="BeanFactory体系"><a href="#BeanFactory体系" class="headerlink" title="BeanFactory体系"></a>BeanFactory体系</h4><p><code>BeanFactory</code> 是我们Spring IOC 中非常重要的一块，它是用于访问Spring Bean容器的根接口。它为我们Spring IOC 容器提供了最底层的支持。说的简单点，就是BeanFactory的主要功能就是管理我们容器中的Bean。其体系结构如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/BeanFactory.png"  alt="BeanFactory"></p><h4 id="BeanDefinitionReader体系"><a href="#BeanDefinitionReader体系" class="headerlink" title="BeanDefinitionReader体系"></a>BeanDefinitionReader体系</h4><p>在上面的Resource系统中，我们提到BeanDefinitionReader将Resource中的类信息加载为BeanDefinition，因此BeanDefinitionReader和BeanDefinition也是我们Spring IOC容器中非常重要的一个体系结构，我们先来看BeanDefinitionReader。BeanDefinitionReader类图如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/BeanDefinitionReader.png"  alt="BeanDefinitionReader"></p><p>可以看到上面的<code>BeanDefinitionReader</code>体系都是基于配置的，基于注解的是<code>AnnotatedBeanDefinitionReader</code>，它就是一个单独的类，用于处理基于注解的配置。其类图如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/AnnotatedBeanDefinitionReader.png"  alt="AnnotatedBeanDefinitionReader"></p><h4 id="BeanDefinition体系"><a href="#BeanDefinition体系" class="headerlink" title="BeanDefinition体系"></a>BeanDefinition体系</h4><p>BeanDefinition是Spring用来描述Bean的信息的类，其类图如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/BeanDefinition.png"  alt="BeanDefinition"></p><p>上面的五个体系，不，应该是六个体系，<code>AnnotatedBeanDefinitionReader</code>应该单独算一个体系。这六个系统是我们Spring IOC中最核心的部分，后面博主将根据这六个体系来分析Spring IOC的源码和实现原理。</p>]]></content>
      
      
      <categories>
          
          <category> Spring源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码环境搭建</title>
      <link href="/spring-source-environment/"/>
      <url>/spring-source-environment/</url>
      
        <content type="html"><![CDATA[<h3 id="Gradle安装"><a href="#Gradle安装" class="headerlink" title="Gradle安装"></a>Gradle安装</h3><p>gradle安装文档地址：<a href="https://gradle.org/install/" target="_blank" rel="external nofollow noopener noreferrer">https://gradle.org/install/</a>  官网上详细的介绍了如何安装Gradle。</p><p>Windows平台下，需要配置gradle的环境变量。</p><ul><li>新增 <code>GRADLE_HOME</code> 环境变量，指向Gradle解压目录</li><li>配置Path环境变量:新增 <code>%GRADLE_HOME%\bin</code></li></ul><p>完成配置后，输入<code>gradle -v</code>会显示gradle的版本号，表示gradle安装成功。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/image-20200429221410367.png"  alt="image-20200429221410367"></p><h3 id="下载Spring源码"><a href="#下载Spring源码" class="headerlink" title="下载Spring源码"></a>下载Spring源码</h3><p>Spring源码下载在github上找到spring-projects/<em>spring</em>-framework，选择版本后将其下载到本地。</p><h3 id="Spring源码编译"><a href="#Spring源码编译" class="headerlink" title="Spring源码编译"></a>Spring源码编译</h3><p>进入 <code>spring-framework</code> 文件夹下，打开cmd，输入 <code>gradlew :spring-oxm:compileTestJava</code> 进行编译。在编译的过程中可能出现错误，重试几次就可以了。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/image-20200430091342847.png"  alt="image-20200430091342847"></p><h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><p>打开IDEA依次打开File -&gt; New -&gt; Project from Existing Sources -&gt; Navigate to directory -&gt; Select build.gradle，点击OK导入项目</p><p>导入项目完成后，修改gradle和Jdk的配置信息。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/image-20200430101715846.png"  alt="image-20200430101715846"></p><p>修改完成后，查看源码中是否包含<code>spring-aspects</code>模块，如果存在，则需要将<code>spring-aspects</code>排除编译。</p><p>File -&gt; Project Structure -&gt; Modules</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/image-20200430102139508.png"  alt="image-20200430102139508"></p><p>构建项目，等待IDEA工具编译完成。</p><p>在构建的过程中可能会出现如下的错误</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/image-20200430102604467.png"  alt="image-20200430102604467"></p><p>这是因为gradle的版本太高的原因，有2种解决方案，一是将自己本地的gradle的版本减低，二是提高build-scan的版本，这里博主用的是第一种方案。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在spring的工程项目中新建测试模块，在工程目录项右键–&gt;New–&gt;Module</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/image-20200430112732589.png"  alt="image-20200430112732589"></p><p>新建项目完成后，配置build.gradle,在 dependencies 里面添加 compile(project(“:spring-context”))  spring-context的依赖。</p><p>最后运行测试</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/image-20200430115639706.png"  alt="image-20200430115639706"></p><p>可以看到正常的输出了打印的信息</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/image-20200430115708533.png"  alt="image-20200430115708533"></p><p>此时，spring源码环境即搭建完成。</p><blockquote><p>  <strong>当前Spring的版本为5.2.3，后面Spring的源码分析都是基于此版本。 后面的系列文章均是LZ 学习、研究 Spring 源码的学习笔记，如有错误之处，望各位大佬指出，不胜感激。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池ThreadPoolExecutor源码分析</title>
      <link href="/thread-pool/"/>
      <url>/thread-pool/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h3><p>创建线程要花费昂贵的资源和时间，如果任务来了才创建那么响应时间会变长，而且一个进程能创建的线程数量有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应出来，它们被称为线程池，里面的线程就叫做工作线程。</p><h3 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h3><ul><li>避免线程的创建和销毁带来的性能开销。</li><li>避免大量的线程间因互相抢占系统资源导致的阻塞现象。</li><li>能够对线程进行简单的管理并提供定时执行、间隔执行等功能。</li></ul><h3 id="线程池工作原理"><a href="#线程池工作原理" class="headerlink" title="线程池工作原理"></a>线程池工作原理</h3><p>我们在创建线程池后，线程池是如何来执行任务的呢？下面我们就来看看线程池的主要处理流程。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/image-20200326221736249.png"  alt="线程池处理流程"></p><p>从上面的图我们可以看到ThreadPoolExecutor提供了2种方式提交任务，这个2种方法提交任务的区别，我们后面会说到。当提交一个新任务到线程池时，其处理流程如下：</p><ol><li>线程池判断核心线程池里的线程是否都在执行任务，如果不是，则创建一个新的工作线程来执行任务，如果核心线程池中的线程都在执行任务，则进入下一个流程。</li><li>线程池判断工作队列是否已满，如果工作队列没有满，则将任务存储到工作队列中。如果工作队列已满，则进入下一个流程。</li><li>线程池判断线程池的线程是否都在执行任务，如果不是，则创建一个工作线程来来执行任务，如果是，则交给创建线程池时的拒绝策略来处理任务。</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>上面线程池的流程分析让我们很直观的了解了<code>ThreadPoolExecutor</code>的工作原理，下面我们通过源码来具体分析线程池是如何实现的。</p><h4 id="ThreadPoolExecutor类图"><a href="#ThreadPoolExecutor类图" class="headerlink" title="ThreadPoolExecutor类图"></a>ThreadPoolExecutor类图</h4><p>在研究源码之前，我们先大体的认识下ThreadPoolExecutor的整个架构。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/ThreadPoolExecutor%E7%B1%BB%E5%9B%BE.png"  alt="ThreadPoolExecutor类图"></p><p>上面是ThreadPoolExecutor的UML类图，上面类中的方法和属性并没有完全列出来，只是将主要的属性和方法列出。</p><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p>线程池状态定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><p>其中AtomicInteger变量ctl的功能非常强大：利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态：</p><ol><li>RUNNING：-1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务</li><li>SHUTDOWN： 0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li>STOP ： 1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li><li>TIDYING ： 2 &lt;&lt; COUNT_BITS，即高3位为010, 所有的任务都已经终止；</li><li>TERMINATED： 3 &lt;&lt; COUNT_BITS，即高3位为011, terminated()方法已经执行完成</li></ol><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>第一步，我们先从<code>ThreadPoolExecutor</code>的构造函数，来了解<code>ThreadPoolExecutor</code>是如何创建的。其构造函数源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数检测</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> || maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//安全管理器</span></span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">               <span class="keyword">null</span> :</span><br><span class="line">               AccessController.getContext();</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadPoolExecutor</code> 的构造其实非常的简单，就是将传入参数赋值给成员变量，下面我们来解释下构造函数中各个参数所代表的意思。</p><ol><li><p><code>corePoolSize:</code>  线程池的核心线程数量。线程池的核心线程数量在我们创建线程池时默认是不会改变的，即使线程池没有处理任何任务，它的数量也是不会改变的。除非我们手动的设置了<code>ThreadPoolExecutor</code>中<code>allowCoreThreadTimeOut</code>的值为true,那么空闲的核心线程将会被销毁。</p></li><li><p><code>maximumPoolSize:</code>  线程池最大线程数量。</p></li><li><p><code>keepAliveTime:</code> 线程存活时间，当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</p></li><li><p><code>unit:</code> 超时时间单位</p></li><li><p><code>workQueue:</code> 工作队列，用于存储任务</p></li><li><p><code>threadFactory:</code> 线程工厂，用户创建线程，threadFactory创建的线程也是采用new Thread()方式。</p></li><li><p><code>handler:</code> 拒绝策略，当线程池和阻塞队列都满时，再加入的任务会执行此策略。</p><p>在JDK1.5中Java线程池提供了以下几种拒绝策略</p><ul><li>AbortPolicy：直接抛出异常。</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉。</li></ul><p>当然，我们也可以根据应用场景需要自己来实现RejectedExecutionHandler接口自定义策略。如记录<br>日志或持久化存储不能处理的任务。</p></li></ol><p>ThreadPoolExecutor虽然还提供了一些其它的构造函数，但是它们最终都是调用上面的构造函数来完成线程池的创建的。</p><h4 id="execute提交任务"><a href="#execute提交任务" class="headerlink" title="execute提交任务"></a>execute提交任务</h4><p>execute提交任务源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数检测</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//获取线程池的控制状态，它是一个原子变量，包括了高3位的运行状态和低29位的有效线程数量</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//判断线程池中的线程数是否小于核心线程数量</span></span><br><span class="line">    <span class="comment">//小于，则直接创建工作线程执行任务,否则进入下一步</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//如果添加工作线程成功，则直接返回，否则再次获取线程池控制状态，并进入下一步</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//重新获取线程池控制状态</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果线程池处于运行状态且阻塞队列可以添加任务，则进入if语句否则进入下一步 ②</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 再次获取线程池控制状态</span></span><br><span class="line"><span class="comment">        * 这里再次获取线程池控制状态，是因为在执行if语句时，线程池控制状态可能已经改变</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line"><span class="comment">// 如果线程池处于非运行状态且任务可以从队列中删除(即该任务已经存在于工作队列中)，</span></span><br><span class="line">        <span class="comment">// 则调用初始化线程池的拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//如果线程池中的线程数量为0，则调用addWorker执行任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">//如果addWorker失败，则执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execute</code>逻辑比较简单，就是更具线程池的控制状态已经工作队列是否已满的情况调用<code>addWorker</code>方法创建线程并执行任务或者调用拒绝策略处理任务。在上面源码的第②步中为什么需要double check线程池的状态？这是因为在多线程环境下，线程池的状态时刻在变化，而ctl.get()是非原子操作，很有可能刚获取了线程池状态后线程池状态就改变了。判断是否将command加入workque是线程池之前的状态。倘若没有double check，万一线程池处于非running状态（在多线程环境下很有可能发生），那么command永远不会执行。</p><h4 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h4><p>从上面execute方法的源码可以看出，addWorker主要是负责创建新的线程并执行任务，其源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取线程池的控制状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//根据线程池的控制状态获取线程池的运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(1) 如果线程池已经停止或者关闭，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//(2) 通过cas增加线程个数</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//（2.1）获取线程池中种的线程数量</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//（2.2）如果线程数量超过限制，则直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//（2.3）cas增加线程线程个数，成功则直接跳出最外层的for循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">//（2.4）cas 失败重新获取线程池控制状态</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">          <span class="comment">//（2.5）看线程池状态是否变化了，变化则跳到外层循环重试重新获取线程池状态，否者内层循环重新cas。</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//（3）创建worker</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">//（3.1）加锁，确保worker添加成功，因为可能多个线程调用了线程池的execute方法。</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//（3.2）重新检查线程池状态，为了避免在获取锁前调用了shutdown接口</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">//（3.3）添加worker</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//（3.4）添加成功则启动任务</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码主要分两部分，第一部分的双重循环目的是通过 cas 操作增加线程池线程数，第二部分主要是并发安全的把任务添加到 workers 里面，并且启动任务执行。</p><p>先看第一部分的代码（1)，如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">    ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">       firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">       ! workQueue.isEmpty()))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>这样看不好理解，我们展开！运算符后，相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">    (rs != SHUTDOWN ||    </span><br><span class="line">     firstTask != <span class="keyword">null</span> || </span><br><span class="line">     workQueue.isEmpty())</span><br></pre></td></tr></table></figure><p>如上代码，也就是说代码（1）在下面几种情况下会返回 false：</p><p>  1.当前线程池状态为 STOP，TIDYING，TERMINATED；</p><p>  2.当前线程池状态为 SHUTDOWN 并且已经有了第一个任务；</p><p>  3.当前线程池状态为 SHUTDOWN 并且任务队列为空。</p><p>我们再回到addWorker方法，看到代码（2），我们发现内层循环是通过CAS方式增加线程数量，代码（2.2）判断线程数量是否超过限制，超过了则直接返回false，否则执行代码（2.3）利用CAS增加线程个数，如果成功，则跳出外层循环，执行第二部分，如果失败则判断线程池状态是否发生了改变，如果改变则重新进入外层循环，如果没有发生改变则从内层开始继续通过CAS增加线程数量。</p><p>执行到第二部分的代码（3），说明使用CAS成功的增加了线程个数，但现在仅仅是线程的数量增加了并没有创建一个新的线程来执行任务，第二部分代码主要实现的就是增加一个工作线程,并将其添加到工作队列中，最后启动线程。</p><h4 id="工作线程Wokder"><a href="#工作线程Wokder" class="headerlink" title="工作线程Wokder"></a>工作线程Wokder</h4><p>在addWorker方法中，新增工作线程是通过new Worker来实现的，我们先来看看Worker这个类的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span>  <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">//设置状态</span></span><br><span class="line">        setState(-<span class="number">1</span>); </span><br><span class="line">        <span class="comment">//外部提交的任务</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到Worker是一个Runnable并且是AQS的子类，那么Worker类肯定能够进行并发控制。</p><p>在上面addWorker方法中，添加worker成功后，会启动则会执行Worker类中的run方法，实际执行的则是runWorker方法。</p><h5 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h5><p>runWorker方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前worker携带的任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//修改state为0，将占用锁的线程设为null（第一次执行之前没有线程占用）,运行线程中断</span></span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋。先执行自己携带的任务，然后从阻塞队列中获取一个任务直到无法获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 将state修改为1，设置占有锁的线程为自己</span></span><br><span class="line">            w.lock();</span><br><span class="line">             <span class="comment">/**</span></span><br><span class="line"><span class="comment">              * check线程池的状态，如果状态为stop以上(stop以上不执行任务)，则中断当前线程</span></span><br><span class="line"><span class="comment">              * 如果当前线程已被中断（其他线程并发的调用线程池的shutdown()或shutdownNow()方法），则check线程池状态是否为stop以上</span></span><br><span class="line"><span class="comment">              * 最后如果线程池状态为stop以上，当前线程未被中断则中断当前线程</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行任务前做的事情，留给子类实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行外部提交的任务，通过try-catch来保证异常不会影响线程池本身的功能</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//任务执行完成后做的事情，留给子类实现</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//完成任务数量统计</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 从上面可以看出如果实际业务(外部提交的Runnable)出现异常会导致当前worker终止</span></span><br><span class="line"><span class="comment">          * completedAbruptly 此时为true意味着worker是突然完成，不是正常退出</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly); <span class="comment">// 执行worker退出收尾工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面runWorker方法的整个流程如下：</p><ol><li>如果当前 task==null 或者调用 getTask 从任务队列获取的任务返回 null，则跳转到代码processWorkerExit。</li><li>如果 task 不为 null 则获取工作线程内部持有的独占锁，然后执行扩展接口代码，在具体任务执行前做一些事情，扩展接口执行完成后，执行具体任务，在具体任务执行完毕后做一些事情，最后统计当前 worker 完成了多少个任务，并释放锁。</li></ol><p>这里在执行具体任务期间加锁，是为了避免任务运行期间，其他线程调用了 shutdown 或者 shutdownNow 命令关闭了线程池。</p><h5 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="comment">// 自旋获取任务(因为是多线程环境)</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();<span class="comment">// 读取最新的clt</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、线程池状态为shutdown并且任务队列为空</span></span><br><span class="line"><span class="comment">         * 2、线程池状态为stop状态以上</span></span><br><span class="line"><span class="comment">         * 这2种情况直接减少worker数量，并且返回null从而保证外部获取任务的worker进行正常退出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、允许核心线程退出</span></span><br><span class="line"><span class="comment">         * 2、当前的线程数量超过核心线程数</span></span><br><span class="line"><span class="comment">         * 这时获取任务的机制切换为poll(keepAliveTime)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、线程数大于maximumPoolSize(什么时候会出现这种情况？ 当maximumPoolSize初始设置为0或者其他线程通过set方法对其进行修改)</span></span><br><span class="line"><span class="comment">         * 2、线程数未超过maximumPoolSize但是timed为true(允许核心线程退出或者线程数量超过核心线程)</span></span><br><span class="line"><span class="comment">         * 并且上次获取任务超时(没获取到任务,我们推测本次依旧会超时)</span></span><br><span class="line"><span class="comment">         * 3、在满足条件1或者条件2的情况下进行check：运行线程数大于1或者任务队列没有任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c)) <span class="comment">// CAS进行worker数量-1，成功则返回null进行worker退出流程，失败则继续自旋</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果允许超时退出，则调用poll(keepAliveTime)获取任务，否则则通过tack()一直阻塞等待直到有任务提交到队列</span></span><br><span class="line">            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;<span class="comment">// 当等待超过keepAliveTime时间未获取到任务时，标记为true。在下次自旋时会进入销毁流程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 什么时候会抛出异常？当调用shutdown或者shutdownNow方法触发worker内的Thread调用interrupt方法时会执行到此处</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从getTask方法中，我们明白了核心线程能够保留的原因，这是因为在获取任务时，如果队列为空并且allowCoreThreadTimeOut为false时，通过workQueue.take()方法将挂起线程。着就保证了线程池在处理完任务后核心线程不会被回收。这是也为什么前面在初始化线程池时传入的是阻塞队列的原因了。</p><h5 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果completedAbruptly为ture,则将工作线程数量减一</span></span><br><span class="line">    <span class="comment">//这里completedAbruptly为true是在runWorker执行时异常的情况</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//统计整个线程池完成的任务个数,并从工作集里面删除当前woker</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//尝试设置线程池状态为TERMINATED，如果当前是shutdonw状态并且工作队列为空</span></span><br><span class="line">    <span class="comment">//或者当前是stop状态当前线程池里面没有活动线程</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"><span class="comment">//如果当前线程个数小于核心个数，则增加</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>processWorkerExit流程总结如下：</p><ol><li><p>判断是否是意外退出的，如果是意外退出的话，那么就需要把WorkerCount–</p></li><li><p>加完锁后，同步将completedTaskCount进行增加，表示总共完成的任务数，并且从WorkerSet中将对应的Worker移除</p></li><li><p>调用tryTemiate，进行判断当前的线程池是否处于SHUTDOWN状态，判断是否要终止线程</p></li><li><p>判断当前的线程池状态，如果当前线程池状态比STOP大的话，就不处理</p></li><li><p>否则判断是否是意外退出，如果不是意外退出的话，那么就会判断最少要保留的核心线程数，如果allowCoreThreadTimeOut被设置为true的话，那么说明核心线程在设置的KeepAliveTime之后，也会被销毁。</p></li><li><p>如果最少保留的Worker数为0的话，那么就会判断当前的任务队列是否为空，如果任务队列不为空的话而且线程池没有停止，那么说明至少还需要1个线程继续将任务完成。</p></li><li><p>判断当前的Worker是否大于min，也就是说当前的Worker总数大于最少需要的Worker数的话，那么就直接返回，因为剩下的Worker会继续从WorkQueue中获取任务执行。</p></li><li><p>如果当前运行的Worker数比当前所需要的Worker数少的话，那么就会调用addWorker，添加新的Worker，也就是新开启线程继续处理任务。</p></li></ol><h5 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h5><p>processWorkerExit方法会尝试调用tryTerminate方法来终止线程池，tryTerminate方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//线程池控制状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//线程池控制状态在一下情况下直接返回</span></span><br><span class="line">        <span class="comment">//1.线程池处于运行状态</span></span><br><span class="line">        <span class="comment">//2.c&gt;=TIDYING,线程池已经停止或者正在停止</span></span><br><span class="line">        <span class="comment">//3.SHUTDOWN状态但是工作队列非空</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//程序运行到这里说明线程池控制状态为SHUTDOWN，并且工作队列为空</span></span><br><span class="line">        <span class="comment">//如果还存在工作线程，则中断一个空闲worker</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">//中断一个线程，前面在getTaskf方法中已经说了，核心线程在工作队列为空时将挂起，那么打断一个线程后，工作线程将从runWorker中退出，调用processWorkerExit(w, true),达到关闭所有的工作线程然后关闭线程池的目的</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果没有了工作线程，则 通过CAS，先置为 TIDYING 态，并最终更新为 TERMINATED 态</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 线程安全性检查</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 更新线程池状态为 SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">         <span class="comment">// 尝试关闭空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 空实现</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试中止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法都有特定的目的，其中 <code>checkShutdownAccess()</code> 和 <code>advanceRunState(SHUTDOWN)</code>比较简单，所以这里不再描述了，而 <code>interruptIdleWorkers()</code> 尝试关闭空闲线程这个没什么好说的， <code>tryTerminate()</code>方法上面我们已经做了详细的解释，也不在赘述了。</p><h4 id="submit提交"><a href="#submit提交" class="headerlink" title="submit提交"></a>submit提交</h4><p>submit方法是ThreadPoolExecutor另一种提交任务的方式，它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//将Runnable转换成RunnableFuture</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//调用execut方法</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出submit实际上还是调用的execute方法来提交任务的，只不过submit方式是有返回值的，而execute方式是没有返回值的。</p><p>注意：这里的submit方法并不是ThreadPoolExecutor类中的方法，而是AbstractExecutorService类中的方法，AbstractExecutorService是一个抽象类，ThreadPoolExecutor继承了AbstractExecutorService。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是ThreadPoolExecutor的工作原理和源码分析，希望能够帮助同学们对ThreadPoolExecutor有一个深入的了解。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/singleton/"/>
      <url>/singleton/</url>
      
        <content type="html"><![CDATA[<h3 id="单例模式简介"><a href="#单例模式简介" class="headerlink" title="单例模式简介"></a>单例模式简介</h3><p>所谓的单例模式即在整个系统中，某个类只存在一个实例对象，并且该类只提供一个取得其对象实例的方法。</p><h3 id="单例模式特点"><a href="#单例模式特点" class="headerlink" title="单例模式特点"></a>单例模式特点</h3><p>单例模式有三个重要的特点,分别是：</p><ol><li>一个类只有一个实例</li><li>这个类必须自行创建实例</li><li>这个类必须向整个系统提供这个实例</li></ol><h3 id="单例模式的结构与实现"><a href="#单例模式的结构与实现" class="headerlink" title="单例模式的结构与实现"></a>单例模式的结构与实现</h3><p>单例模式是<code>设计模式</code>中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p><h4 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h4><p>单例模式的主要角色如下。</p><ul><li>单例类：包含一个实例且能自行创建这个实例的类。</li><li>访问类：使用单例的类。</li></ul><p>结构如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/image-20200412144645302.png"  alt="image-20200412144645302"></p><h4 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h4><p>单例模式有八种写法，但是在工作中推荐使用的只有几种方式。</p><h5 id="方式一：饿汉式-静态变量"><a href="#方式一：饿汉式-静态变量" class="headerlink" title="方式一：饿汉式(静态变量)"></a>方式一：饿汉式(静态变量)</h5><p>饿汉式静态变量方式实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTypeOne</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2.类的内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//3.提供一个共有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式虽然实现简单，但功能完全能满足需求，唯一瑕疵的地方就在于<code>Singleton</code>一旦加载到虚拟机中就会被实例化，造成系统资源浪费。但是LZ认为这种浪费完全可以忽略不计，JDK中<code>Runtime</code>的实现单例方式即使用的这种方式。</p><p><strong>推荐指数：☆☆☆☆</strong></p><h5 id="方式二：饿汉式（静态代码块）"><a href="#方式二：饿汉式（静态代码块）" class="headerlink" title="方式二：饿汉式（静态代码块）"></a>方式二：饿汉式（静态代码块）</h5><p>饿汉式静态代码块实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonType02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="comment">//2.类的内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance ;</span><br><span class="line">    <span class="comment">//在静态代码块中创建单例对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.提供一个共有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式和方式一几乎一样，只是把实例化放到了静态代码块中来完成的。</p><p><strong>推荐指数：☆☆☆</strong></p><h5 id="方式三：懒汉式（线程不安全）"><a href="#方式三：懒汉式（线程不安全）" class="headerlink" title="方式三：懒汉式（线程不安全）"></a>方式三：懒汉式（线程不安全）</h5><p>懒汉式实现单例方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式实现单例模式</span></span><br><span class="line"><span class="comment"> * 线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonType03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; System.out.println(Singleton.getInstance().hashCode())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式只能在单线程下保证创建的实例是唯一的，但是在多线程下是不能保证创建的实例是唯一的。原因是假如现在有线程A和线程B同时访问<code>getInstance()</code>方法，线程A在判断完<code>if(instance == null)</code>后，此时CPU调度将时间片分给了线程B，那么线程B也会进行<code>if(instance == null)</code>的判断，这时instance ==null成立，线程B将执行<code>instance = new Singleton()</code>创建一个实例，在线程B创建完实例后，CPU调用将时间片重新分配给了线程A，那么A也将执行<code>instance = new Singleton()</code>再次创建一个新的实例，此时线程A创建的实例和线程B创建的实例就是不一致的。</p><p>测试结果：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/image-20200412153420901.png"  alt="image-20200412153420901"></p><p>既然上面的方式是线程不安全的，那么我们是否可以通过加锁来保障线程安全呢？因此演变出方式四的实现单例。</p><p><strong>推荐指数：不推荐</strong></p><h5 id="方式四：懒汉式-同步方法"><a href="#方式四：懒汉式-同步方法" class="headerlink" title="方式四：懒汉式(同步方法)"></a>方式四：懒汉式(同步方法)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonType04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; System.out.println(Singleton.getInstance().hashCode())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式是在<code>getInstance</code>方法上加<code>synchronized</code>关键词来保障线程安全，但是我们知道<code>synchronized</code>关键词会影响性能，虽然官方自JDK6以后通过适应性自旋锁、锁消除、锁粗化、偏向锁以及轻量级锁等一系列手段对<code>synchronized</code>做了优化，它的性能得到了非常大的提升，但是我们能不能通过其它手段来优化上面的代码呢？这就演出了懒汉式(同步代码块)的实现方式。</p><p><strong>推荐指数：不推荐</strong></p><h5 id="方式五：饿汉式-同步代码块"><a href="#方式五：饿汉式-同步代码块" class="headerlink" title="方式五：饿汉式(同步代码块)"></a>方式五：饿汉式(同步代码块)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonType05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; System.out.println(Singleton.getInstance().hashCode())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式虽然对程序就行了优化，但是在多线程下就变得不安全了，至于原因已经在前面解释过了，主要就是在<code>if(instance == null)</code>这句多个线程都可以进入。</p><p>测试结果如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/image-20200412153811164.png"  alt="image-20200412153811164"></p><p>基于上面方式五是线程不安全，演变成了双重检查机制来既保证了性能，又保障了先安全。</p><p><strong>推荐指数：不推荐</strong></p><h5 id="方式六：双重检查"><a href="#方式六：双重检查" class="headerlink" title="方式六：双重检查"></a>方式六：双重检查</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonType06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; System.out.println(Singleton.getInstance().hashCode())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查机制有一个非常重要的点就是属性<code>instance</code>上必须要有<code>volatile</code>关键词修饰，如果没有<code>volatile</code>关键词修饰，那么双重检查会有一个致命的缺陷。原因是<code>编译器和处理器为了优化程序性能会对指令序列重新排序</code>。关于重排序的知识，有兴趣的同学可以看看LZ的这篇博客<code>https://zzwzdx.cn/jmm-reordering/</code>。好了言归正传，为什么不加<code>volatile</code>就会有缺陷呢？这是因为创建实例不是一个原子操作，即<code>instance = new Singleton();</code>这句话不是原子操作，虽然它就只有一句，但是在虚拟机中它分为了3个步骤，分别是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">// 1:分配对象的内存空间</span></span><br><span class="line">ctorInstance(memory); <span class="comment">// 2:初始化对象</span></span><br><span class="line">instance = memory; <span class="comment">// 3: 设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure><p>上面3行代码中，2和3可能被重排序，如果2和3被重排序, 在对象还未被初始化时，其它线程就有可能拿到了这个还未被初始化的对象去使用，导致了程序出现异常。<code>volatile</code>的作用就是禁止指令2和3重排序。</p><p><strong>推荐指数：☆☆☆☆☆</strong></p><h5 id="方式七：静态内部类"><a href="#方式七：静态内部类" class="headerlink" title="方式七：静态内部类"></a>方式七：静态内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonType07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; System.out.println(Singleton.getInstance().hashCode())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态内部类，该类中有一个静态属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类实现单例模式也是一个非常好的选择，它不仅保证了性能、线程安全和懒加载，而且它的实现也非常的简单。性能的保障是程序没有使用锁，懒加载的保障是<code>INSTANCE</code>实例是在静态内部类中创建的，Singleton类在被加载时，实例是不会被初始化的。线程安全的保障是通过JVM来完成的，JVM初始化类时只会初始化一次，因此SingletonHolder在被虚拟机进行初始化时INSTANCE也只会被初始化一次。</p><p><strong>推荐指数：☆☆☆☆☆</strong></p><h5 id="方式八：枚举"><a href="#方式八：枚举" class="headerlink" title="方式八：枚举"></a>方式八：枚举</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleType08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; System.out.println(Singleton.getInstance().hashCode())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最后一种实现单例模式的方式，这种方式是Josh Bloch在《Effective Java》中提出的。Josh Bloch在《Effective Java》中表明”使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法“。确实看到这里我们也知道使用枚举实现单例是多么的简洁。使用枚举还有一个最大的优势就是不能通过反序列化手段来破坏单例。这里至于为什Enum能保证线程安全和不能反序列化，后面LZ单独写一篇文章解释。</p><p><strong>推荐指数：☆☆☆☆☆</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面就是单例模式的全部内容，从上面可以看到，单例模式看起来简单但实际上呢？完全不是，单例模式要考虑的东西还是很多的，既要考虑性能还要考虑线程安全必要时还需要考虑反序列化的问题。至于最喜欢哪种方式，那就是萝卜白菜各有所爱了！</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis3源码之XMLMapperBuilder加载ResultMap过程</title>
      <link href="/mybatis3-source-xmlmapperbuilder/"/>
      <url>/mybatis3-source-xmlmapperbuilder/</url>
      
        <content type="html"><![CDATA[<h3 id="XMLMapperBuilder-parse-方法"><a href="#XMLMapperBuilder-parse-方法" class="headerlink" title="XMLMapperBuilder.parse()方法"></a>XMLMapperBuilder.parse()方法</h3><p>XMLConfigBuilder在解析过程中碰到mappers元素会交由XMLMapperBuilder.parse()方法来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        <span class="comment">//真正解析</span></span><br><span class="line">        configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingChacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">     <span class="comment">//在Mybatis3中mapper元素必须定义命名空间</span></span><br><span class="line">     <span class="keyword">if</span> (namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//缓存,以后再看</span></span><br><span class="line">     cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">     cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">     <span class="comment">//解析parameterMap节点，Mybatis3中官方已经不推荐使用parameterMap配置，这里也不做讨论</span></span><br><span class="line">     parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//解析resultMap</span></span><br><span class="line">     resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">     sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line"></span><br><span class="line">     <span class="comment">//解析sql</span></span><br><span class="line">     buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. Cause: "</span> + e, e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="解析resultMap节点"><a href="#解析resultMap节点" class="headerlink" title="解析resultMap节点"></a>解析resultMap节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ResultMap <span class="title">resultMapElement</span><span class="params">(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"processing "</span> + resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    <span class="comment">//id,对应ResultMap.id,内映射没有ID,用&lt;span style="font-family: Arial, Helvetica, sans-serif; font-size: 12px;"&gt;resultMapNode.getValueBasedIdentifier()方法生成一个&lt;/span&gt;</span></span><br><span class="line">    String id = resultMapNode.getStringAttribute(<span class="string">"id"</span>,</span><br><span class="line">                                                 resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    <span class="comment">//type,对应ResultMap.Type,这里可以看到这个type可以通过很多个属性进行配置</span></span><br><span class="line">    String type = resultMapNode.getStringAttribute(<span class="string">"type"</span>,</span><br><span class="line">                                                   resultMapNode.getStringAttribute(<span class="string">"ofType"</span>,</span><br><span class="line">                                                                                    resultMapNode.getStringAttribute(<span class="string">"resultType"</span>,</span><br><span class="line">                                                                                                                     resultMapNode.getStringAttribute(<span class="string">"javaType"</span>))));</span><br><span class="line">    String extend = resultMapNode.getStringAttribute(<span class="string">"extends"</span>);</span><br><span class="line">    <span class="comment">//是否自动映射</span></span><br><span class="line">    Boolean autoMapping = resultMapNode.getBooleanAttribute(<span class="string">"autoMapping"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将type解析成class,可以是别名，也可以是全限定名</span></span><br><span class="line">    Class&lt;?&gt; typeClass = resolveClass(type);</span><br><span class="line">    Discriminator discriminator = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//这个resultMappings将对应ResultMap.resultMappings</span></span><br><span class="line">    List&lt;ResultMapping&gt; resultMappings = <span class="keyword">new</span> ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">    resultMappings.addAll(additionalResultMappings);</span><br><span class="line">    List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();</span><br><span class="line">    <span class="keyword">for</span> (XNode resultChild : resultChildren) &#123;<span class="comment">//解析子节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"constructor"</span>.equals(resultChild.getName())) &#123;</span><br><span class="line">            <span class="comment">//解析constructor节点</span></span><br><span class="line">            processConstructorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"discriminator"</span>.equals(resultChild.getName())) &#123;</span><br><span class="line">            <span class="comment">//解析disriminator节点，暂时不讨论</span></span><br><span class="line">            discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ArrayList&lt;ResultFlag&gt; flags = <span class="keyword">new</span> ArrayList&lt;ResultFlag&gt;();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"id"</span>.equals(resultChild.getName())) &#123;</span><br><span class="line">                flags.add(ResultFlag.ID);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解析其他节点,主要有result、association及collection</span></span><br><span class="line">            <span class="comment">//在这里可以说明一个result、association及collection都会被解析成一个resultMapping对象，即使他们有很多子元素</span></span><br><span class="line">            resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ResultMapResolver resultMapResolver = <span class="keyword">new</span> ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//得到resultMappings后，生成ResultMap并加入到Configuration中</span></span><br><span class="line">        <span class="keyword">return</span> resultMapResolver.resolve();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncompleteElementException  e) &#123;</span><br><span class="line">        configuration.addIncompleteResultMap(resultMapResolver);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resultMapResolver.resolve()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultMap <span class="title">resolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> assistant.addResultMap(<span class="keyword">this</span>.id, <span class="keyword">this</span>.type, <span class="keyword">this</span>.extend, <span class="keyword">this</span>.discriminator, <span class="keyword">this</span>.resultMappings, <span class="keyword">this</span>.autoMapping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MapperBuilderAssistant.addResultMap()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultMap <span class="title">addResultMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String id,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">    String extend,</span></span></span><br><span class="line"><span class="function"><span class="params">    Discriminator discriminator,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;ResultMapping&gt; resultMappings,</span></span></span><br><span class="line"><span class="function"><span class="params">    Boolean autoMapping)</span> </span>&#123;</span><br><span class="line">    id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">    extend = applyCurrentNamespace(extend, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//交由ResultMap.Builder来创建ResultMap对象，ResultMap.Builder.build()方法前面已经介绍过</span></span><br><span class="line">    ResultMap.Builder resultMapBuilder = <span class="keyword">new</span> ResultMap.Builder(configuration, id, type, resultMappings, autoMapping);</span><br><span class="line">    <span class="keyword">if</span> (extend != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//对继承了其他resultMap的处理，暂时不讨论</span></span><br><span class="line">        <span class="keyword">if</span> (!configuration.hasResultMap(extend)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">"Could not find a parent resultmap with id '"</span> + extend + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ResultMap resultMap = configuration.getResultMap(extend);</span><br><span class="line">        List&lt;ResultMapping&gt; extendedResultMappings = <span class="keyword">new</span> ArrayList&lt;ResultMapping&gt;(resultMap.getResultMappings());</span><br><span class="line">        extendedResultMappings.removeAll(resultMappings);</span><br><span class="line">        <span class="comment">// Remove parent constructor if this resultMap declares a constructor.</span></span><br><span class="line">        <span class="keyword">boolean</span> declaresConstructor = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (ResultMapping resultMapping : resultMappings) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">                declaresConstructor = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (declaresConstructor) &#123;</span><br><span class="line">            Iterator&lt;ResultMapping&gt; extendedResultMappingsIter = extendedResultMappings.iterator();</span><br><span class="line">            <span class="keyword">while</span> (extendedResultMappingsIter.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (extendedResultMappingsIter.next().getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">                    extendedResultMappingsIter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resultMappings.addAll(extendedResultMappings);</span><br><span class="line">    &#125;</span><br><span class="line">    resultMapBuilder.discriminator(discriminator);</span><br><span class="line">    <span class="comment">//生成ResultMap对象</span></span><br><span class="line">    ResultMap resultMap = resultMapBuilder.build();</span><br><span class="line">    <span class="comment">//另到Configuration中</span></span><br><span class="line">    configuration.addResultMap(resultMap);</span><br><span class="line">    <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上分析，在得到resultMappings之后再构造ResultMap对象的过程已经完成。下面再看看ResultMapping是怎么被解析的，也就是ResultMap的直接子节点的解析。</p><h3 id="ResultMapping解析"><a href="#ResultMapping解析" class="headerlink" title="ResultMapping解析"></a>ResultMapping解析</h3><p>constructor节点解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processConstructorElement</span><span class="params">(XNode resultChild, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;XNode&gt; argChildren = resultChild.getChildren();</span><br><span class="line">    <span class="comment">//遍历子节点</span></span><br><span class="line">    <span class="keyword">for</span> (XNode argChild : argChildren) &#123;</span><br><span class="line">        ArrayList&lt;ResultFlag&gt; flags = <span class="keyword">new</span> ArrayList&lt;ResultFlag&gt;();</span><br><span class="line">        <span class="comment">//标识为ResultFlag.CONSTRUCTOR</span></span><br><span class="line">        flags.add(ResultFlag.CONSTRUCTOR);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"idArg"</span>.equals(argChild.getName())) &#123;</span><br><span class="line">            <span class="comment">//标识为一个ID属性</span></span><br><span class="line">            flags.add(ResultFlag.ID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个ResultMapping对象，并加入resultMappings</span></span><br><span class="line">        <span class="comment">//这里说明了，constructor下有多个几子节点，就会产生多少个resultMapping对象</span></span><br><span class="line">        resultMappings.add(buildResultMappingFromContext(argChild, resultType, flags));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buildResultMappingFromContext()方法生成了一个ResultMapping对象，解析如下节点都会调用这个方法来实现：</p><ol><li><p>constructor/idArg  </p></li><li><p>constructor/arg</p></li><li><p>result</p></li><li><p>association</p></li><li><p>collection</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ResultMapping <span class="title">buildResultMappingFromContext</span><span class="params">(XNode context, Class&lt;?&gt; resultType, ArrayList&lt;ResultFlag&gt; flags)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String property = context.getStringAttribute(<span class="string">"property"</span>);</span><br><span class="line">    String column = context.getStringAttribute(<span class="string">"column"</span>);</span><br><span class="line">    String javaType = context.getStringAttribute(<span class="string">"javaType"</span>);</span><br><span class="line">    String jdbcType = context.getStringAttribute(<span class="string">"jdbcType"</span>);</span><br><span class="line">    String nestedSelect = context.getStringAttribute(<span class="string">"select"</span>);</span><br><span class="line">    <span class="comment">//这里需要特殊说明，一个resultMapping可以对应一个resultMap对应，我们称之为内部映射</span></span><br><span class="line">    String nestedResultMap = context.getStringAttribute(<span class="string">"resultMap"</span>,</span><br><span class="line">                                                        processNestedResultMappings(context, Collections.&lt;ResultMapping&gt; emptyList()));</span><br><span class="line">    String notNullColumn = context.getStringAttribute(<span class="string">"notNullColumn"</span>);</span><br><span class="line">    String columnPrefix = context.getStringAttribute(<span class="string">"columnPrefix"</span>);</span><br><span class="line">    String typeHandler = context.getStringAttribute(<span class="string">"typeHandler"</span>);</span><br><span class="line">    String resulSet = context.getStringAttribute(<span class="string">"resultSet"</span>);</span><br><span class="line">    String foreignColumn = context.getStringAttribute(<span class="string">"foreignColumn"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> lazy = <span class="string">"lazy"</span>.equals(context.getStringAttribute(<span class="string">"fetchType"</span>, configuration.isLazyLoadingEnabled() ? <span class="string">"lazy"</span> : <span class="string">"eager"</span>));</span><br><span class="line">    Class&lt;?&gt; javaTypeClass = resolveClass(javaType);</span><br><span class="line">    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;) resolveClass(typeHandler);</span><br><span class="line">    JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);</span><br><span class="line">    <span class="comment">//这里的ResultMapping生成的方法跟ResultMap生成的过程大同小异，这里不再做讨论</span></span><br><span class="line">    <span class="keyword">return</span> builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resulSet, foreignColumn, lazy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一个内部的ReulstMapp对象，并加到Congruation中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">processNestedResultMappings</span><span class="params">(XNode context, List&lt;ResultMapping&gt; resultMappings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//只有association, collection, case节点才会生成内部映射，其他不生成，返回null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"association"</span>.equals(context.getName())</span><br><span class="line">        || <span class="string">"collection"</span>.equals(context.getName())</span><br><span class="line">        || <span class="string">"case"</span>.equals(context.getName())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.getStringAttribute(<span class="string">"select"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//这里类似一个递归调用，需要注意内部映射的ID是Mybatis自动生成的，不是在配置文件里读取的</span></span><br><span class="line">            ResultMap resultMap = resultMapElement(context, resultMappings);</span><br><span class="line">            <span class="keyword">return</span> resultMap.getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看内部映射的ID是怎么生成的:XMLMapperBuilder.resultMapElement方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ResultMap <span class="title">resultMapElement</span><span class="params">(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"processing "</span> + resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    String id = resultMapNode.getStringAttribute(<span class="string">"id"</span>,</span><br><span class="line">                                                 resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    <span class="comment">//getValueBasedIdentifier这就是内部映射生成ID的地方，这个只是一个标识，保证唯一性即可！这里不再讨论！</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在此，XMLMapperBuilder对配置文件中的resultMap元素的解析并生成ResultMap对象的分析基本完成。这里总结几点：</p><ol><li><p>ResultMap对象是结果集中的一行记录和一个java对象的对应关系。</p></li><li><p>ResultMapping对象是结果集中的列与java对象的属性之间的对应关系。</p></li><li><p>ResultMapp由id,type等基本的属性组成外，还包含多个ResultMapping对象。这类似于一个java对象由多个属性组成一个道理。</p></li><li><p>ResultMapping最主要的属性column(结果集字段名),property(java对象的属性)，ResultMapping可以指向一个内查询或内映射。</p></li><li><p>XMLMapperBuilder调用如下方法来解析并生成ResultMap对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings)</span><br></pre></td></tr></table></figure></li><li><p>在resultMapElement方法中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ResultMapping <span class="title">buildResultMappingFromContext</span><span class="params">(XNode context, Class&lt;?&gt; resultType, ArrayList&lt;ResultFlag&gt; flags)</span></span></span><br></pre></td></tr></table></figure><p>方法来子节点解析成ResultMapping对象。</p></li><li><p>ResultMap和ResultMapping对象都是由相对应的Builder构建的。Builder只是进行了一些数据验证，并没有太多的业务逻辑。</p></li></ol><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5G73Rn" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5G73Rn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis3源码之ResultMap加载过程</title>
      <link href="/mybatis3-resultmap-loading/"/>
      <url>/mybatis3-resultmap-loading/</url>
      
        <content type="html"><![CDATA[<h3 id="XMLMapperBuilder简单说明"><a href="#XMLMapperBuilder简单说明" class="headerlink" title="XMLMapperBuilder简单说明"></a>XMLMapperBuilder简单说明</h3><p>XMLMapperBuildery主要是加载mapper配置文件加Configuration中。主要加载两大内容  </p><ol><li><p>ResultMap:结果集映射，对应Configuration中的resultMaps属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ResultMap&gt; resultMaps = <span class="keyword">new</span> StrictMap&lt;ResultMap&gt;(<span class="string">"Result Maps collection"</span>);</span><br></pre></td></tr></table></figure></li><li><p>sql:即mapper配置文件中的select、update、insert、delete节点。对应Configuration中的mappedStatements</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, MappedStatement&gt; mappedStatements = <span class="keyword">new</span> StrictMap&lt;MappedStatement&gt;(<span class="string">"Mapped Statements collection"</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="Configuration内部类StrictMap分析"><a href="#Configuration内部类StrictMap分析" class="headerlink" title="Configuration内部类StrictMap分析"></a>Configuration内部类StrictMap分析</h3><p>StrictMap继承了HashMap&lt;String,T&gt;主要增加了如下三点:</p><ol><li><p>多了一个名字，然而并没有什么用处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StrictMap</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写了put方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(String key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (containsKey(key))</span><br><span class="line">    <span class="comment">//如果已经存在key，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(name + <span class="string">" already contains value for "</span> + key);</span><br><span class="line">  <span class="keyword">if</span> (key.contains(<span class="string">"."</span>)) &#123;<span class="comment">//key中是否存在"."</span></span><br><span class="line">    <span class="comment">//getShortName()方法获取了最后一个"."之后的字符，如:key=com.ashan.Hello,那么shortName=Hello</span></span><br><span class="line">    <span class="keyword">final</span> String shortKey = getShortName(key);</span><br><span class="line">    <span class="comment">//再判断shortKey是否已经存在了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">super</span>.get(shortKey) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果不存在，直接设置</span></span><br><span class="line">      <span class="keyword">super</span>.put(shortKey, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果已经存在，设置为一个特殊的对象，标识shortName同时对应的了多个值</span></span><br><span class="line">      <span class="keyword">super</span>.put(shortKey, (V) <span class="keyword">new</span> Ambiguity(shortKey));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个put方法主要逻辑：</p><ol><li>如果key已经存在，将直接报错</li><li>如果key还未存在，直接设置</li><li>如果key中包含了”.”符号，截取最后一个”.”符号后面的字符串做为shortName</li><li>如果shortName之前已经存在，将shortName对应的值设置为一个特殊对名，get方法如果获取一个特殊对象里将报错</li><li>如果shortName未存在，将shortName对应的值设置成与key对应的值一样</li></ol><p>例如：调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put(com.ashan.selectUserById,<span class="string">"select * from tab_user where id=?"</span>)</span><br></pre></td></tr></table></figure><p>map里将这样保存数据(两key对应同一个value)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.ashan.selectUserById=<span class="string">"select * from tab_user where id=?"</span></span><br><span class="line">          selectUserById=<span class="string">"select * from tab_user where id=?"</span></span><br></pre></td></tr></table></figure></li><li><p>重写了get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  V value = <span class="keyword">super</span>.get(key);</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(name + <span class="string">" does not contain value for "</span> + key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Ambiguity) &#123;</span><br><span class="line"><span class="comment">//如果为特殊对象Ambiguity，同一个shortName有多个命名空间使用，所有不允许用shortName方法，必须加上命名空间访问</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(((Ambiguity) value).getSubject() + <span class="string">" is ambiguous in "</span> + name</span><br><span class="line">                                       + <span class="string">" (try using the full name including the namespace, or rename one of the entries)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StrictMap只是增加了对命名空间的支持，并没有太多的逻辑！</p></li></ol><h3 id="ResultMap类"><a href="#ResultMap类" class="headerlink" title="ResultMap类"></a>ResultMap类</h3><p>mapper配置文件中的resultMap节点最终会被解析成一个ResultMap对象，这个对象中包含多个ResultMapping对象，我们可以这样子认为，ResultMap为一个java对象和一个结果集/表中的一行记录对应，ResultMapping为一个java对象中的属性和一个结果集/表某一行的某一个字段对应。如下示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.ashan.mybatis.User"</span> <span class="attr">id</span>=<span class="string">"detailUserResultMap"</span>&gt;</span><span class="comment">&lt;!-- 整个resultMap会被解析成一个ResultMap对应 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">javaType</span>=<span class="string">"String"</span>/&gt;</span><span class="comment">&lt;!-- idArg会被解析成一个resultMapping对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">column</span>=<span class="string">"user_name"</span>/&gt;</span><span class="comment">&lt;!-- resultMapping对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"user_pwd"</span> /&gt;</span><span class="comment">&lt;!-- resultMapping对象 --&gt;</span></span><br><span class="line">&lt;result property="type" column="user_type" javaType="com.ashan.mybatis.UserType" &lt;!-- resultMapping对象 --&gt;</span><br><span class="line">       typeHandler="com.ashan.mybatis.UserTypeHandler"/&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"svcnum"</span> <span class="attr">column</span>=<span class="string">"svc_num"</span> /&gt;</span> <span class="comment">&lt;!-- resultMapping对象 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"cust"</span> <span class="attr">javaType</span>=<span class="string">"com.ashan.mybatis.Cust"</span>&gt;</span> <span class="comment">&lt;!-- resultMapping对象 这个resultMapping对象指向了另一个ResultMap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"cust_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"custname"</span> <span class="attr">column</span>=<span class="string">"cust_name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"certNo"</span> <span class="attr">column</span>=<span class="string">"cert_no"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"accts"</span> <span class="attr">ofType</span>=<span class="string">"com.ashan.mybatis.Acct"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"acct_id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"payName"</span> <span class="attr">column</span>=<span class="string">"pay_name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bankNo"</span> <span class="attr">column</span>=<span class="string">"bank_no"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ResultMap的主要属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id="detailUserResultMap"</span></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="comment">//type="com.ashan.mybatis.User"</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">//所有的resultMapping对象，包括constructor/idArg,constructor/arg,result,association,collection,但不包括association和collection里的子节点</span></span><br><span class="line"><span class="comment">//上图中应该有7个</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; resultMappings;</span><br><span class="line"><span class="comment">//包括constructor/idArg,id</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; idResultMappings;</span><br><span class="line"><span class="comment">//constructor里的子节点</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; constructorResultMappings;</span><br><span class="line"><span class="comment">//除constructor里的子节点,其他都是，result,association,collection,id</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; propertyResultMappings;</span><br><span class="line"><span class="comment">//所有被映射的列</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; mappedColumns;</span><br><span class="line"><span class="comment">//比较少用</span></span><br><span class="line"><span class="keyword">private</span> Discriminator discriminator;</span><br><span class="line"><span class="comment">//是否有内映射，上图中association, collection都为内映射,内查询不算（就是的reulst节点中配置select属性的情况）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedResultMaps;</span><br><span class="line"><span class="comment">//是否有查询，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedQueries;</span><br><span class="line"><span class="comment">//是否要求自动映射</span></span><br><span class="line"><span class="keyword">private</span> Boolean autoMapping;</span><br></pre></td></tr></table></figure><p>ResultMap.Builder.build()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultMap <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (resultMap.id == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ResultMaps must have an id"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  resultMap.mappedColumns = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">  resultMap.idResultMappings = <span class="keyword">new</span> ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">  resultMap.constructorResultMappings = <span class="keyword">new</span> ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">  resultMap.propertyResultMappings = <span class="keyword">new</span> ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">  <span class="comment">//遍历所有的resultMapping</span></span><br><span class="line">  <span class="keyword">for</span> (ResultMapping resultMapping : resultMap.resultMappings) &#123;</span><br><span class="line">    <span class="comment">//如果其中一个resultMapping有内查询，则这个resultMap也就是有内查询</span></span><br><span class="line">    resultMap.hasNestedQueries = resultMap.hasNestedQueries || resultMapping.getNestedQueryId() != <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//如果其中一个resultMapping有内映射，则这个resultMap也就是有内映射</span></span><br><span class="line">    resultMap.hasNestedResultMaps = resultMap.hasNestedResultMaps || (resultMapping.getNestedResultMapId() != <span class="keyword">null</span> &amp;&amp; resultMapping.getResultSet() == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> String column = resultMapping.getColumn();</span><br><span class="line">    <span class="keyword">if</span> (column != <span class="keyword">null</span>) &#123;</span><br><span class="line">      resultMap.mappedColumns.add(column.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultMapping.isCompositeResult()) &#123;</span><br><span class="line">      <span class="comment">//组合的配置</span></span><br><span class="line">      <span class="keyword">for</span> (ResultMapping compositeResultMapping : resultMapping.getComposites()) &#123;</span><br><span class="line">        <span class="keyword">final</span> String compositeColumn = compositeResultMapping.getColumn();</span><br><span class="line">        <span class="keyword">if</span> (compositeColumn != <span class="keyword">null</span>) &#123;</span><br><span class="line">          resultMap.mappedColumns.add(compositeColumn.toUpperCase(Locale.ENGLISH));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">      resultMap.constructorResultMappings.add(resultMapping);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resultMap.propertyResultMappings.add(resultMapping);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.ID)) &#123;</span><br><span class="line">      resultMap.idResultMappings.add(resultMapping);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (resultMap.idResultMappings.isEmpty()) &#123;</span><br><span class="line">    resultMap.idResultMappings.addAll(resultMap.resultMappings);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// lock down collections</span></span><br><span class="line">  resultMap.resultMappings = Collections.unmodifiableList(resultMap.resultMappings);</span><br><span class="line">  resultMap.idResultMappings = Collections.unmodifiableList(resultMap.idResultMappings);</span><br><span class="line">  resultMap.constructorResultMappings = Collections.unmodifiableList(resultMap.constructorResultMappings);</span><br><span class="line">  resultMap.propertyResultMappings = Collections.unmodifiableList(resultMap.propertyResultMappings);</span><br><span class="line">  resultMap.mappedColumns = Collections.unmodifiableSet(resultMap.mappedColumns);</span><br><span class="line">  <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResultMapping主要属性"><a href="#ResultMapping主要属性" class="headerlink" title="ResultMapping主要属性"></a>ResultMapping主要属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Configuration configuration;</span><br><span class="line"><span class="comment">//java对象的属性名</span></span><br><span class="line"><span class="keyword">private</span> String property;</span><br><span class="line"><span class="comment">//结果集中的字段名</span></span><br><span class="line"><span class="keyword">private</span> String column;</span><br><span class="line"><span class="comment">//属性类型</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; javaType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> JdbcType jdbcType;</span><br><span class="line"><span class="keyword">private</span> TypeHandler&lt;?&gt; typeHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部映射的ResultMapId</span></span><br><span class="line"><span class="keyword">private</span> String nestedResultMapId;</span><br><span class="line"><span class="comment">//内查询ID</span></span><br><span class="line"><span class="keyword">private</span> String nestedQueryId;</span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; notNullColumns;</span><br><span class="line"><span class="keyword">private</span> String columnPrefix;</span><br><span class="line"><span class="keyword">private</span> List&lt;ResultFlag&gt; flags;</span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; composites;</span><br><span class="line"><span class="keyword">private</span> String resultSet;</span><br><span class="line"><span class="keyword">private</span> String foreignColumn;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> lazy;</span><br></pre></td></tr></table></figure><p>这个类就是一个普通的java对象，本身没有什么逻辑，要想知道属性是怎么产生的,还得分析XMLMapperBuildery的源代码。</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/6gRndy" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/6gRndy</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis3源码之Configuration加载过程</title>
      <link href="/mybatis3-configuration-loading/"/>
      <url>/mybatis3-configuration-loading/</url>
      
        <content type="html"><![CDATA[<h3 id="Configuration-类在-Mybatis-中的作用"><a href="#Configuration-类在-Mybatis-中的作用" class="headerlink" title="Configuration 类在 Mybatis 中的作用"></a>Configuration 类在 Mybatis 中的作用</h3><p>Configuration 类保存了所有 Mybatis 的配置信息。也就是说 mybaits-config.xml 及 UserMapper.xml 中所有配置信息都可以在 Configruation 对象中找到相应的信息。一般情况下 Mybatis 在运行过程中只会创建一个 Configration 对象，并且配置信息不能再被修改。如何配置 Mybatis 可以看这个文档：<a href="http://mybatis.org/mybatis-3/zh/configuration.html" target="_blank" rel="external nofollow noopener noreferrer" title="http://mybatis.org/mybatis-3/zh/configuration.html">http://mybatis.org/mybatis-3/zh/configuration.html</a></p><h3 id="Configuration-的属性"><a href="#Configuration-的属性" class="headerlink" title="Configuration 的属性"></a>Configuration 的属性</h3><p>configuration 的属性主要分为两大部分：</p><ol><li>从 mybatis-config.xml 中读取的配置</li><li>从 mapper 配置文件或 Mapper 注解读取的配置</li></ol><p>下面简单说一下这两部分的属性与配置的对应关系</p><h4 id="从-mybatis-config-xml-文件中对应的属性"><a href="#从-mybatis-config-xml-文件中对应的属性" class="headerlink" title="从 mybatis-config.xml 文件中对应的属性"></a>从 mybatis-config.xml 文件中对应的属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> safeRowBoundsEnabled = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> safeResultHandlerEnabled = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> mapUnderscoreToCamelCase = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> aggressiveLazyLoading = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> multipleResultSetsEnabled = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> useGeneratedKeys = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> useColumnLabel = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> cacheEnabled = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> callSettersOnNulls = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">protected</span> String logPrefix;</span><br><span class="line"><span class="keyword">protected</span> Class &lt;? extends Log&gt; logImpl;</span><br><span class="line"><span class="keyword">protected</span> LocalCacheScope localCacheScope = LocalCacheScope.SESSION;</span><br><span class="line"><span class="keyword">protected</span> JdbcType jdbcTypeForNull = JdbcType.OTHER;</span><br><span class="line"><span class="keyword">protected</span> Set&lt;String&gt; lazyLoadTriggerMethods = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(<span class="keyword">new</span> String[] &#123; <span class="string">"equals"</span>, <span class="string">"clone"</span>, <span class="string">"hashCode"</span>, <span class="string">"toString"</span> &#125;));</span><br><span class="line"><span class="keyword">protected</span> Integer defaultStatementTimeout;</span><br><span class="line"><span class="keyword">protected</span> ExecutorType defaultExecutorType = ExecutorType.SIMPLE;</span><br><span class="line"><span class="keyword">protected</span> AutoMappingBehavior autoMappingBehavior = AutoMappingBehavior.PARTIAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Properties variables = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="keyword">protected</span> ObjectFactory objectFactory = <span class="keyword">new</span> DefaultObjectFactory();</span><br><span class="line"><span class="keyword">protected</span> ObjectWrapperFactory objectWrapperFactory = <span class="keyword">new</span> DefaultObjectWrapperFactory();</span><br><span class="line"><span class="keyword">protected</span> MapperRegistry mapperRegistry = <span class="keyword">new</span> MapperRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> lazyLoadingEnabled = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">protected</span> ProxyFactory proxyFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> InterceptorChain interceptorChain = <span class="keyword">new</span> InterceptorChain();</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry = <span class="keyword">new</span> TypeHandlerRegistry();</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeAliasRegistry typeAliasRegistry = <span class="keyword">new</span> TypeAliasRegistry();</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> LanguageDriverRegistry languageRegistry = <span class="keyword">new</span> LanguageDriverRegistry();</span><br></pre></td></tr></table></figure><p>以上属性可以说都是由 mybatis-config.xml 文件中读取的。</p><p>例如文件中的 setting 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"multipleResultSetsEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useColumnLabel"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useGeneratedKeys"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"autoMappingBehavior"</span> <span class="attr">value</span>=<span class="string">"PARTIAL"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultExecutorType"</span> <span class="attr">value</span>=<span class="string">"SIMPLE"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultStatementTimeout"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultFetchSize"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"safeRowBoundsEnabled"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"jdbcTypeForNull"</span> <span class="attr">value</span>=<span class="string">"OTHER"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadTriggerMethods"</span> <span class="attr">value</span>=<span class="string">"equals,clone,hashCode,toString"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看配置的内容和 Configuration 中的属性名称，就大概知道对应关系。相信之后的解析内容了不会太复杂。</p><h4 id="从-Mapper-配置文件中读取的属性"><a href="#从-Mapper-配置文件中读取的属性" class="headerlink" title="从 Mapper 配置文件中读取的属性"></a>从 Mapper 配置文件中读取的属性</h4><p>如下属性是从 Mapper 配置文件中读取的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, MappedStatement&gt; mappedStatements = <span class="keyword">new</span> StrictMap&lt;MappedStatement&gt;(<span class="string">"Mapped Statements collection"</span>);</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, Cache&gt; caches = <span class="keyword">new</span> StrictMap&lt;Cache&gt;(<span class="string">"Caches collection"</span>);</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ResultMap&gt; resultMaps = <span class="keyword">new</span> StrictMap&lt;ResultMap&gt;(<span class="string">"Result Maps collection"</span>);</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ParameterMap&gt; parameterMaps = <span class="keyword">new</span> StrictMap&lt;ParameterMap&gt;(<span class="string">"Parameter Maps collection"</span>);</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, KeyGenerator&gt; keyGenerators = <span class="keyword">new</span> StrictMap&lt;KeyGenerator&gt;(<span class="string">"Key Generators collection"</span>);</span><br></pre></td></tr></table></figure><p>其中最主要的也是相对复杂的有如下两个(Mapper 配置文件也主要是配置这两项):</p><ol><li>mappedStatements 属性，保存了所有 Mapper 配置文件中的 select/update/insert/delete 节点信息。属性类型为一个 Map,key 为 sql 对应的 ID,MappedSatement 为一个 java 对象，保存了一个 select/update/insert/delete 的节点信息。</li><li>resultMaps 属性，保存了所有 Mapper 配置文件中的 resultMap 节点。</li></ol><p>Mapper 配置文件也主要是配置 select/update/insert/delete/resultMap 这几个节点。</p><h3 id="Configuration-加载过程"><a href="#Configuration-加载过程" class="headerlink" title="Configuration 加载过程"></a>Configuration 加载过程</h3><p>针对 mybatis-config.xml 配置文件和 Mapper 配置文件，Mybatis 也是由两个相对应的类来解析的。</p><ol><li>XMLConfigBuilder 解析 mybatis-config.xml 的配置到 Configuration 中</li><li>XMLMapperBuilder 解析 Mapper 配置文件的配置到 Configuration 中</li></ol><h4 id="XMLConfigBuilder-parse-方法"><a href="#XMLConfigBuilder-parse-方法" class="headerlink" title="XMLConfigBuilder.parse()方法"></a>XMLConfigBuilder.parse()方法</h4><p>通过 SqlSessionFactory 获取 Configuration 的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory=<span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">System.out.println(sqlSessionFactory.getConfiguration());</span><br></pre></td></tr></table></figure><p>再来看 SqlSessionFactoryBuilder.build()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> build(inputStream, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> build(inputStream, environment, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, Properties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> build(inputStream, <span class="keyword">null</span>, properties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line"><span class="comment">//从这里可以看出XMLConfigBuilder.parse()返回了一个Configuration对象</span></span><br><span class="line"><span class="keyword">return</span> build(parser.parse());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">ErrorContext.instance().reset();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">inputStream.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载具体配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="keyword">true</span>;</span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从xml配置文件中加载到Configuration对象中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//加载properties节点,一般是定义一些变量</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">"properties"</span>)); <span class="comment">//issue #117 read properties first</span></span><br><span class="line">    <span class="comment">//加载别名</span></span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">    <span class="comment">//拦截器</span></span><br><span class="line">    pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line"></span><br><span class="line">    settingsElement(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">"environments"</span>)); <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载Mapper的配置文件，最主要的有两个：一个是sql的定义，一个是resultMap</span></span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">    mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加载-properties-节点"><a href="#加载-properties-节点" class="headerlink" title="加载 properties 节点"></a>加载 properties 节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">propertiesElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//先加载property子节点下的属性</span></span><br><span class="line">    Properties defaults = context.getChildrenAsProperties();</span><br><span class="line">    String resource = context.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">    String url = context.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">    <span class="comment">//不能同时设置resource属性和url属性</span></span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//会覆盖子节点的配置</span></span><br><span class="line">      defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//会覆盖子节点的配置</span></span><br><span class="line">      defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">    &#125;</span><br><span class="line">    Properties vars = configuration.getVariables();</span><br><span class="line">    <span class="keyword">if</span> (vars != <span class="keyword">null</span>) &#123;</span><br><span class="line">      defaults.putAll(vars);</span><br><span class="line">    &#125;</span><br><span class="line">    parser.setVariables(defaults);</span><br><span class="line">    <span class="comment">//设置了变量列表中去</span></span><br><span class="line">    configuration.setVariables(defaults);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法中可以看出配置规则</p><ol><li><p>可以设置 url 或 resource 属性从外部文件中加载一个 properties 文件</p></li><li><p>可以通过 property 子节点进行配置，如果子节点属性的 key 与外部文件的 key 重复的话，子节点的将被覆</p></li><li><p>通过编程方式定义的属性最后加载，优先级最高：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, Properties properties)</span></span></span><br></pre></td></tr></table></figure></li></ol><p>properties 配置示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/config.properties"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"dev_user"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"F2Fa3!33TYyg"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里加载的主要是给后面的配置作为变量使用!</p><h2 id="加载别名"><a href="#加载别名" class="headerlink" title="加载别名"></a>加载别名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">typeAliasesElement</span><span class="params">(XNode parent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="comment">//package的方式，很少用到，略过</span></span><br><span class="line">        String typeAliasPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String alias = child.getStringAttribute(<span class="string">"alias"</span>);</span><br><span class="line">        String type = child.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Class&lt;?&gt; clazz = Resources.classForName(type);</span><br><span class="line">          <span class="keyword">if</span> (alias == <span class="keyword">null</span>) &#123;</span><br><span class="line">            typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//加载到别名注册表中</span></span><br><span class="line">            typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error registering typeAlias for '"</span> + alias + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看 TypeAliasRegistry 源码，发现 mybatis 已经为定义了很多别名，方便以后的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TypeAliasRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    registerAlias(<span class="string">"string"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"byte"</span>, Byte<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"long"</span>, Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"short"</span>, Short<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"int"</span>, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"integer"</span>, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"double"</span>, Double<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"float"</span>, Float<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"boolean"</span>, Boolean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"byte[]"</span>, Byte[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"long[]"</span>, Long[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"short[]"</span>, Short[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"int[]"</span>, Integer[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"integer[]"</span>, Integer[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"double[]"</span>, Double[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"float[]"</span>, Float[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"boolean[]"</span>, Boolean[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"_byte"</span>, <span class="keyword">byte</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_long"</span>, <span class="keyword">long</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_short"</span>, <span class="keyword">short</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_int"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_integer"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_double"</span>, <span class="keyword">double</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_float"</span>, <span class="keyword">float</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_boolean"</span>, <span class="keyword">boolean</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"_byte[]"</span>, <span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_long[]"</span>, <span class="keyword">long</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_short[]"</span>, <span class="keyword">short</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_int[]"</span>, <span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_integer[]"</span>, <span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_double[]"</span>, <span class="keyword">double</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_float[]"</span>, <span class="keyword">float</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_boolean[]"</span>, <span class="keyword">boolean</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"date"</span>, Date<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"decimal"</span>, BigDecimal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"bigdecimal"</span>, BigDecimal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"biginteger"</span>, BigInteger<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"object"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"date[]"</span>, Date[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"decimal[]"</span>, BigDecimal[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"bigdecimal[]"</span>, BigDecimal[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"biginteger[]"</span>, BigInteger[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"object[]"</span>, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"map"</span>, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"hashmap"</span>, HashMap<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"list"</span>, List<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"arraylist"</span>, ArrayList<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"collection"</span>, Collection<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"iterator"</span>, Iterator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"ResultSet"</span>, ResultSet<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个加载通过别名加载 class 的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Class&lt;T&gt; <span class="title">resolveAlias</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (string == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String key = string.toLowerCase(Locale.ENGLISH); <span class="comment">// issue #748</span></span><br><span class="line">    Class&lt;T&gt; value;</span><br><span class="line">    <span class="keyword">if</span> (TYPE_ALIASES.containsKey(key)) &#123;</span><br><span class="line">      <span class="comment">//如果是别名，直接从注册表里返回</span></span><br><span class="line">      value = (Class&lt;T&gt;) TYPE_ALIASES.get(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      value = (Class&lt;T&gt;) Resources.classForName(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not resolve type alias '"</span> + string + <span class="string">"'.  Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加载-Mapper-配置文件"><a href="#加载-Mapper-配置文件" class="headerlink" title="加载 Mapper 配置文件"></a>加载 Mapper 配置文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">        String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">          <span class="comment">//由XMLMapperBuilder对象解析加载</span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          <span class="comment">//由XMLMapperBuilder对象解析加载</span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 Mapper 的配置文件最终会由 XMLMapperBuilder 对象解析加载到 Configuration 对象中。XMLMapperBuilder 的解析过程中 XMLConfigBuilder 解析过程差不多，以后再详细分析！</p><h4 id="加载其他配置项"><a href="#加载其他配置项" class="headerlink" title="加载其他配置项"></a>加载其他配置项</h4><p>还有一些配置项这里没有讲到，如：插件/拦截器、对象工厂、setting 项。这些的加载都比较简单，只要花点心里就可以看明白。在以后分析代码过程中，一定会看到这里配置，到时再进一步研究，不过可以肯定这里配置很多情况下都是使用默认的值。</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/69lahT" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/69lahT</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis3源码解析-前期准备</title>
      <link href="/mybatis3-source-code-preparation/"/>
      <url>/mybatis3-source-code-preparation/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们大多项目都使用了 Mybatis。Mybatis 的中的 sql 大多都是配置在 xml 文件中的，我们为了方便 dba 对 sql 统一的管理需要将 sql 保存在数据库中。这样就要求 Mybatis 从数据库中加载配置，同时 dba 优化 sql 之后还得实现让 Mybatis 在不重启应用的情况下动态加载。要实现这些功能，需要对 Mybatis 进行扩展，所以本人花了一些时间分析一 Mybatis3 源码，在此记录。</p><h3 id="分析计划"><a href="#分析计划" class="headerlink" title="分析计划"></a>分析计划</h3><p>主要分析如下三大内容:</p><ol><li>分析 Mybatis 是怎么解析配置文件</li><li>分析 Mybatis 是如何执行 Sql 并映射结果</li><li>分析 Mybatis 是如何使用缓存的</li></ol><h3 id="技术要求"><a href="#技术要求" class="headerlink" title="技术要求"></a>技术要求</h3><ol><li>core java。尤其是 jdbc 部分。</li><li>基本的 xml 知识。</li><li>以上都具备的话，还需要花点时间看看 Mybatis</li></ol><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>在 eclipse 中新建一个普通的 maven 工程，并加上 Mybatis 的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ashan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>电信行业最简单的三户模型：客户、用户、账户</p><ol><li>客户：即一个证件对应一个客户</li><li>用户：一个电话号码或宽带账号对应一个用户</li><li>账户：一个银行账户对应一个账户</li></ol><p>这里假定这个情形：你拿身份证去电信运营商里办了一个号码，并且提供了两个银行账户，每个月都可以使用这两个账号自动交话费。</p><h4 id="用户定义"><a href="#用户定义" class="headerlink" title="用户定义"></a>用户定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ashan.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户id，主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户号码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String svcnum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个用户只能对应一个客户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Cust cust;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个用户可以有多个账户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Acct&gt; accts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类型，两种：普通用户和重要用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UserType type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String id, String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cust <span class="title">getCust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cust;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust</span><span class="params">(Cust cust)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cust = cust;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Acct&gt; <span class="title">getAccts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccts</span><span class="params">(List&lt;Acct&gt; accts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accts = accts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserType <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(UserType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSvcnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> svcnum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSvcnum</span><span class="params">(String svcnum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.svcnum = svcnum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户定义-1"><a href="#用户定义-1" class="headerlink" title="用户定义"></a>用户定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ashan.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cust</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String custname;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 证件号码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String certNo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCustname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> custname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustname</span><span class="params">(String custname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.custname = custname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCertNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> certNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCertNo</span><span class="params">(String certNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.certNo = certNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="账户定义"><a href="#账户定义" class="headerlink" title="账户定义"></a>账户定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ashan.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Acct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String payName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 银行账号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String bankNo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> payName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPayName</span><span class="params">(String payName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.payName = payName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBankNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bankNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBankNo</span><span class="params">(String bankNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bankNo = bankNo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户类型"><a href="#用户类型" class="headerlink" title="用户类型"></a>用户类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ashan.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> UserType &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    GENERAL,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重要用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IMPORTANT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mybatis-配置"><a href="#Mybatis-配置" class="headerlink" title="Mybatis 配置"></a>Mybatis 配置</h3><h4 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">'-//mybatis.org//DTD Config 3.0//EN'</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">'http://mybatis.org/dtd/mybatis-3-config.dtd'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"UserMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="UserMapper-xml"><a href="#UserMapper-xml" class="headerlink" title="UserMapper.xml"></a>UserMapper.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">'-//mybatis.org//DTD Mapper 3.0//EN'</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">'http://mybatis.org/dtd/mybatis-3-mapper.dtd'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.ashan.user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"detailUserResultMap"</span> <span class="attr">type</span>=<span class="string">"com.ashan.mybatis.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">javaType</span>=<span class="string">"String"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">column</span>=<span class="string">"user_name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_pwd"</span> <span class="attr">property</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_type"</span> <span class="attr">javaType</span>=<span class="string">"com.ashan.mybatis.UserType"</span> <span class="attr">property</span>=<span class="string">"type"</span> <span class="attr">typeHandler</span>=<span class="string">"com.ashan.mybatis.UserTypeHandler"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"svc_num"</span> <span class="attr">property</span>=<span class="string">"svcnum"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">javaType</span>=<span class="string">"com.ashan.mybatis.Cust"</span> <span class="attr">property</span>=<span class="string">"cust"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"cust_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cust_name"</span> <span class="attr">property</span>=<span class="string">"custname"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cert_no"</span> <span class="attr">property</span>=<span class="string">"certNo"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">ofType</span>=<span class="string">"com.ashan.mybatis.Acct"</span> <span class="attr">property</span>=<span class="string">"accts"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"acct_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"pay_name"</span> <span class="attr">property</span>=<span class="string">"payName"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"bank_no"</span> <span class="attr">property</span>=<span class="string">"bankNo"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUserDetail"</span> <span class="attr">resultMap</span>=<span class="string">"detailUserResultMap"</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">                select user_id,user_name,user_type,cust_id from tf_f_user a where a.user_id=#&#123;userId&#125;</span><br><span class="line">            ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="跑跑试试看有没有问题"><a href="#跑跑试试看有没有问题" class="headerlink" title="跑跑试试看有没有问题"></a>跑跑试试看有没有问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ashan.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSesstionFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String resouce = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(resouce);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        System.out.println(sqlSessionFactory.getConfiguration());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行没有异常说明配置 OK!</p><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><p>搭建这个环境的作用是为了在分析代码过程中进行 Debuger，有些时候源代码很难明白，Debuger 一下能知道代码的走向，有时源代码看明白了，Debuger 一下也能帮助验证自己的理解是否有错。Debuger 对分析源码非常有用。</p><p>使用 Maven 构建这个工程除了方便 jar 导入之后，还有一个用处就是在 eclipse 中查看源代码非常方便。在 eclipse 使用 maven 工程，eclipse 会自动下载并关联源代码。</p><blockquote><p>作者：ashan_li<br>链接：<a href="http://suo.im/5xmz3s" target="_blank" rel="external nofollow noopener noreferrer">http://suo.im/5xmz3s</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis3源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis3源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC阻塞队列之LinkedBlockingDeque源码分析</title>
      <link href="/juc-linkedBlockingDeque/"/>
      <url>/juc-linkedBlockingDeque/</url>
      
        <content type="html"><![CDATA[<p>LinkedBlockingDeque从名称中我们可以得知，他是一个由链表结构组成的双向阻塞队列。  相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst。  </p><h3 id="LinkedBlockingDeque构造函数"><a href="#LinkedBlockingDeque构造函数" class="headerlink" title="LinkedBlockingDeque构造函数"></a>LinkedBlockingDeque构造函数</h3><p>LinkedBlockingDeque提供了3中构造函数，分别是默认构造函数，指定长度构造函数和指定集合的构造函数。其定义分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定长度构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 检查长度合法性</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定集合的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(Collection &lt; ? extends E &gt; c)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化容量大小</span></span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">// 加可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (E e: c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="comment">// 想队列尾部添加元素</span></span><br><span class="line">            <span class="keyword">if</span> (!linkLast(<span class="keyword">new</span> Node &lt; E &gt; (e)))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Deque full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入列操作"><a href="#入列操作" class="headerlink" title="入列操作"></a>入列操作</h3><p>LinkedBlockingDeque提供了好几个入列方法，不过其入列的实现基本相似，这里我们就以<code>putFirst</code>方法为例来说明LinkedBlockingDeque的入列操作。<code>putFirst</code>方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putFirst</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 元素不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 构建新节点</span></span><br><span class="line">    Node &lt; E &gt; node = <span class="keyword">new</span> Node &lt; E &gt; (e);</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将节点添加到队列头部，如果失败则等待在notFull条件上</span></span><br><span class="line">        <span class="keyword">while</span> (!linkFirst(node))</span><br><span class="line">            notFull.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">linkFirst</span><span class="params">(Node &lt; E &gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断队列是否已满</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 获取first节点</span></span><br><span class="line">    Node &lt; E &gt; f = first;</span><br><span class="line">    <span class="comment">// 将first节点赋值给node的next域</span></span><br><span class="line">    node.next = f;</span><br><span class="line">    <span class="comment">// 将node节点赋值给first</span></span><br><span class="line">    first = node;</span><br><span class="line">    <span class="comment">// 如果last==null,则将last也指向node</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        last = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果last不为null，则将原头结点的prev域设置为node</span></span><br><span class="line">        f.prev = node;</span><br><span class="line">    <span class="comment">// 节点自增</span></span><br><span class="line">    ++count;</span><br><span class="line">    <span class="comment">// 唤醒等待在notEmpty条件上的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出列操作"><a href="#出列操作" class="headerlink" title="出列操作"></a>出列操作</h3><p>同样我们也已<code>takeFirst</code>方法为例，来说明LinkedBlockingDeque的处理操作。其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">takeFirst</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="comment">// 如果x==null，则将线程等待在notEmpty条件上</span></span><br><span class="line">        <span class="keyword">while</span> ((x = unlinkFirst()) == <span class="keyword">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 否则返回x</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取头结点</span></span><br><span class="line">    Node &lt; E &gt; f = first;</span><br><span class="line">    <span class="comment">// 若头结点为null,则直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取头结点的下一个节点n</span></span><br><span class="line">    Node &lt; E &gt; n = f.next;</span><br><span class="line">    <span class="comment">// 获取头结点的值</span></span><br><span class="line">    E item = f.item;</span><br><span class="line">    <span class="comment">// 将头结的值设置为null</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将头结点的next设置为自身</span></span><br><span class="line">    f.next = f; </span><br><span class="line">    <span class="comment">// 将first 指向 n</span></span><br><span class="line">    first = n;</span><br><span class="line">    <span class="comment">// 如果n==null,则表示队列为空，则将last节点也设置为null</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则将头结点的前驱节点设置为null </span></span><br><span class="line">        n.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 队列中总数减一</span></span><br><span class="line">    --count;</span><br><span class="line">    <span class="comment">// 唤醒等待在notFull条件上的线程</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedBlockingDeque入列和出列的逻辑都比较简单，只要注意节点的指向就行。LinkedBlockingDeque底层结构如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BB%93%E6%9E%84.png"  alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>LinkedBlockingDeque 内部使用了可重入锁（线程安全），不像SynchronousQueue使用的循环cas，因此很简单，出队和入队使用的是同一个锁，但是两头都可以操作队列，相对于单端队列可以减少一半的竞争。LinkedBlockingDeque 同其他阻塞队列一样，不能存储null值元素。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> LinkedBlockingDeque </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC阻塞队列之LinkedTransferQueue源码分析</title>
      <link href="/juc-linkedTransferQueue/"/>
      <url>/juc-linkedTransferQueue/</url>
      
        <content type="html"><![CDATA[<p>LinkedTransferQueue从名称上我们就能判断出它是基于链表结构的，它是一个先进先出（FIFO）的阻塞无界队列。LinkedTransferQueue同样继承了AbstractQueue，并且实现了<code>TransferQueue</code>接口。LinkedTransferQueue 与普通的阻塞队列的区别是，当有消费者等待消费数据时，生产者可以将生产的数据直接交给消费者而不用进入队列中。下面我们就来看看LinkedTransferQueue 是如何实现的。</p><h3 id="构造函数和节点实现"><a href="#构造函数和节点实现" class="headerlink" title="构造函数和节点实现"></a>构造函数和节点实现</h3><p>LinkedTransferQueue的构造函数有2中，分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化一个空的队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedTransferQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*通过制定集合C来构建队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedTransferQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>addAll(c)</code>是<code>AbstractQueue</code>中提供的方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查判断参数是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//检查判断参数是否为自身</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//遍历集合并调用add方法添加元素</span></span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (add(e))</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用LinkedTransferQueue实现的offer方法</span></span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码中我们可以看到，通过给定制定的集合来初始化LinkedTransferQueue最终的核心是调用LinkedTransferQueue的<code>offer</code>方法。此方法我们后面再详细说明。</p><p>既然LinkedTransferQueue是基于链表来实现了，那我们就先来看看其 阻塞队列的节点Node是如何设计如的，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如为true,说明是一个数据节点，否则为一个请求节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isData;</span><br><span class="line">    <span class="comment">//数据域 </span></span><br><span class="line">    <span class="keyword">volatile</span> Object item; </span><br><span class="line">    <span class="comment">//下一个指向的节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//当请求节点线程进入等待前，赋予该节点值</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CAS设置next的值</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node cmp, Node val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CAS设置item的值</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(Object cmp, Object val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert cmp == null || cmp.getClass() != Node.class;</span></span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造Node节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Object item, <span class="keyword">boolean</span> isData) &#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item); <span class="comment">// relaxed write</span></span><br><span class="line">        <span class="keyword">this</span>.isData = isData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将next指向自身，表明节点被删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forgetNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, nextOffset, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置item的值为自身</span></span><br><span class="line"><span class="comment">     * 设置waiter的值为空</span></span><br><span class="line"><span class="comment">     * 在节点被匹配过或者清除时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forgetContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, <span class="keyword">this</span>);</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, waiterOffset, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查节点是否被匹配过了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isMatched</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object x = item;</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="keyword">this</span>) || ((x == <span class="keyword">null</span>) == isData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是一个未匹配的请求节点</span></span><br><span class="line"><span class="comment">     * 如果是的话isData应为false，item == null，因位如果匹配了，item则会有值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isUnmatchedRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !isData &amp;&amp; item == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果给定的节点不能挂在当前节点后返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cannotPrecede</span><span class="params">(<span class="keyword">boolean</span> haveData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> d = isData;</span><br><span class="line">        Object x;</span><br><span class="line">        <span class="keyword">return</span> d != haveData &amp;&amp; (x = item) != <span class="keyword">this</span> &amp;&amp; (x != <span class="keyword">null</span>) == d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试匹配一个数据节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryMatchData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isData;</span></span><br><span class="line">        Object x = item;</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp; x != <span class="keyword">this</span> &amp;&amp; casItem(x, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            LockSupport.unpark(waiter);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3375979862319811754</span> L;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waiterOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class &lt; ? &gt; k = Node<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            itemOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">"item"</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">            waiterOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">"waiter"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Node结点，有以下几点需要特别注意：</p><ol><li>Node结点有两种类型：数据结点、请求结点，通过字段<code>isData</code>区分，只有不同类型的结点才能相互匹配；</li><li>Node结点的值保存在<code>item</code>字段，匹配前后值会发生变化；</li></ol><h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><p>LinkedTransferQueue的put操作提供了put、offer和add方法。它们的目的都是向队列中添加一个元素，我们来看看他们的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向队列尾部添加一个元素</span></span><br><span class="line"><span class="comment"> * 因为队列是无界的，所以该方法永远不会阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    xfer(e, <span class="keyword">true</span>, ASYNC, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向队列尾部添加一个元素</span></span><br><span class="line"><span class="comment"> * 因为队列是无界的，所以该方法永远不会返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    xfer(e, <span class="keyword">true</span>, ASYNC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向队列尾部添加一个元素</span></span><br><span class="line"><span class="comment"> * 因为队列是无界的，所以该方法永远不会返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    xfer(e, <span class="keyword">true</span>, ASYNC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向队列尾部添加一个元素</span></span><br><span class="line"><span class="comment"> *因为队列是无界的，所以该方法永远不会返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    xfer(e, <span class="keyword">true</span>, ASYNC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码中，我们可以发现，put操作的所有方法都是凋用<code>xfer</code>这个方法，并且传入的参数都是一样的。<code>xfer</code>方法在介绍完take操作后，我们在介绍。</p><h3 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h3><p>LinkedTransferQueue的take操作提供了take和poll两中方法，它们的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = xfer(<span class="keyword">null</span>, <span class="keyword">false</span>, SYNC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = xfer(<span class="keyword">null</span>, <span class="keyword">false</span>, TIMED, unit.toNanos(timeout));</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> xfer(<span class="keyword">null</span>, <span class="keyword">false</span>, NOW, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从LinkedTransferQueue的put操作和take操作我们可以总结出如下2点：</p><ol><li><p>这些函数读取/插入数据实际调用的都是xfer这一个函数来完成的。</p></li><li><p>这些函数中传入了4个重要的常量，来区分每个方法的调用。这4个常量分别是NOW、ASYNC 、SYNC 和 TIMED ，它们的值分别为0、1、2、3。这4个常量代表意义如下：</p><ol><li><p><strong>NOW表示即时操作（可能失败），即不会阻塞调用线程：</strong> </p><p>  poll（获取并移除队首元素，如果队列为空，直接返回null）；tryTransfer（尝试将元素传递给消费者，如果没有等待的消费者，则立即返回false，也不会将元素入队） </p></li><li><p><strong>ASYNC表示异步操作（必然成功）：</strong> </p><p> offer（插入指定元素至队尾，由于是无界队列，所以会立即返回true）；put（插入指定元素至队尾，由于是无界队列，所以会立即返回）；add（插入指定元素至队尾，由于是无界队列，所以会立即返回true） </p></li><li><p><strong>SYNC表示同步操作（阻塞调用线程）：</strong> </p><p> transfer（阻塞直到出现一个消费者线程）；take（从队首移除一个元素，如果队列为空，则阻塞线程） </p></li><li><p><strong>TIMED表示限时同步操作（限时阻塞调用线程）：</strong> </p><p> poll(long timeout, TimeUnit unit)；tryTransfer(E e, long timeout, TimeUnit unit) </p></li></ol><h3 id="xfer函数"><a href="#xfer函数" class="headerlink" title="xfer函数"></a>xfer函数</h3></li></ol><p>xfer作为LinkedTransferQueue里面最核心的函数, 在读取数据都依赖它, 接下来将看具体的实现。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e put操作的元素，当时take操作时e为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> haveData put操作为true，take操作为false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> how NOW, ASYNC, SYNC, or TIMED</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 超时时间，仅TIMED模式有效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if haveData mode but e is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">xfer</span><span class="params">(E e, <span class="keyword">boolean</span> haveData, <span class="keyword">int</span> how, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查数据合法性</span></span><br><span class="line">    <span class="keyword">if</span> (haveData &amp;&amp; (e == <span class="keyword">null</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//新建待插入的节点S</span></span><br><span class="line">    Node s = <span class="keyword">null</span>; </span><br><span class="line">    retry:</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">            <span class="comment">//从头结点开始变量，知道匹配到节点</span></span><br><span class="line">            <span class="keyword">for</span> (Node h = head, p = h; p != <span class="keyword">null</span>;) &#123; </span><br><span class="line">                <span class="comment">// 获取p结点的类型，true为put操作，false为take操作</span></span><br><span class="line">                <span class="keyword">boolean</span> isData = p.isData;</span><br><span class="line">                <span class="comment">// 获取p结点的值</span></span><br><span class="line">                Object item = p.item;</span><br><span class="line">                <span class="comment">// p结点存在并且未被匹配</span></span><br><span class="line">                <span class="comment">// item != p 表示节点未被删除</span></span><br><span class="line">                <span class="comment">// (item != null) == isData 表示节点未被匹配</span></span><br><span class="line">                <span class="keyword">if</span> (item != p &amp;&amp; (item != <span class="keyword">null</span>) == isData) &#123; </span><br><span class="line">                    <span class="comment">//如果头结点和代匹配的节点类型一致，则直接返回不进行匹配操作</span></span><br><span class="line">                    <span class="keyword">if</span> (isData == haveData) </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                     <span class="comment">// 开始匹配操作</span></span><br><span class="line">                     <span class="comment">// CAS方式将p节点的item的值设置为e</span></span><br><span class="line">                    <span class="keyword">if</span> (p.casItem(item, e)) &#123;</span><br><span class="line">                        <span class="comment">//对于for循环，启动条件只要匹配节点不是head节点就会尝试将head节点cas为本匹配节点的next节点或者本匹配节点当匹配节点没有next节点时</span></span><br><span class="line">                        <span class="keyword">for</span> (Node q = p; q != h;) &#123;</span><br><span class="line">                            Node n = q.next; <span class="comment">// update by 2 unless singleton</span></span><br><span class="line">                            <span class="keyword">if</span> (head == h &amp;&amp; casHead(h, n == <span class="keyword">null</span> ? q : n)) &#123;</span><br><span class="line">                                <span class="comment">//cas head节点成功，则将之前的节点的next指针指向节点自身。这意味着节点脱离了队伍。同时，这也可以帮助gc。因为指向自身后，节点的不可达状态判断会更容易些。</span></span><br><span class="line">                                <span class="comment">//当节点的next指针指向自身，意味着该节点已经脱离队伍，是一个无效节点。这个是一个判断的充分条件。</span></span><br><span class="line">                                h.forgetNext();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                             <span class="comment">//cas 失败后则检查当前head指针距离下一个有效节点是否大于2.大于则再次循环，否则退出。头节点的松弛长度由这段代码决定。从代码上可以看出，松弛距离是2.</span></span><br><span class="line">                            <span class="keyword">if</span> ((h = head) == <span class="keyword">null</span> ||</span><br><span class="line">                                (q = h.next) == <span class="keyword">null</span> || !q.isMatched())</span><br><span class="line">                                <span class="keyword">break</span>; <span class="comment">// unless slack &lt; 2</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        LockSupport.unpark(p.waiter);</span><br><span class="line">                        <span class="keyword">return</span> LinkedTransferQueue. &lt; E &gt; cast(item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果没有找到匹配节点就尝试下一个节点。如果该节点已经脱离队列，则从头开始。</span></span><br><span class="line">                Node n = p.next;</span><br><span class="line">                p = (p != n) ? n : (h = head); <span class="comment">// Use head if p offlist</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有找到匹配节点的情况下，并且不是无阻塞提取的操作的话，就构建一个节点，将自身节点放入队尾</span></span><br><span class="line">            <span class="keyword">if</span> (how != NOW) &#123; </span><br><span class="line">                <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                    s = <span class="keyword">new</span> Node(e, haveData);</span><br><span class="line">                 <span class="comment">//尝试将节点放入队尾。该方式是存在失败可能。此时需要重新开始完整流程。而s不需要初始化两次。保存作为临时变量即可。</span></span><br><span class="line">                Node pred = tryAppend(s, haveData);</span><br><span class="line">                <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">continue</span> retry; <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">                <span class="keyword">if</span> (how != ASYNC)</span><br><span class="line">                    <span class="comment">//只有SYNC或者TINED情况, 线程才会被阻塞。只有部分接口才会阻塞线程</span></span><br><span class="line">                    <span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e; <span class="comment">// not waiting</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xfer方法主要逻辑如下：</p><ul><li>检查传入的参数e和haveData是否匹配</li><li>从队列的头结点开始向后遍历，查找到第一个未匹配的节点。</li><li>如果第一个未匹配的节点与本次请求模式一致，并且本次请求不是无阻塞的请求，则将本次请求加入到阻塞队列中(tryAppend)。</li><li>如果第一个未匹配的节点与本次请求模式不一致，则开始匹配：<ul><li>如果匹配成功，并且匹配的节点不是头结点，则重新定位头结点并将原来的头结点删除，然后唤醒匹配节点等待的线程并返回。</li><li>如果匹配失败，则尝试匹配下一个节点。</li></ul></li></ul><p>下面我们来看看将节点添加到队列尾部的tryAppend方法，该方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将节点添加到队列尾部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 待添加的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> haveData 节点的模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果添加失败则返回null,否则返回s的前驱节点，如果s没有前驱节点，则返回s本身</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">tryAppend</span><span class="params">(Node s, <span class="keyword">boolean</span> haveData)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从队列尾部遍历</span></span><br><span class="line">    <span class="keyword">for</span> (Node t = tail, p = t;;) &#123; </span><br><span class="line">        Node n, u; </span><br><span class="line">        <span class="comment">//如果队列未初始化，则将s作为head节点，并返回自身</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; (p = head) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casHead(<span class="keyword">null</span>, s))</span><br><span class="line">                <span class="keyword">return</span> s; </span><br><span class="line">        <span class="comment">//如果队尾节点的模式和s节点的模式不一致，则返回true    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.cannotPrecede(haveData))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果p节点不是队尾节点，则重新定位队尾节点    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((n = p.next) != <span class="keyword">null</span>) </span><br><span class="line">            p = p != t &amp;&amp; t != (u = tail) ? (t = u) :</span><br><span class="line">            (p != n) ? n : <span class="keyword">null</span>; <span class="comment">// restart if off list</span></span><br><span class="line">        <span class="comment">// CAS 将s节点添加到p节点后面，如果失败则将p.next 赋值给p    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p.casNext(<span class="keyword">null</span>, s))</span><br><span class="line">            p = p.next; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//开始检查p与tail的松弛距离, 如果tail距离最终节点距离&gt;2, 则tail继续向后移动。</span></span><br><span class="line">            <span class="keyword">if</span> (p != t) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((tail != t || !casTail(t, s)) &amp;&amp;</span><br><span class="line">                    (t = tail) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (s = t.next) != <span class="keyword">null</span> &amp;&amp; <span class="comment">// advance and retry</span></span><br><span class="line">                    (s = s.next) != <span class="keyword">null</span> &amp;&amp; s != t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAppend方法的目的就是将s节点添加到队列的尾部，如果成功则返回其前驱节点(没有前驱节点则返回自身)。如果失败则返回null。 在方法返回成功后，如果how还不是ASYNC则调用awaitMatch()方法阻塞等待： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">awaitMatch</span><span class="params">(Node s, Node pred, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算超时结束时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0</span> L;</span><br><span class="line">    <span class="comment">//当前线程</span></span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> spins = -<span class="number">1</span>; </span><br><span class="line">    ThreadLocalRandom randomYields = <span class="keyword">null</span>; <span class="comment">// bound if needed</span></span><br><span class="line">    <span class="comment">//开始死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取s节点的值</span></span><br><span class="line">        Object item = s.item;</span><br><span class="line">        <span class="comment">// 节点已经被匹配</span></span><br><span class="line">        <span class="keyword">if</span> (item != e) &#123; </span><br><span class="line">            <span class="comment">// 撤销节点</span></span><br><span class="line">            s.forgetContents(); </span><br><span class="line">            <span class="keyword">return</span> LinkedTransferQueue. &lt; E &gt; cast(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程中断或者超时了。则调用将s节点item设置为e，等待取消</span></span><br><span class="line">        <span class="keyword">if</span> ((w.isInterrupted() || (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)) &amp;&amp; s.casItem(e, s)) &#123; </span><br><span class="line">            <span class="comment">//断开节点</span></span><br><span class="line">            unsplice(pred, s);</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">if</span> (spins &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算自旋次数</span></span><br><span class="line">            <span class="keyword">if</span> ((spins = spinsFor(pred, s.isData)) &gt; <span class="number">0</span>)</span><br><span class="line">                randomYields = ThreadLocalRandom.current();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123; <span class="comment">// spin</span></span><br><span class="line">            --spins;</span><br><span class="line">            <span class="comment">//随机数==0，让出线程  没看明白</span></span><br><span class="line">            <span class="keyword">if</span> (randomYields.nextInt(CHAINED_SPINS) == <span class="number">0</span>)</span><br><span class="line">                Thread.yield(); </span><br><span class="line">        <span class="comment">// 将当前线程设置到节点的waiter域</span></span><br><span class="line">        <span class="comment">// 一开始s.waiter == null 肯定是会成立的，    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.waiter = w; </span><br><span class="line">        <span class="comment">//超时阻塞    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &gt; <span class="number">0</span> L)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个awaitMatch方法的逻辑大体不难理解，但是<code>Thread.yield();</code>让出线程执行时间这个实在是没看明白。在awaitMatch执行过程中，如果线程被中断，或者超时则会调用<code>unsplice(pred, s);</code>将该节点移除。改方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unsplice</span><span class="params">(Node pred, Node s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将item设置为自身节点，清空waiter数据。</span></span><br><span class="line">    s.forgetContents(); </span><br><span class="line">    <span class="comment">//if判断确认pred节点确实存在并且仍然是s的前置节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span> &amp;&amp; pred != s &amp;&amp; pred.next == s) &#123;</span><br><span class="line">        Node n = s.next;</span><br><span class="line">        <span class="comment">//一般情况下就只是将前置节点的next设置为本节点的后置节点。让遍历路径中去掉该取消节点即可。</span></span><br><span class="line">        <span class="comment">//而如果发现该取消节点是最后一个节点或者前置节点已经无效了，就需要做进一步的清理动作。</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span> || (n != s &amp;&amp; pred.casNext(s, n) &amp;&amp; pred.isMatched())) &#123;</span><br><span class="line">            <span class="comment">//首先是帮忙清理头结点，如果头节点已经失效的话</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">                Node h = head;</span><br><span class="line">                <span class="keyword">if</span> (h == pred || h == s || h == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// at head or list empty</span></span><br><span class="line">                <span class="keyword">if</span> (!h.isMatched())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                Node hn = h.next;</span><br><span class="line">                <span class="keyword">if</span> (hn == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// now empty</span></span><br><span class="line">                <span class="keyword">if</span> (hn != h &amp;&amp; casHead(h, hn))</span><br><span class="line">                    h.forgetNext(); <span class="comment">// advance head</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果前置节点和本身节点都在队列中，与上面的条件结合，此时这两个节点都是无效节点。此时就对sweepVotes（清除投票计数）原子增。如果一个线程发现其触发了阀值。则执行全队列清除动作。</span></span><br><span class="line">            <span class="keyword">if</span> (pred.next != pred &amp;&amp; s.next != s) &#123; <span class="comment">// recheck if offlist</span></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123; <span class="comment">// sweep now if enough votes</span></span><br><span class="line">                    <span class="keyword">int</span> v = sweepVotes;</span><br><span class="line">                    <span class="keyword">if</span> (v &lt; SWEEP_THRESHOLD) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (casSweepVotes(v, v + <span class="number">1</span>))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casSweepVotes(v, <span class="number">0</span>)) &#123;</span><br><span class="line">                        sweep();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里主体流程已经结束。最后总结如下：</p><ul><li>LinkedTransferQueue的put操作和take操作都是通过调用<code>E xfer(E e, boolean haveData, int how, long nanos)</code>方法来完成的，只是操作中每个方法传入的how不同。</li><li>如果新节点的模式和队列中头结点的模式不一样，则直接进行匹配操作，新节点不加入到队列中。</li><li>如果新节点的模式和队列中头结点的模式一致，则将新节点添加到队列尾部。</li><li>若节点添加成功，且how != ASYNC， 则调用awaitMatch()方法阻塞等待， 在阻塞等待的过程中，如果线程超时或者被中断，则将节点从队列中移除。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> LinkedTransferQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC阻塞队列之SynchronousQueue-非公平模式源码分析</title>
      <link href="/juc-synchronousQueue-nofair/"/>
      <url>/juc-synchronousQueue-nofair/</url>
      
        <content type="html"><![CDATA[<p>上一章LZ分析了<a href="https://www.zzwzdx.cn/juc-synchronousQueue-fair/">SynchronousQueue的公平模式</a>，这一章将分析SynchronousQueue的非公平模式的数据交换。SynchronousQueue的非公平模式的实现策略是基于TransferStack类的。TransferStack类中的三种状态非常重要，分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 节点代表未实现的消费者 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** 节点代表未完成的生产者 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** 节点正在执行另一个未完成的数据或请求 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>其中REQUEST代表的数据请求的操作也就是take操作，而DATA表示的是数据也就是Put操作将数据存放到栈中，用于消费者进行获取操作，而FULFILLING代表的是可以进行互补操作的状态，其实和前面讲的公平模式也很类似。</p><p>下面我们来看看非公平模式的<code>put</code>和<code>take</code>操作。其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码中我们可以看到<code>put</code>和<code>take</code>操作都是调用<code>TransferStack</code>类中的<code>transfer</code>方法，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    SNode s = <span class="keyword">null</span>; </span><br><span class="line">    <span class="comment">//判断mode</span></span><br><span class="line">    <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        SNode h = head;</span><br><span class="line">        <span class="comment">//栈顶指针为空或者是模式相同，则进入if语句</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123; </span><br><span class="line">            <span class="comment">// 指定了timed并且时间小于等于0则取消操作。</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="comment">//栈顶指针不为空，且节点的删除标志位true，则执行casHead操作</span></span><br><span class="line">                <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                    <span class="comment">// 弹出删除的节点</span></span><br><span class="line">                    casHead(h, h.next); </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//初始化节点并尝试修改栈顶指针    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                <span class="comment">//如果返回的节点和自身相等，表示节点被清除</span></span><br><span class="line">                <span class="keyword">if</span> (m == s) &#123; </span><br><span class="line">                    clean(s);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                    casHead(h, s.next); </span><br><span class="line">                <span class="keyword">return</span> (E)((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 判断栈顶节点mode不是FULFILLING</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; </span><br><span class="line">            <span class="comment">//如果栈顶指针的删除标识为true，则删除栈顶指针并重定义head节点</span></span><br><span class="line">            <span class="keyword">if</span> (h.isCancelled()) </span><br><span class="line">                casHead(h, h.next); </span><br><span class="line">            <span class="comment">//新建一个Full节点压入栈顶</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, FULFILLING | mode))) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123; <span class="comment">// 循环直到匹配</span></span><br><span class="line">                     <span class="comment">// s的下一个节点</span></span><br><span class="line">                    SNode m = s.next;</span><br><span class="line">                    <span class="comment">//m==null，表示没有等待的内容</span></span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123; </span><br><span class="line">                        casHead(s, <span class="keyword">null</span>); <span class="comment">// 弹出full节点</span></span><br><span class="line">                        s = <span class="keyword">null</span>; </span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 退到主循环中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    SNode mn = m.next;</span><br><span class="line">                    <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                        casHead(s, mn); <span class="comment">// 弹出s和m节点</span></span><br><span class="line">                        <span class="keyword">return</span> (E)((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="comment">// 没有匹配到</span></span><br><span class="line">                        s.casNext(m, mn); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果栈顶节点的mode是FULFILLING，则表示有线程正在匹配，则先帮助匹配在循环    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SNode m = h.next; </span><br><span class="line">            <span class="keyword">if</span> (m == <span class="keyword">null</span>) </span><br><span class="line">                casHead(h, <span class="keyword">null</span>); </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                SNode mn = m.next;</span><br><span class="line">                <span class="keyword">if</span> (m.tryMatch(h)) </span><br><span class="line">                    casHead(h, mn); </span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    h.casNext(m, mn); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>transfer</code>方法的主要逻辑如下：</p><ol><li>如果栈顶节点是否为空，或者栈顶节点的mode和新节点的mode一直，则压栈等待匹配，</li><li>如果栈顶节点不为空，且栈顶节点的mode和新节点的mode不一致，则判断栈顶节点的mode是否是<code>FULFILLING</code>，如果不是，则进行匹配操作。如果是，则表示已有线程正在进行匹配操作，先帮助线程完成匹配操作，在开始循环。</li></ol><p>为了更好的理解上面源码，我们用示图例来详细解释上面源码逻辑。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronousQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中我们先做了一次<code>put</code>操作，然后睡眠50秒后，执行了一次<code>take</code>操作。在执行<code>put</code>操作时，会掉用<code>transfer</code>方法，进入<code>transfer</code>后计算mode的值，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line"><span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br></pre></td></tr></table></figure><p>通过上面代码，我们可以知道<code>e=1!=null</code>，所以mode是<code>DATA</code>类型，接下来会对栈顶节点和mode进行判断，执行如下if语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SNode h = head;</span><br><span class="line"><span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode)</span><br></pre></td></tr></table></figure><p>此时栈顶节点h == null，因此会进入当前的if语句，执行内部逻辑，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can't wait</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">        casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">    SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">    <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">        clean(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">        casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line">    <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中为判断timed和nanos, 如果指定了timed并且nanos小于0，则判断栈顶节点不为null并且栈顶节点已经删除，则弹出栈顶节点重新定义栈顶节点，否则返回null。上述条件在当前例子中都不满足，所以要进入到下面这段代码中，首先进行对s进行初始化值，并且进行入栈操作，<code>casHead(h, s = snode(s, e, h, mode))</code>，下面看一下栈中的情况如下图所示：<br><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/put_2_1.png"  alt></p><p>当执行完入栈操作后，接下来会执行<code>awaitFulfill</code>操作，我们先来看看该方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果指定了timed，则计算线程睡眠终止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">//当前线程</span></span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="comment">//自旋次数</span></span><br><span class="line">    <span class="keyword">int</span> spins = (shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//如果线程中断，则清除节点</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            <span class="comment">//清除节点</span></span><br><span class="line">            s.tryCancel();</span><br><span class="line">        <span class="comment">//s节点的匹配节点</span></span><br><span class="line">        SNode m = s.match;</span><br><span class="line">        <span class="comment">//如果匹配节点存在，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="comment">// 如果指定了timed=true,则重新计算线程睡眠时间</span></span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">//超时，清理节点</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                s.tryCancel();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算自旋次数</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">            s.waiter = w; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>); <span class="comment">//阻塞线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>awaitFulfill</code>方法的逻辑比较清晰，首先判断线程是否中断，如果中断则将节点清除。然后判断节点是否已经匹配，如果已经匹配，则返回匹配的节点，否则判断节点是否需要自旋，判断的方法为<code>shouldSpin(s)</code>,如果需要自旋，则先自旋，如果不需要自旋或者在自旋次数完毕后，节点还没有被匹配或者中断，则阻塞当前线程。判断是否需要自旋源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldSpin</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//栈顶指针</span></span><br><span class="line">    SNode h = head;</span><br><span class="line">    <span class="comment">//如果带匹配的节点就是栈顶节点 或者 栈顶节点为null  或者站点节点的mode是FULFILLING，则需要自旋</span></span><br><span class="line">    <span class="keyword">return</span> (h == s || h == <span class="keyword">null</span> || isFulfilling(h.mode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到我们的示例中，在执行完<code>awaitFulfill</code>方法后，栈中的情况如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/put2_2.png"  alt></p><p>在示例中，主线程在Thread_1启动后，睡眠了50秒，因此此时Thread_1线程将进入阻塞状态，即调用<code>queue.put(1);</code>方法的线程进入阻塞状态，在过了50秒后，Thread_2线程(即调用<code>queue.take()</code>方法的线程)启动，该线程将调用<code>E e = transferer.transfer(null, false, 0)</code>,进入<code>transfer</code>方法后，任然会新进行mode值的计算，会执行下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line"><span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br></pre></td></tr></table></figure><p>此时根据示例我们知道e=null，因此mode=REQUEST。继续往下执行，会进入第二个if语句，即执行下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// 条件二</span></span><br><span class="line">    <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">        casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">            SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line">            <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">            &#125;</span><br><span class="line">            SNode mn = m.next;</span><br><span class="line">            <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">            &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入if语句后，首先判断栈顶节点是否被清除，很明显此时栈顶节点没有被删除，因此执行<code>casHead(h, s=snode(s, e, h, FULFILLING|mode))</code>,在执行该语句后，栈中的情况如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/take_2_1.png"  alt></p><p>继续往后面执行代码，执行完<code>SNode m = s.next;</code>后，从上图中知道，m=Reference-1!=null,继续执行后面代码<code>SNode mn = m.next</code>,此时mn=null,然后执行<code>m.tryMatch(s)</code>,如果成功，则表示匹配成功，将s节点和m节点从栈中弹出，然后返回。如果匹配不成功，则更新s节点的next,重新循环。在上面执行的代码中核心方法就是<code>tryMatch</code>方法，我们来看看该方法的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryMatch</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (match == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, matchOffset, <span class="keyword">null</span>, s)) &#123;</span><br><span class="line">        Thread w = waiter;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123;    <span class="comment">// waiters need at most one unpark</span></span><br><span class="line">            waiter = <span class="keyword">null</span>;</span><br><span class="line">            LockSupport.unpark(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match == s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryMatch方法逻辑比较简单，利用CAS更新m节点的match字段为s节点，如果更新成功，则唤醒m节点中的额waiter线程。到此SynchronousQueue的给公平模式就分析完成了，但是细心的朋友会发现，最后面还有一个帮助fulfill的操作，（transfer中）代码如下所示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SNode m = h.next;               <span class="comment">// m is h's match</span></span><br><span class="line"><span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">    casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    SNode mn = m.next;</span><br><span class="line">    <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">        casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">    <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">        h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的分析图中，我们可以得知在take操作时，栈顶节点的mode=FULFILLING,我们设想下当一个线程正在做take操作时，另一个线程B也来进行take操作，这样线程会运行上面的fulfill操作代码块。此时线程B会先帮助上一个take操作的线程完成，然后在进行自己的操作。</p><p> 最后我们来看看clean方法，消的clean方法内容: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">    s.item = <span class="keyword">null</span>;   <span class="comment">// 将item值设置为null</span></span><br><span class="line">    s.waiter = <span class="keyword">null</span>; <span class="comment">// 将线程设置为null</span></span><br><span class="line">    SNode past = s.next; <span class="comment">// s节点下一个节点如果不为空，并且节点是取消节点则指向下下个节点，这里是结束的标识，代表没有了。</span></span><br><span class="line">    <span class="keyword">if</span> (past != <span class="keyword">null</span> &amp;&amp; past.isCancelled())</span><br><span class="line">        past = past.next;</span><br><span class="line">    <span class="comment">// 如果取消的是头节点则运行下面的清理操作，操作逻辑很简单就是判断头结点是不是取消节点，如果是则将节点一定到下一个节点</span></span><br><span class="line">    SNode p;</span><br><span class="line">    <span class="keyword">while</span> ((p = head) != <span class="keyword">null</span> &amp;&amp; p != past &amp;&amp; p.isCancelled())</span><br><span class="line">        casHead(p, p.next);</span><br><span class="line">    <span class="comment">// 取消不是头结点的嵌套节点。</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p != past) &#123;</span><br><span class="line">        SNode n = p.next;</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="keyword">null</span> &amp;&amp; n.isCancelled())</span><br><span class="line">            p.casNext(n, n.next);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 通过源码可以看到首先是先找到一个可以结束的标识past，也就说到这里就结束了，判断是否不是头节点被取消了，如果是头节点被取消了则进行第一个while语句，操作也很简单就是将头节点替换头结点的下一个节点，之后进行下面的while语句操作，其实就是将取消的上一个节点的下一个节点指定为被取消节点的下一个节点，到此分析完毕了。 </p><p>如果有分析不正确的地方，请给位指正。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> SynchronousQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC阻塞队列之SynchronousQueue公平模式源码分析</title>
      <link href="/juc-synchronousQueue-fair/"/>
      <url>/juc-synchronousQueue-fair/</url>
      
        <content type="html"><![CDATA[<p>synchronousQueue是一个不存储元素的阻塞队列。每个put操作必须等待一个take操作，否则不能继续向队列中添加元素。synchronousQueue同样支持公平和非公平性，在默认情况下线程采用非公平性策略进行访问。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>SynchronousQueue提供了2种构造方式，一种是默认的非公平性，一种是可选择公平和非公平性的构造方式，构造函数源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue &lt; E &gt; () : <span class="keyword">new</span> TransferStack &lt; E &gt; ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码中，我们可以看到，当SynchronousQueue非公平时，使用的是TransferStack这个类来构造的，否则使用的是TransferQueue这个类进行构造，下面我们看看这2个类的实现。</p><h4 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h4><p>TransferQueue是SynchronousQueue实现公平策略的核心类，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferQueue</span> &lt; <span class="title">E</span> &gt; <span class="keyword">extends</span> <span class="title">Transferer</span> &lt; <span class="title">E</span> &gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** 队列头结点 */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line">    <span class="comment">/** 队列尾节点 */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br><span class="line">    <span class="comment">// 指向一个取消的结点</span></span><br><span class="line">    <span class="comment">//当一个节点中最后一个插入时，它被取消了但是可能还没有离开队列</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode cleanMe;</span><br><span class="line"></span><br><span class="line">    TransferQueue() &#123;</span><br><span class="line">    <span class="comment">//初始化一个空节点</span></span><br><span class="line">        QNode h = <span class="keyword">new</span> QNode(<span class="keyword">null</span>, <span class="keyword">false</span>); </span><br><span class="line">        <span class="comment">//将队列的头结点和尾节点都指向这个空节点</span></span><br><span class="line">        head = h;</span><br><span class="line">        tail = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略部分代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述TransferQueue的定义中我们可以看出，在TransferQueue中除了头、尾节点外还存在一个cleanMe节点。该节点主要用于标记，当删除的节点是尾节点时则需要使用该节点。 同时，对于TransferQueue需要注意的是，其队列永远都存在一个dummy node(虚拟节点)。在构造创建完TransferQueue后，其头结点和尾节点都指向了一个虚拟节点。而且在TransferQueue中节点的类型是<code>QNode</code>类型，它是TransferQueue的一个静态内部类，其源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向队列中的下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> QNode next;</span><br><span class="line">    <span class="comment">// 数据项 </span></span><br><span class="line">    <span class="keyword">volatile</span> Object item;</span><br><span class="line">    <span class="comment">//等待线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="comment">//模式，表示当前是数据还是请求，只有当匹配的模式相匹配时才会交换</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isData;</span><br><span class="line"></span><br><span class="line">    QNode(Object item, <span class="keyword">boolean</span> isData) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">        <span class="keyword">this</span>.isData = isData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS设置next域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(QNode cmp, QNode val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next == cmp &amp;&amp;</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS 设置item域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(Object cmp, Object val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item == cmp &amp;&amp;</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试通过CAS将此项目引用取消，将item域设置为自身</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tryCancel</span><span class="params">(Object cmp)</span> </span>&#123;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断节点是否被缺陷</span></span><br><span class="line"><span class="comment">     * 与tryCancel相照应只需要判断item释放等于自身即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item == <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isOffList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next == <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class &lt; ? &gt; k = QNode<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            itemOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">"item"</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码逻辑非常清晰，唯一需要注意的一点就是isData，该属性在进行数据交换起到关键性作用，两个线程进行数据交换的时候，必须要两者的模式保持一致,否则不能进行数据交换。</p><h4 id="TransferStack"><a href="#TransferStack" class="headerlink" title="TransferStack"></a>TransferStack</h4><p>TransferStack是SynchronousQueue实现非公平策略的关键类，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span> &lt; <span class="title">E</span> &gt; <span class="keyword">extends</span> <span class="title">Transferer</span> &lt; <span class="title">E</span> &gt; </span>&#123;</span><br><span class="line">    <span class="comment">/* Modes for SNodes, ORed together in node fields */</span></span><br><span class="line">    <span class="comment">/** 节点代表未实现的消费者 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 节点代表未完成的生产者 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** 节点正在执行另一个未完成的数据或请求 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  如果m设置了满足位，则返回true。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFulfilling</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> (m &amp; FULFILLING) != <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 栈的头部 */</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略部分代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransferStack中定义了三个状态：REQUEST表示消费数据的消费者，DATA表示生产数据的生产者，FULFILLING，表示匹配另一个生产者或消费者。任何线程对TransferStack的操作都属于上述3种状态中的一种（对应着SNode节点的mode）。同时还包含一个head域，表示头结点。 内部节点SNode定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next 节点</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode next;</span><br><span class="line">    <span class="comment">// 相匹配的节点</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode match;</span><br><span class="line">    <span class="comment">// 等待的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="comment">// item 域</span></span><br><span class="line">    Object item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式</span></span><br><span class="line">    <span class="keyword">int</span> mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * item域和mode域不需要使用volatile修饰，因为它们在volatile/atomic操作之前写，之后读</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SNode(Object item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(SNode cmp, SNode val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cmp == next &amp;&amp;</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将s结点与本结点进行匹配，匹配成功，则unpark等待线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryMatch</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (match == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, matchOffset, <span class="keyword">null</span>, s)) &#123;</span><br><span class="line">            Thread w = waiter;</span><br><span class="line">            <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123; <span class="comment">// waiters need at most one unpark</span></span><br><span class="line">                waiter = <span class="keyword">null</span>;</span><br><span class="line">                LockSupport.unpark(w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match == s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tryCancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, matchOffset, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> match == <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> matchOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class &lt; ? &gt; k = SNode<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            matchOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">"match"</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面简单介绍了TransferQueue和TransferStack的基本结构和定义，由于SynchronousQueue的put、take操作都是调用Transfer的transfer()方法，只不过是传递的参数不同而已，put传递的是e参数，所以模式为数据（公平isData = true，非公平mode= DATA），而take操作传递的是null，所以模式为请求（公平isData = false，非公平mode = REQUEST），如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// take操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平模式"><a href="#公平模式" class="headerlink" title="公平模式"></a>公平模式</h3><p>在公平模式中调用的方法是TransferQueue中的transfer方法，我们来看看该刚发的源码定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本算法是循环尝试执行以下两个操作之一：</span></span><br><span class="line"><span class="comment">     * 1.如果队列明显为空或持有相同模式的节点，请尝试将节点添加到等待队列中，直到被匹配或者被取消。</span></span><br><span class="line"><span class="comment">     * 2.如果队列显然包含等待项，并且此调用是互补模式，请尝试通过对等待节点的CAS item字段进行出队并使其出队，然后返回匹配项来实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QNode s = <span class="keyword">null</span>; </span><br><span class="line">    <span class="comment">// 判断是否是数据模式</span></span><br><span class="line">    <span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//尾节点</span></span><br><span class="line">        QNode t = tail;</span><br><span class="line">        <span class="comment">//头结点</span></span><br><span class="line">        QNode h = head;</span><br><span class="line">        <span class="comment">//队列还未初始化，则等待</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// spin</span></span><br><span class="line">        <span class="comment">//如果头为节点相等（队列为空），或者队列尾部节点和请求的节点具有相同的交易类型，那么就将节点添加到队列尾部，并且等待匹配。</span></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// empty or same-mode</span></span><br><span class="line">            QNode tn = t.next;</span><br><span class="line">            <span class="comment">// 如果此时t!=tail，则表示有其它线程进行了操作修改了tail节点，重新定位尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// tn != null，表示已经有其他线程添加了节点，tn 推进，重新处理</span></span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="comment">//尝试推进tn为尾节点</span></span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  调用的方法的 wait 类型的, 并且 超时了, 直接返回 null</span></span><br><span class="line">            <span class="comment">// timed 在take操作阐述</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) <span class="comment">// can't wait</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// s == null，构建一个新节点Node   </span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">            <span class="comment">//CAS设置新节点为尾节点，如果CAS失败，则表示有其它线程进行了操作，重新进行</span></span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s)) <span class="comment">// failed to link in</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//尝试推进s为尾节点        </span></span><br><span class="line">            advanceTail(t, s);</span><br><span class="line">            <span class="comment">// 调用awaitFulfill, 若节点是 head.next, 则进行自旋</span></span><br><span class="line">            <span class="comment">// 若不是的话, 直接 block, 直到有其他线程 与之匹配, 或它自己进行线程的中断</span></span><br><span class="line">            Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123; </span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断结束是否已经从队列中离开</span></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123; </span><br><span class="line">                <span class="comment">//尝试将s设置为head</span></span><br><span class="line">                advanceHead(t, s); </span><br><span class="line">                <span class="keyword">if</span> (x != <span class="keyword">null</span>) <span class="comment">// and forget fields</span></span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E) x : e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            QNode m = h.next;</span><br><span class="line">            <span class="comment">// 不一致读，则表示 有其他线程更改了线程结构，重新开始</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">            Object x = m.item;</span><br><span class="line">            <span class="comment">// isData == (x != null)：判断isData与x的模式是否相同，相同表示已经匹配了</span></span><br><span class="line">            <span class="comment">// x == m ：m节点被取消了</span></span><br><span class="line">            <span class="comment">// !m.casItem(x, e)：如果尝试将数据e设置到m上失败</span></span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||  x == m || !m.casItem(x, e)) &#123; </span><br><span class="line">                advanceHead(h, m); </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 成功匹配了，m设置为头结点h出列，向前推进</span></span><br><span class="line">            advanceHead(h, m); </span><br><span class="line">            <span class="comment">// 唤醒m上的等待线程</span></span><br><span class="line">            LockSupport.unpark(m.waiter);</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E) x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看看awaitFulfill这个方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">awaitFulfill</span><span class="params">(QNode s, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果指定了timed,则时间为System.nanoTime() + nanos，否则为0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0</span> L;</span><br><span class="line">    <span class="comment">//当前线程</span></span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="comment">///如果头节点下一个节点是当前s节点(以防止其他线程已经修改了head节点)</span></span><br><span class="line">    <span class="comment">// 则运算(timed ? maxTimedSpins : maxUntimedSpins)，否则直接返回。</span></span><br><span class="line">    <span class="comment">// 指定了timed则使用maxTimedSpins，反之使用maxUntimedSpins</span></span><br><span class="line">    <span class="keyword">int</span> spins = ((head.next == s) ? (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//判断当前线程是否中断</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            <span class="comment">//尝试取消，将当前节点的item设置为自己(this)</span></span><br><span class="line">            s.tryCancel(e);</span><br><span class="line">         <span class="comment">//获取当前节点的内容   </span></span><br><span class="line">        Object x = s.item;</span><br><span class="line">        <span class="comment">//如果当前节点的值和当前值是否相等，不相等表示节点已经被取出(交易)</span></span><br><span class="line">        <span class="keyword">if</span> (x != e)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="comment">//计算截止时间   </span></span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span> L) &#123;</span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            --spins;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//将当前节点的等待线程设置为当前线程</span></span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            <span class="comment">//线程阻塞</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            <span class="comment">//线程阻塞等待指定纳秒</span></span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put操作的<code>transfer</code>方法的逻辑比较复杂，这里再次对其进行一次梳理，其整个逻辑流程如下：</p><ol><li>获取队列的头结点和尾节点，如果为初始化则自旋等待初始化。</li><li>对队列的尾节点进行验证，定位出真正的尾节点，防止其它线程修改了队列后尾节点定位一次。</li><li>将当前传入的值构建成为一个新的节点，并将其添加到队列尾部并从新定义尾节点。</li><li>然后调用awaitFulfill方法阻塞线程，知道线程被中断或者超时已经消费者消费。</li><li>如何消费者消费成功，则将节点从队列中清除。</li></ol><p>最后我们举例来说明SynchronousQueue的公平模式的<code>put</code>操作。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronousQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-A"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-B"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Integer take = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                take = queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(take);</span><br><span class="line">        &#125;,<span class="string">"Thread-C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先上来之后进行的是两次put操作，然后再take操作，默认队列上来会进行初始化，初始化的内容如下代码所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TransferQueue() &#123;</span><br><span class="line">    <span class="comment">//初始化一个虚拟节点</span></span><br><span class="line">    QNode h = <span class="keyword">new</span> QNode(<span class="keyword">null</span>, <span class="keyword">false</span>); </span><br><span class="line">    head = h;</span><br><span class="line">    tail = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化后，队列的状态如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/put_1.png"  alt="初始化"></p><p>当线程第一次进行<code>put</code>操作时，我们来分析下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QNode t = tail;</span><br><span class="line">QNode h = head;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>) <span class="comment">// saw uninitialized value</span></span><br><span class="line">    <span class="keyword">continue</span>; <span class="comment">// spin</span></span><br></pre></td></tr></table></figure><p>首先获取头结点和尾节点，并判断头结点和尾节点是否为空，如果为空则进行自旋，这里我们看到head=tail=虚拟节点。继续执行后面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列为空或者模式相同时进行if语句</span></span><br><span class="line"><span class="keyword">if</span> (h == t || t.isData == isData) &#123; </span><br><span class="line">    QNode tn = t.next;</span><br><span class="line">    <span class="comment">// 判断t是否是队尾，不是则重新循环。</span></span><br><span class="line">    <span class="keyword">if</span> (t != tail) </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123; </span><br><span class="line">        advanceTail(t, tn);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果指定了timed并且延时时间用尽则直接返回空，这里操作主要是offer操作时，因为队列无存储空间的当offer时不允许插入。</span></span><br><span class="line">    <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这里是新节点生成。</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">        s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">     <span class="comment">// 将尾节点的next节点修改为当前节点。</span></span><br><span class="line">    <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s)) </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 队尾移动</span></span><br><span class="line">    advanceTail(t, s);</span><br><span class="line">    <span class="comment">//自旋并且设置线程。</span></span><br><span class="line">    Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">    <span class="keyword">if</span> (x == s) &#123;</span><br><span class="line">        clean(t, s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.isOffList()) &#123; </span><br><span class="line">        advanceHead(t, s); </span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>) </span><br><span class="line">            s.item = s;</span><br><span class="line">        s.waiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E) x : e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完上面代码后，队列情况如下：</p><p> ![](<a href="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/put_2" target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/zhangzwd/pic-bed/raw/master/blog/put_2</a> .png)</p><p>此时线程A处于自旋状态，如果自旋次数用完后还没有消费者消费在线程进入阻塞状态。接下来是线程B进行操作，这里不进行重复进行，插入第二个元素队列的状况，此时线程B也处于等待状态。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/put_3.png"  alt></p><p>上面的主要是put了两次操作后队列的情况，接下来分析一下take操作时又是如何进行操作的，当take操作时，isData为false，而队尾的isData为true两个不相等，所以不会进入到if语句，而是进入到了else语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 获取头结点的下一个节点，进行互补操作。</span></span><br><span class="line">    QNode m = h.next; </span><br><span class="line">    <span class="comment">//读取不一致，则从新读取</span></span><br><span class="line">    <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">    <span class="comment">//获取m节点的值</span></span><br><span class="line">    Object x = m.item;</span><br><span class="line">    <span class="comment">// 如果x==null，表示x节点已经被读取</span></span><br><span class="line">    <span class="comment">// x==m 表m节点已经被删除</span></span><br><span class="line">    <span class="comment">// m.casItem(x, e) 设置x节点的item为null</span></span><br><span class="line">    <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) || x == m || !m.casItem(x, e)) &#123;</span><br><span class="line">        <span class="comment">//移动头结点到头结点的下一个节点</span></span><br><span class="line">        advanceHead(h, m); </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动头结点到头结点的下一个节点</span></span><br><span class="line">    advanceHead(h, m); </span><br><span class="line">    <span class="comment">//唤醒节点上等待的线程</span></span><br><span class="line">    LockSupport.unpark(m.waiter);</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E) x : e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取头结点的下一个节点m用于互补操作，也就是take操作,接下来判断读取是否一致，不一致从新读取。然后判断m节点是否被消费，如果没消费，则移动头结点到下一个节点，并重新消费，如果没有消费，则移动头结点到下一个节点，然后将m的item值修改为null,并且唤醒m节点上阻塞的线程。因此在take()操作执行完后，队列情况如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/take.png"  alt></p><p>这里需要注意的是，在执行<code>LockSupport.unpark(m.waiter);</code>代码后，或唤醒put操作的线程，这里会唤醒线程A，唤醒线程A后会在执行如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//awaitFulfill方法片段</span></span><br><span class="line">Object x = s.item;</span><br><span class="line"><span class="keyword">if</span> (x != e)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line"><span class="comment">//transfer方法片段</span></span><br><span class="line">Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line"><span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">    clean(t, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断节点是否离开了队列</span></span><br><span class="line"><span class="keyword">if</span> (!s.isOffList()) &#123; </span><br><span class="line">    <span class="comment">//调节头结点</span></span><br><span class="line">    advanceHead(t, s); </span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>) </span><br><span class="line">        s.item = s;</span><br><span class="line">    s.waiter = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E) x : e;</span><br></pre></td></tr></table></figure><p>这里的代码我们可以对照<code>插入第一个元素</code>图，s节点也就是当前m节点，获取值得时候已经修改为null，但是当时插入的值时1，所以两个不想等了，则直接返回null值。此时x!=s因此不会执行<code>clean</code>方法，接下来会执行<code>s.isOffList()</code>来判断节点是否移除了队列，很明显当前节点s并没有离开队列，将waiter设置为null后返回。</p><h3 id="清除操作"><a href="#清除操作" class="headerlink" title="清除操作"></a>清除操作</h3><p>上面分析了正常的take和put操作，接下来我们分析下中断操作，现在在被中断后会执行<code>s.tryCancel(e)</code>方法，这个方法的作用的是将QNode节点的item节点赋值为当前QNode，这时候x和e值就不相等了（<code>if (x != e)</code>），x的值是s.item，则为当前QNode，而e的值是用户指定的值，这时候返回x(s.item)。返回到函数调用地方<code>transfer</code>中，这时候要执行下面语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为节点s被删除了，所有s.item = s</span></span><br><span class="line"><span class="keyword">if</span> (x == s) &#123;                  </span><br><span class="line">    clean(t, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>clean(t,s)</code>清理节点，其方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pred [要清除节点的前一个节点]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s    [要清除的节点]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(QNode pred, QNode s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清除节点等待线程</span></span><br><span class="line">    s.waiter = <span class="keyword">null</span>; </span><br><span class="line">    <span class="comment">//判断节点是否正常(如果不正常表示有其它线程已经对队列做了操作)</span></span><br><span class="line">    <span class="keyword">while</span> (pred.next == s) &#123; </span><br><span class="line">        <span class="comment">//获取队列的头结点</span></span><br><span class="line">        QNode h = head;</span><br><span class="line">        <span class="comment">//头结点指向的下下一个节点(第一个节点)</span></span><br><span class="line">        QNode hn = h.next; </span><br><span class="line">        <span class="comment">//如果头结点的下一个节点已经交易过了，则移动头结点</span></span><br><span class="line">        <span class="keyword">if</span> (hn != <span class="keyword">null</span> &amp;&amp; hn.isCancelled()) &#123;</span><br><span class="line">            advanceHead(h, hn);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取对了的尾节点</span></span><br><span class="line">        QNode t = tail; </span><br><span class="line">        <span class="comment">//如果队列为空，则退出</span></span><br><span class="line">        <span class="keyword">if</span> (t == h)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//获取尾节点的下一个节点</span></span><br><span class="line">        QNode tn = t.next;</span><br><span class="line">        <span class="comment">//判断现在的t是不是末尾节点，可能其他线程插入了内容导致不是最后的节点。</span></span><br><span class="line">        <span class="keyword">if</span> (t != tail)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果不是最后节点的话将其现在t.next节点作为tail尾节点。</span></span><br><span class="line">        <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advanceTail(t, tn);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前要清除节点不是尾节点进入到这里面。</span></span><br><span class="line">        <span class="keyword">if</span> (s != t) &#123; </span><br><span class="line">            <span class="comment">//获取当前节点（被取消的节点）的下一个节点。</span></span><br><span class="line">            QNode sn = s.next;</span><br><span class="line">            <span class="comment">//修改上一个节点的next(下一个)元素为下下个节点。</span></span><br><span class="line">            <span class="keyword">if</span> (sn == s || pred.casNext(s, sn))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QNode dp = cleanMe;</span><br><span class="line">        <span class="keyword">if</span> (dp != <span class="keyword">null</span>) &#123; <span class="comment">// 尝试清除上一个标记为清除的节点。</span></span><br><span class="line">            <span class="comment">//获取要清除的节点</span></span><br><span class="line">            QNode d = dp.next;</span><br><span class="line">            QNode dn;</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="keyword">null</span> || <span class="comment">// d is gone or</span></span><br><span class="line">                d == dp || <span class="comment">// d is off list or</span></span><br><span class="line">                !d.isCancelled() || <span class="comment">// d not cancelled or</span></span><br><span class="line">                (d != t &amp;&amp; <span class="comment">// d not tail and</span></span><br><span class="line">                    (dn = d.next) != <span class="keyword">null</span> &amp;&amp; <span class="comment">//   has successor</span></span><br><span class="line">                    dn != d &amp;&amp; <span class="comment">//   that is on list</span></span><br><span class="line">                    dp.casNext(d, dn))) <span class="comment">// d unspliced</span></span><br><span class="line">                casCleanMe(dp, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (dp == pred)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// s is already saved node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casCleanMe(<span class="keyword">null</span>, pred))</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// Postpone cleaning s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里删除分一下3中情况：</p><ol><li>如果节点中取消的头结点的下一个节点，只需要移动当前head节点到下一个节点即可。</li><li>如果取消的是中间的节点，则将当前节点next节点修改为下下个节点。</li><li>如果修改为末尾的节点，则将当前节点放入到QNode的clearMe中，等待有内容进来之后下一次进行清除操作。</li></ol><p>这里我们对上面3种方式分别举例说明。</p><h4 id="情况一："><a href="#情况一：" class="headerlink" title="情况一："></a>情况一：</h4><p>清除头结点下一个节点，下面是实例代码进行讲解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronousQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-A"</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-B"</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        </span><br><span class="line">        threadA.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子说明我们启动了两个线程，分别向SynchronousQueue队列中添加了元素1和元素2，添加成功之后的，让主线程休眠一会，然后将第一个线程进行中断操作，添加两个元素后节点所处在的状态为下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_1.png"  alt></p><p>当我们调用<code>threadA.interrupt();</code>方法时，线程A的等他消费将会被终止，然后会运行<code>awaitFulfill</code>中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">    <span class="comment">//将节点的item设置为自己</span></span><br><span class="line">    s.tryCancel(e);</span><br><span class="line">Object x = s.item;</span><br><span class="line"><span class="keyword">if</span> (x != e)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure><p>执行完上面代码后，节点状态如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_1_1.png"  alt></p><p>退出<code>awaitFulfill</code>并且返回的是s节点内容（实际上返回的就是s节点），接下来返回到调用<code>awaitFulfill</code>的方法<code>transfer</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回的x就是s</span></span><br><span class="line">Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line"><span class="keyword">if</span> (x == s) &#123; </span><br><span class="line">    <span class="comment">//进入clean方法</span></span><br><span class="line">    clean(t, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>clean</code>方法后运行如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QNode h = head;</span><br><span class="line">QNode hn = h.next; </span><br><span class="line"><span class="comment">//判断头结点的下一个节点不为空，切实删除状态则进入</span></span><br><span class="line"><span class="keyword">if</span> (hn != <span class="keyword">null</span> &amp;&amp; hn.isCancelled()) &#123;</span><br><span class="line">    advanceHead(h, hn);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到首先h节点为head节点，hn为头结点的下一个节点，在进行判断头结点的下一个节点不为空并且头结点下一个节点是被中断的节点(取消的节点)，则进入到if语句中，if语句其实也很简单就是将头结点修改为头结点的下一个节点(s节点，别取消节点，并且将前节点的next节点修改为自己，也就是移除了之前的节点，我们看下advanceHead方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advanceHead</span><span class="params">(QNode h, QNode nh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == head &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, headOffset, h, nh))</span><br><span class="line">        h.next = h; <span class="comment">// forget old next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>advanceHead</code>代码比较简单，运行完后，节点状态如下所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_1_2.png"  alt></p><p>从上图我们看到，队列的原头结点从队列中移除了，并且原队列中头结点的下一个元素转变成了新的头结点，至此清除头结点的下一个节点完成。</p><h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>清除中间节点，实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronousQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-A"</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        </span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-B"</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-C"</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        </span><br><span class="line">        threadB.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完3次put操作后，队列情况如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_2.png"  alt></p><p>在执行<code>threadB.interrupt();</code>后，线程B会从等待中唤醒，然后和情况一相同从<code>awaitFulfill</code>方法中返回后进入<code>clean</code>方法，代入如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QNode t = tail; <span class="comment">// Ensure consistent read for tail</span></span><br><span class="line"><span class="keyword">if</span> (t == h)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">QNode tn = t.next;</span><br><span class="line"><span class="keyword">if</span> (t != tail)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    advanceTail(t, tn);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s != t) &#123;</span><br><span class="line">    QNode sn = s.next;</span><br><span class="line">    <span class="keyword">if</span> (sn == s || pred.casNext(s, sn))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里s即线程B所在的节点也就是要清除的节点，很显然<code>s!=t</code>成立，进入if语句。然后执行<code>pred.casNext(s, sn)</code>将s节点跳过，运行完后，队列情况如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_2_1.png"  alt></p><h4 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h4><p>清除尾节点，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronousQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-A"</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-B"</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        threadB.interrupt();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        </span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread-C"</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        threadC.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例子主要说明一个问题就是删除的节点如果是末尾节点的话，<code>clear</code>方法又是如何处理的，首先启动第一和第二个线程，然后又将第二个线程中断，这是第二个线程插入的节点为尾节点，然后再启动第三个节点插入值，再中断了第三个节点末尾节点，说一下为啥这样操作，因为当清除尾节点时，并不是直接移除当前节点，而是将被清除的节点的前节点设置到QNode的CleanMe中，等待下次clear方法时进行清除上次保存在CleanMe的节点，然后再处理当前被中断节点，将新的被清理的节点prev设置为cleanMe当中，等待下次进行处理，接下来一步一步分析，首先我们先来看一下第二个线程启动后节点的状态。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_3.png"  alt></p><p>然后在执行了<code>threadB.interrupt();</code>后，状态如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_3_1.png"  alt></p><p>然后在线程C执行put操作后，状态如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_3_2.png"  alt></p><p>然后执行<code>threadC.interrupt();</code>后此时<code>QNode dp = cleanMe;</code>不为空，因此进入执行下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dp != <span class="keyword">null</span>) &#123; <span class="comment">// Try unlinking previous cancelled node</span></span><br><span class="line">    QNode d = dp.next;</span><br><span class="line">    QNode dn;</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="keyword">null</span> || <span class="comment">// d is gone or</span></span><br><span class="line">        d == dp || <span class="comment">// d is off list or</span></span><br><span class="line">        !d.isCancelled() || <span class="comment">// d not cancelled or</span></span><br><span class="line">        (d != t &amp;&amp; <span class="comment">// d not tail and</span></span><br><span class="line">            (dn = d.next) != <span class="keyword">null</span> &amp;&amp; <span class="comment">//   has successor</span></span><br><span class="line">            dn != d &amp;&amp; <span class="comment">//   that is on list</span></span><br><span class="line">            dp.casNext(d, dn))) <span class="comment">// d unspliced</span></span><br><span class="line">        casCleanMe(dp, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (dp == pred)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// s is already saved node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码逻辑主要如下：</p><ol><li>判断d是否为空，如果为空，则表示节点已经清除。</li><li>如果cleanMe节点的下一个节点和自己相等，说明需要清除的节点已经离队了。</li><li>判断要清除的节点状态是清除状态。</li><li>如果上面条件都正确，则执行<code>(d != t &amp;&amp; (dn = d.next) != null &amp;&amp; dn != d &amp;&amp;  dp.casNext(d, dn))</code>，将清除节点前一个节点的next设置为清除节点的后一个节点。</li></ol><p>上面逻辑执行完后，队列状态如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_3_3.png"  alt></p><p>可以看出将上一次标记为清除的节点清除了队列中，再次进入循环，循环之后发现dp为null则会运行<code>casCleanMe(null, pred)</code>，此时当前节点s的前一个节点已经被清除队列，但是并不影响后续的清除操作，因为前节点的next节点还在维护中，也是前节点的next指向还是<code>Reference-Thread-C</code>,如下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/clean_3_4.png"  alt></p><p>就此SynchronousQueue的公平模式的数据交换分析完毕，如果有不正确的地方请指正。下一篇将分析SynchronousQueue的非公平模式。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> SynchronousQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC阻塞队列之DelayQueue源码分析</title>
      <link href="/juc-delayQueue/"/>
      <url>/juc-delayQueue/</url>
      
        <content type="html"><![CDATA[<p>DelayQueue是一个支持延时获取元素的无界阻塞队列。并且队列中的元素必须实现Delayed接口。在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中获取到元素。DelayQueue的应用范围非常广阔，如可以用它来保存缓存中元素的有效期，也可用它来实现定时任务。</p><p>DelayQueue是一个支持延时获取元素的无界阻塞队列。并且队列中的元素必须实现Delayed接口。在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中获取到元素。DelayQueue的应用范围非常广阔，如可以用它来保存缓存中元素的有效期，也可用它来实现定时任务。</p><h4 id="Delayed接口"><a href="#Delayed接口" class="headerlink" title="Delayed接口"></a>Delayed接口</h4><p>在分析DelayQueue源码之前，我们先来看看Delayd接口，其源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &lt; <span class="title">Delayed</span> &gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定返回对象的延时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  unit [时间单位]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>      [延时的剩余，0或者-1表示延时已经过期]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，Delayed接口继承了Comparable接口，即实现Delayed接口的对象必须实现<code>getDelay(TimeUnit unit)</code>方法和<code>compareTo(T o)</code>方法。这里<code>compareTo(T o)</code>方法可以用来实现元素的排序，可以将延时时间长的放到队列的末尾。</p><h4 id="DelayQueue构造函数"><a href="#DelayQueue构造函数" class="headerlink" title="DelayQueue构造函数"></a>DelayQueue构造函数</h4><p>上面分析了Delayed接口，接下来我们分析DelayQueue的构造函数。DelayQueue提供了2种构造函数，一个是无参构造函数，一个是给定集合为参数的构造函数。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个空的DelayQueue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定集合c为参数的构造函数</span></span><br><span class="line"><span class="comment"> * 将集合c中的元素全部放入到DelayQueue中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">(Collection &lt; ? extends E &gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addAll</code>方法是AbstractQueue抽象类中的方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection &lt; ? extends E &gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数检测</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//遍历集合c中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (E e: c)</span><br><span class="line">        <span class="comment">// 调用DelayQueue中的add方法</span></span><br><span class="line">        <span class="keyword">if</span> (add(e))</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码中，我们可以看到，AbstractQueue抽象类中<code>addAll</code>方法实际是调用DelayQueue类中的<code>add</code>方法来实现的。</p><h4 id="DelayQueue-入列操作"><a href="#DelayQueue-入列操作" class="headerlink" title="DelayQueue 入列操作"></a>DelayQueue 入列操作</h4><p>DelayQueue提供了4种入列操作，分别是：</p><ul><li><code>add(E e):</code>阻塞的将指定元素添加到延时队列中去，因为队列是无界的因此此方法永不阻塞。</li><li><code>offer(E e):</code>阻塞的将指定元素添加到延时队列中去，因为队列是无界的因此此方法永不阻塞。</li><li><code>put(E e):</code>阻塞的将指定元素添加到延时队列中去，因为队列是无界的因此此方法永不阻塞。</li><li><code>offer(E e, long timeout, TimeUnit unit):</code>阻塞的将指定元素添加到延时队列中去，因为队列是无界的因此此方法永不阻塞。</li></ul><p>这里大家可能会奇怪，为什么这些入列方法的解释都是一样的？这个问题先等下回答，我们先来看看这几个入列方法的源码定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用PriorityQueue中的offer方法</span></span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="comment">//调用PriorityQueue中的peek方法</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们从源码中可以看到，<code>add(E e)</code>方法、<code>put(E e)</code>方法和<code>offer(E e,long timeout,TimeUnit unit)</code>方法都是调用<code>offer(E e)</code>方法来实现的，这也是为什么这几个方法的解释都是一样的原因。其中<code>offer(E e)</code>方法的核心又是调用了PriorityQueue中的<code>offer(E e)</code>方法，PriorityQueue和PriorityBlockingQueue都是以二叉堆的无界队列，只不过PriorityQueue不是阻塞的而PriorityBlockingQueue是阻塞的。前面分析过PriorityBlockingQueue的源码，这里就不在重复赘述了。</p><h4 id="DelayQueue出列操作"><a href="#DelayQueue出列操作" class="headerlink" title="DelayQueue出列操作"></a>DelayQueue出列操作</h4><p>DelayQueue提供了3种出列操作方法，它们分别是：</p><ul><li><code>poll():</code>检索并删除此队列的开头，如果此队列没有延迟的元素，则返回null</li><li><code>take():</code>检索并除去此队列的头，如有必要，请等待直到该队列上具有过期延迟的元素可用。</li><li><code>poll(long timeout, TimeUnit unit):</code>检索并删除此队列的头，如有必要，请等待直到该队列上具有过期延迟的元素可用，或者或指定的等待时间到期。</li></ul><p>下面我们来一个一个分析出列操作的原来。</p><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>poll操作的源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//获取队列中的第一个元素</span></span><br><span class="line">        E first = q.peek();</span><br><span class="line">        <span class="comment">//如果元素为null,或者头元素还未过期，则返回false</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           <span class="comment">//调用PriorityQueue中的出列方法</span></span><br><span class="line">            <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法与PriorityQueue的poll方法唯一的区别就是多了<code>if (first == null || first.getDelay(NANOSECONDS) &gt; 0)</code>这个条件判断，该条件是表示如果队列中没有元素或者队列中的元素未过期，则返回null。</p><h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><p>take操作源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//西循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//查看队列头元素</span></span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="comment">//如果队列头元素为null,则表示队列中没有数据，线程进入等待队列</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取first元素剩余的延时时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="comment">//如果剩余延时时间&lt;=0 表示元素已经过期，可以从队列中获取元素</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//直接返回头部元素</span></span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                <span class="comment">//如果剩余延时时间&gt;0，表示元素还未过期，则将first置为null,防止内存溢出</span></span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="comment">//如果leader不为null，则直接进入等待队列中等待</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果leader为null,则把当前线程赋值给leader，并超时等待delay纳秒</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//唤醒线程</span></span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>take</code>操作比<code>poll</code>操作稍微要复杂些，但是逻辑还是相对比较简单。只是在获取元素的时候先检查元素的剩余延时时间，如果剩余延时时间&lt;=0,则直接返回队列头元素。如果剩余延时时间&gt;0，则判断leader是否为null，如果leader不为null，则表示已经有线程在等待获取队列的头部元素，因此直接进入等待队列中等待。如果leader为null，则表示这是第一个获取头部元素的线程，把当前线程赋值给leader，然后超时等待剩余延时时间。在<code>take</code>操作中需要注意的一点是<code>fist=null</code>，因为如果first不置为null的话会引起内存溢出的异常，这是因为在并发的时候，每个线程都会持有一份first，因此first不会被释放，如果线程数过多，就会导致内存溢出的异常。</p><h5 id="poll-long-timeout-TimeUnit-unit"><a href="#poll-long-timeout-TimeUnit-unit" class="headerlink" title="poll(long timeout, TimeUnit unit)"></a>poll(long timeout, TimeUnit unit)</h5><p>超时等待获取队列元素的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class="line">                        nanos -= delay - timeLeft;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个出列操作的逻辑和<code>take</code>出列操作的逻辑几乎一样，唯一不同的在于<code>take</code>是无时间限制等待，而改操作是超时等待。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>DelayQueue的入列和出列操作逻辑相对比较简单，就是在获取元素的时候，判断元素是否已经过期，如果过期就可以直接获取，没有过期的话<code>poll</code>操作是直接返回null，<code>take</code>操作是进入等待队列中等待。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> delayQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC阻塞队列之PriorityBlockingQueue源码分析</title>
      <link href="/juc-priorityBlockingQueue/"/>
      <url>/juc-priorityBlockingQueue/</url>
      
        <content type="html"><![CDATA[<p>PriorityBlockingQueue是一个支持优先级的无界队列。默认情况下PriorityBlockingQueue中元素的排列顺序采用自然升序的方式排列。也可以自定义类实现compareTo()方法来执行元素的排列规则，或者在初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是PriorityBlockingQueue不能保证同优先级元素的顺序，并且不支持插入null元素也不支持插入非comparable的对象。</p><p>PriorityBlockingQueue是基于最小二叉堆实现，对于堆数组中索引为n的节点，其父节点为(n-1)/2，其左右子节点分别为2n+1和2n+2。PriorityBlockingQueue使用ReentrantLock来控制所有公用操作的线程同步，使用基于CAS实现的自旋锁来控制队列的动态扩容，保证了扩容操作不会阻塞take操作的执行。</p><h3 id="主要成员变量"><a href="#主要成员变量" class="headerlink" title="主要成员变量"></a>主要成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认最大容量</span></span><br><span class="line"><span class="comment"> * 减8是因为有的VM实现在数组头有些内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放最小二叉堆的数组。</span></span><br><span class="line"><span class="comment"> * 父节点下标是n,那么左节点的下标为2n+1，右节点的下标为2n+2。最小的元素在前面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Comparator &lt; ? <span class="keyword">super</span> E &gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于同步队列操作的锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当队列为空时，阻塞的条件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋锁标识字段，通过CAS操作进行比较更新；</span></span><br><span class="line"><span class="comment"> * 用于动态扩容操作；值为1时，表示加锁；为0时，标识未加锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个普通的PriorityQueue，仅用于序列化</span></span><br><span class="line"><span class="comment"> * 以保持与此类的先前版本的兼容性。仅在序列化/反序列化期间为非null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> PriorityQueue &lt; E &gt; q;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>PriorityBlockingQueue提供了4种初始化方案，它们分别如下：</p><ul><li><p>方案一：无参初始化，源码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认容量大小为11，比较器设置为null</span></span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方案二：指定初始容量大小初始化，源码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方案三：指定初始容量大小和比较器的初始化，源码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,Comparator &lt; ? <span class="keyword">super</span> E &gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验初始容量大小的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 初始化可重入锁(非公平锁)</span></span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//队列为空时的阻塞条件</span></span><br><span class="line">    <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="comment">//初始化比较器</span></span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    <span class="comment">//初始化数组大小</span></span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方案四：指定一个集合的初始化，源码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(Collection &lt; ? extends E &gt; c)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 初始化可重入锁(非公平锁)</span></span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//队列为空时的阻塞条件</span></span><br><span class="line">    <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="comment">//默认进行堆有序化</span></span><br><span class="line">    <span class="keyword">boolean</span> heapify = <span class="keyword">true</span>; </span><br><span class="line">    <span class="comment">//默认检查元素中的每个元素</span></span><br><span class="line">    <span class="keyword">boolean</span> screen = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//如果传入的集合是SortedSet类型，则不进行堆的有序化</span></span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet &lt; ? &gt; ) &#123;</span><br><span class="line">        SortedSet &lt; ? extends E &gt; ss = (SortedSet &lt; ? extends E &gt; ) c;</span><br><span class="line">        <span class="comment">//获取比较器</span></span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator &lt; ? <span class="keyword">super</span> E &gt; ) ss.comparator();</span><br><span class="line">        heapify = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果传入的集合是PriorityBlockingQueue类型，则即不进行堆有序化也不对每个元素进行是否为null的判断</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityBlockingQueue &lt; ? &gt; ) &#123;</span><br><span class="line">        PriorityBlockingQueue &lt; ? extends E &gt; pq =</span><br><span class="line">            (PriorityBlockingQueue &lt; ? extends E &gt; ) c;</span><br><span class="line">        <span class="comment">//获取比较器    </span></span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator &lt; ? <span class="keyword">super</span> E &gt; ) pq.comparator();</span><br><span class="line">        screen = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pq.getClass() == PriorityBlockingQueue<span class="class">.<span class="keyword">class</span>) // <span class="title">exact</span> <span class="title">match</span></span></span><br><span class="line"><span class="class">            <span class="title">heapify</span> </span>= <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将传入的集合转变为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="comment">// If c.toArray incorrectly doesn't return Object[], copy it.</span></span><br><span class="line">    <span class="keyword">if</span> (a.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">a</span> </span>= Arrays.copyOf(a, n, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (screen &amp;&amp; (n == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue = a;</span><br><span class="line">    <span class="keyword">this</span>.size = n;</span><br><span class="line">    <span class="keyword">if</span> (heapify)</span><br><span class="line">        heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>介绍完PriorityBlockingQueue的初始化后，我们来看看它的入列和出列操作。</p><h3 id="入列操作"><a href="#入列操作" class="headerlink" title="入列操作"></a>入列操作</h3><p>PriorityBlockingQueue的入列操作提供了4种方法，分别如下：</p><ul><li><code>add(E e):</code>调用<code>offer</code>方法实现</li><li><code>offer(E e):</code>队列满时返回false；由于为无界队列，因而不会返回false；</li><li><code>put(E e):</code>队列满时阻塞；由于为无界队列，因而不会阻塞；代码实现直接调用offer方法；</li><li><code>offer(E e, long timeout, TimeUnit unit):</code>队列满时阻塞等待直至超时或者数组有空出位置；由于为无界队列，因而不会返回false、超时、阻塞；代码实现直接调用offer方法；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接由offer方法实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  e [要插入的元素]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   [队列满时返回false,由于是无界队列，因此永远不会返回false]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  e [要插入的元素]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   [队列满时返回false,由于是无界队列，因此永远不会返回false]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//检查元素合法性</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">int</span> n, cap;</span><br><span class="line">    Object[] array;</span><br><span class="line">    <span class="comment">//如果队列满，则扩容</span></span><br><span class="line">    <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">        tryGrow(array, cap);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//获取比较器</span></span><br><span class="line">        Comparator &lt; ? <span class="keyword">super</span> E &gt; cmp = comparator;</span><br><span class="line">        <span class="comment">//如果比较器为null,则调用siftUpComparable方法</span></span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            siftUpComparable(n, e, array);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则调用siftUpUsingComparator方法</span></span><br><span class="line">            siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">        size = n + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//唤醒阻塞的线程</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//是否锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由于是无界队列，永远不会被阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e); <span class="comment">// never need to block</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由于是无界队列，因而不存在阻塞、超时和返回false的情况；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e); <span class="comment">// never need to block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入列操作实际只有一个<code>offer(E e)</code>方法，而<code>offer(E e)</code>方法的核心逻辑是在<code>siftUpComparable</code>方法和<code>siftUpUsingComparator</code>方法里面。下面我们来分析这2个方法。</p><h4 id="siftUpComparable-和-siftUpUsingComparator-操作"><a href="#siftUpComparable-和-siftUpUsingComparator-操作" class="headerlink" title="siftUpComparable 和 siftUpUsingComparator 操作"></a>siftUpComparable 和 siftUpUsingComparator 操作</h4><p>siftUpComparable和siftUpUsingComparator方法都是上浮方法，所谓的上浮方法即每次和根节点进行比价，如果插入的节点比当前的根节点小，则再次和根节点的父根节点进行比较，直到root节点。这里大家可能会有疑惑，PriorityBlockingQueue的底层数基于数组的，哪来的根节点呢？这是因为PriorityBlockingQueue的底层是数组不假，但这个数组是最小二叉堆的实现，对这里有疑惑的同学，可以先看看最小二叉堆的数据结构就很清楚了，LZ在这里就不分析最小二叉堆的结构了。siftUpComparable和siftUpUsingComparator的区别在于在元素比较上siftUpComparable使用的是compareTo方法而siftUpUsingComparator使用的是compare方法。下面我们来分析siftUpComparable &amp; siftUpUsingComparator的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [上浮操作，元素必须实现Comparable接口]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  k     [元素代插入的位置]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  x     [元素]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array [队列]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>       </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt; T &gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//元素必须实现Comparable接口，否则会抛出异常</span></span><br><span class="line">    Comparable &lt; ? <span class="keyword">super</span> T &gt; key = (Comparable &lt; ? <span class="keyword">super</span> T &gt; ) x;</span><br><span class="line">    <span class="comment">// 循环查找节点待插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到K位置的父节点下标</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获取k的父节点的值</span></span><br><span class="line">        Object e = array[parent];</span><br><span class="line">        <span class="comment">//和父节点进行比较</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果x比根元素大，则跳出while循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//否则，将parent处的节点放到k的位置</span></span><br><span class="line">        array[k] = e;</span><br><span class="line">        <span class="comment">//将parent给k</span></span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将x放置到k的位置</span></span><br><span class="line">    array[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [上浮操作，基于Comparator，逻辑和siftUpComparable一样]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  k     [元素代插入的位置]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  x     [元素]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array [队列]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>      </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt; T &gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">    Comparator &lt; ? <span class="keyword">super</span> T &gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = array[parent];</span><br><span class="line">        <span class="keyword">if</span> (cmp.compare(x, (T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        array[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    array[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入列流程如下，假设此时队列中的元素为[5,6,7,8,9,10]，那么对于最新二叉堆的结构如下所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E6%9C%80%E5%B0%8F%E4%BA%8C%E5%8F%89%E5%A0%86.png"  alt></p><p>如果此时需要向队列中插入元素4时，即x=4，k=6。此时节点x先和k的父节点的值进行比较大小，当<code>x&gt;=k的父节点的值</code>时，将x放入到k的位置，即array[k] = x;在最小二叉堆中即表现为节点7的右孩子为x。当<code>x&lt;k的父节点的值</code>时，则将K的父节点的值放入到k的位置，如下所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%85%A5%E5%88%97%E6%93%8D%E4%BD%9C2.png"  alt> </p><p>上述操作完成后，k=2，x=4。x继续和k的父节点比价，即x和5进行比价，发现x&lt;5,则将5放置到k的位置。如下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%85%A5%E5%88%97%E6%93%8D%E4%BD%9C3.png"  alt><br>上述操作完成后，k=0,x=4。则直接将x放置到k的位置。如下所示:</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%85%A5%E5%88%97%E6%93%8D%E4%BD%9C4.png"  alt><br>此时队列中数据在数组中的展示顺序为[4,6,5,8,9,10,7]</p><h3 id="出列操作"><a href="#出列操作" class="headerlink" title="出列操作"></a>出列操作</h3><p>同入列操作一样，PriorityBlockingQueue也提供了3种出列操作，它们分别如下：</p><ul><li><code>E poll():</code>队列为空时，直接返回null，不会阻塞；</li><li><code>E take():</code>队列为空时，阻塞直至有元素添加到队列中；</li><li><code>E poll(long timeout, TimeUnit unit):</code>队列为空时，阻塞直至超时或者有元素添加到队列中；</li></ul><p>出列操作的源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用dequeue方法</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="keyword">while</span> ((result = dequeue()) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果获取的数据为null,则等待</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ((result = dequeue()) == <span class="keyword">null</span> &amp;&amp; nanos &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//等待nanos</span></span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码中我们可以看到，出列操作的逻辑比较简单，其的核心方法是<code>dequeue</code>方法，接下来我们看看<code>dequeue</code>的源码定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n为最后一个元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果n&lt;0，表示队列中没有元素，返回null</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取到队列数组</span></span><br><span class="line">        Object[] array = queue;</span><br><span class="line">        <span class="comment">//取出队列中的第一个元素</span></span><br><span class="line">        E result = (E) array[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//取出队列中的最后一个元素</span></span><br><span class="line">        E x = (E) array[n];</span><br><span class="line">        <span class="comment">//将队列中的最后一个元素设置为null</span></span><br><span class="line">        array[n] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//构造队列是，是否有传入比较器</span></span><br><span class="line">        Comparator &lt; ? <span class="keyword">super</span> E &gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果没有传入，则使用siftDownComparable进行下沉操作</span></span><br><span class="line">            siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果传入了比较器，则使用siftDownUsingComparator进行下沉操作</span></span><br><span class="line">            siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">        <span class="comment">//给size赋值</span></span><br><span class="line">        size = n;</span><br><span class="line">        <span class="comment">//返回元素</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中我们可以看到，<code>dequeue</code>方法的逻辑就是取出队列中的第一个元素，然后进行下沉操作。那么我们看看下沉操作到底做了什么处理呢？下沉操作源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下沉操作，将元素x,插入到k的位置</span></span><br><span class="line"><span class="comment"> * 下沉操作的目的是维持最小二叉堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  k     [要插入的位置]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  x     [插入的元素]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array [数组]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  n     [数字中元素的个数]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>       </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt; T &gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确保队列中存在元素</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Comparable &lt; ? <span class="keyword">super</span> T &gt; key = (Comparable &lt; ? <span class="keyword">super</span> T &gt; ) x;</span><br><span class="line">        <span class="comment">//队列中元素个数的一半</span></span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// loop while a non-leaf</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="comment">//获取k位置的左孩子节点的下标</span></span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">            <span class="comment">//获取k位置的左孩子节点的值</span></span><br><span class="line">            Object c = array[child];</span><br><span class="line">            <span class="comment">//k位置右孩子的下标</span></span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果左孩子的值比右孩子的值大</span></span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">                ((Comparable &lt; ? <span class="keyword">super</span> T &gt; ) c).compareTo((T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//设置有右孩子节点的值为c</span></span><br><span class="line">                c = array[child = right];</span><br><span class="line">            <span class="comment">//如果</span></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//把c的值赋值到k的位置上</span></span><br><span class="line">            array[k] = c;</span><br><span class="line">            <span class="comment">//将child赋值给k</span></span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将key的值赋值到k位置上</span></span><br><span class="line">        array[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt; T &gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array, <span class="keyword">int</span> n, Comparator &lt; ? <span class="keyword">super</span> T &gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            Object c = array[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = array[child = right];</span><br><span class="line">            <span class="keyword">if</span> (cmp.compare(x, (T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            array[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        array[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>siftDownUsingComparator</code>方法和<code>siftDownComparable</code>方法的逻辑一样，唯一的区别就是比较器的不同。下沉操作的目的是为了保持二叉堆，那我们看看它是如何维护的？我们还以以上面插入操作的数据为例。在上面插入操作完成后，队列中数组为：[4,6,5,8,9,10,7]。二叉堆的表现如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%85%A5%E5%88%97%E6%93%8D%E4%BD%9C4.png"  alt></p><p>此时，我们第一次做出列操作，返回的元素是4，然后队列做下沉操作。此时，k=0;x=7,arrar=[4,6,5,8,9,10],n=6,那么half=3。k&lt;half成立，进入while，那么child = 2k+1 = 1,c=array[child] = 6,right = child+1 = 2。此时条件<code>right &lt; n &amp;&amp;    ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0</code>成立，则c=array[child=right]=5。然后array[k]=c,即array[0]=5。此时二叉堆如下： </p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%87%BA%E5%88%97%E6%93%8D%E4%BD%9C1.1.png"  alt></p><p>执行完第一遍后,k=2。继续while循环。此时child = 2k+1 = 5,c=array[child]=10,right=child+1 = 6。此时条件<code>right &lt; n &amp;&amp; ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0</code>不成立，而条件<code>key.compareTo((T) c) &lt;= 0</code>成立，跳出while循环，然后把key赋值到k位置，即array[2]=7。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%87%BA%E5%88%97%E6%93%8D%E4%BD%9C1.2.png"  alt></p><p>我们看到，在第一次出来操作后，经过下沉操作，任然维持二叉堆不变呢。</p><p>第二次出列操作返回的是5，第三次是6，第四次是7，第五次是8，第六次是9，第7次是10。出列操作是按照从小到大的顺依次弹出，有兴趣的同学可以Debug看看。</p><h3 id="查看队列头部元素操作"><a href="#查看队列头部元素操作" class="headerlink" title="查看队列头部元素操作"></a>查看队列头部元素操作</h3><p>查看队列头部元素操作只有一个，那就是<code>peek</code>方法，其源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>peek</code>方法非常简单，就是返回数组的第一个元素，但是并不会将第一个元素出队列。</p><h3 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h3><p>PriorityBlockingQueue扩容一般是括50%，但是在队列元素小于64的时候，扩容原来的元素个数+2。扩容操作的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//必须先释放锁，因为在做扩容操作前肯定是先获取了锁的</span></span><br><span class="line">    lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line">    Object[] newArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//CAS方式获取扩容操作的权限</span></span><br><span class="line">    <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//扩容</span></span><br><span class="line">            <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                (oldCap + <span class="number">2</span>) : <span class="comment">// grow faster if small</span></span><br><span class="line">                (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="comment">//如果扩容后的大小比最大的队列长度还要大</span></span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123; <span class="comment">// possible overflow</span></span><br><span class="line">                <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果minCap&lt;0,表示已经超出了int的范围，获取minCap &gt; MAX_ARRAY_SIZE，则抛出OutOfMemoryError异常</span></span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里 queue == array，是为了确保没有做出列操作。</span></span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果CAS失败，则让出CPU执行时间</span></span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) <span class="comment">// back off if another thread is allocating</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="comment">//加锁    </span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        <span class="comment">// 将原来数组上的值，拷贝到新的数组上去</span></span><br><span class="line">        queue = newArray;</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，扩容操作在计算新数组的长度的时候，使用的是CAS的方式，并没有使用重入锁。这是为了如果在扩容时，有出列操作，则没有必要进行扩容，省去了不必要的开销。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> PriorityBlockingQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 日志</title>
      <link href="/mybatis-log/"/>
      <url>/mybatis-log/</url>
      
        <content type="html"><![CDATA[<h2 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h2><p>Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具：</p><ul><li>SLF4J</li><li>Apache Commons Logging</li><li>Log4j 2</li><li>Log4j</li><li>JDK logging</li></ul><p>具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。 如果一个都未找到，日志功能就会被禁用。</p><p>不少应用服务器的classpath中已经包含Commons Logging，如Tomcat和WebShpere， 所以MyBatis会把它作为具体的日志实现。记住这点非常重要。这将意味着，在诸如 WebSphere的环境中——WebSphere提供了Commons Logging的私有实现，你的Log4J配置将被忽略。 这种做法不免让人悲催，MyBatis怎么能忽略你的配置呢？事实上，因Commons Logging已经存 在了，按照优先级顺序，Log4J自然就被忽略了！不过，如果你的应用部署在一个包含Commons Logging的环境， 而你又想用其他的日志框架，你可以根据需要调用如下的某一方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.apache.ibatis.logging.LogFactory.useSlf4jLogging();</span><br><span class="line">org.apache.ibatis.logging.LogFactory.useLog4JLogging();</span><br><span class="line">org.apache.ibatis.logging.LogFactory.useJdkLogging();</span><br><span class="line">org.apache.ibatis.logging.LogFactory.useCommonsLogging();</span><br><span class="line">org.apache.ibatis.logging.LogFactory.useStdOutLogging();</span><br></pre></td></tr></table></figure><p>如果的确需要调用以上的某个方法，请在其他所有MyBatis方法之前调用它。另外，只有在相应日志实现中存在 的前提下，调用对应的方法才是有意义的，否则MyBatis一概忽略。如你环境中并不存在Log4J，你却调用了 相应的方法，MyBatis就会忽略这一调用，代之默认的查找顺序查找日志实现。</p><p>关于SLF4J、Apache Commons Logging、Apache Log4J和JDK Logging的API介绍已经超出本文档的范围。 不过，下面的例子可以作为一个快速入门。关于这些日志框架的更多信息，可以参考以下链接：</p><ul><li><a href="http://commons.apache.org/proper/commons-logging/" target="_blank" rel="external nofollow noopener noreferrer">Apache Commons Logging</a></li><li><a href="http://logging.apache.org/log4j/2.x/" target="_blank" rel="external nofollow noopener noreferrer">Apache Log4j</a></li><li><a href="http://www.oracle.com/technetwork/java/index.html" target="_blank" rel="external nofollow noopener noreferrer">JDK Logging API</a></li></ul><h2 id="Logging-Configuration"><a href="#Logging-Configuration" class="headerlink" title="Logging Configuration"></a>Logging Configuration</h2><p>MyBatis可以对包、类、命名空间和全限定的语句记录日志。</p><p>具体怎么做，视使用的日志框架而定，这里以Log4J为例。配置日志功能非常简单：添加几个配置文件， 如log4j.properties,再添加个jar包，如log4j.jar。下面是具体的例子，共两个步骤：</p><h4 id="步骤1：-添加-Log4J-的-jar-包"><a href="#步骤1：-添加-Log4J-的-jar-包" class="headerlink" title="步骤1： 添加 Log4J 的 jar 包"></a>步骤1： 添加 Log4J 的 jar 包</h4><p>因为采用Log4J，要确保在应用中对应的jar包是可用的。要满足这一点，只要将jar包添加到应用的classpath中即可。 Log4J的jar包可以从上面的链接中下载。</p><p>具体而言，对于web或企业应用，需要将<code>log4j.jar</code> 添加到<code>WEB-INF/lib</code> 目录； 对于独立应用， 可以将它添加到jvm的 <code>-classpath</code>启动参数中。</p><h4 id="步骤2：配置Log4J"><a href="#步骤2：配置Log4J" class="headerlink" title="步骤2：配置Log4J"></a>步骤2：配置Log4J</h4><p>配置Log4J比较简单， 比如需要记录这个mapper接口的日志:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.example;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Select</span>(<span class="string">"SELECT * FROM blog WHERE id = #&#123;id&#125;"</span>)</span><br><span class="line">  <span class="function">Blog <span class="title">selectBlog</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要在应用的classpath中创建一个名称为<code>log4j.properties</code>的文件， 文件的具体内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global logging configuration</span></span><br><span class="line"><span class="string">log4j.rootLogger=ERROR,</span> <span class="string">stdout</span></span><br><span class="line"><span class="comment"># MyBatis logging configuration...</span></span><br><span class="line"><span class="string">log4j.logger.org.mybatis.example.BlogMapper=TRACE</span></span><br><span class="line"><span class="comment"># Console output...</span></span><br><span class="line"><span class="string">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="string">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="string">log4j.appender.stdout.layout.ConversionPattern=%5p</span> <span class="string">[%t]</span> <span class="bullet">-</span> <span class="string">%m%n</span></span><br></pre></td></tr></table></figure><p>添加以上配置后，Log4J就会把 <code>org.mybatis.example.BlogMapper</code> 的详细执行日志记录下来，对于应用中的其它类则仅仅记录错误信息。</p><p>也可以将日志从整个mapper接口级别调整到到语句级别，从而实现更细粒度的控制。如下配置只记录 <code>selectBlog</code> 语句的日志：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">log4j.logger.org.mybatis.example.BlogMapper.selectBlog=TRACE</span></span><br></pre></td></tr></table></figure><p>与此相对，可以对一组mapper接口记录日志，只要对mapper接口所在的包开启日志功能即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">log4j.logger.org.mybatis.example=TRACE</span></span><br></pre></td></tr></table></figure><p>某些查询可能会返回大量的数据，只想记录其执行的SQL语句该怎么办？为此，Mybatis中SQL语 句的日志级别被设为DEBUG（JDK Logging中为FINE），结果日志的级别为TRACE（JDK Logging中为FINER)。所以，只要将日志级别调整为DEBUG即可达到目的：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">log4j.logger.org.mybatis.example=DEBUG</span></span><br></pre></td></tr></table></figure><p>要记录日志的是类似下面的mapper文件而不是mapper接口又该怎么呢？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.mybatis.example.BlogMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对这个文件记录日志，只要对命名空间增加日志记录功能即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">log4j.logger.org.mybatis.example.BlogMapper=TRACE</span></span><br></pre></td></tr></table></figure><p>进一步，要记录具体语句的日志可以这样做：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">log4j.logger.org.mybatis.example.BlogMapper.selectBlog=TRACE</span></span><br></pre></td></tr></table></figure><p>看到了吧，两种配置没差别！</p><p>配置文件<code>log4j.properties</code>的余下内容是针对日志格式的，这一内容已经超出本 文档范围。关于Log4J的更多内容，可以参考Log4J的网站。不过，可以简单试一下看看，不同的配置 会产生什么不一样的效果。</p><blockquote><p>作者:W3Cschool<br>来源:<a href="https://www.w3cschool.cn/mybatis/ogqn1im5.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.w3cschool.cn/mybatis/ogqn1im5.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
            <tag> MyBatis基础教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis SQL语句构建器</title>
      <link href="/mybatis-sql-statement-builder/"/>
      <url>/mybatis-sql-statement-builder/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL语句构建器"><a href="#SQL语句构建器" class="headerlink" title="SQL语句构建器"></a>SQL语句构建器</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Java程序员面对的最痛苦的事情之一就是在Java代码中嵌入SQL语句。这么来做通常是由于SQL语句需要动态来生成-否则可以将它们放到外部文件或者存储过程中。正如你已经看到的那样，MyBatis在它的XML映射特性中有一个强大的动态SQL生成方案。但有时在Java代码内部创建SQL语句也是必要的。此时，MyBatis有另外一个特性可以帮到你，在减少典型的加号,引号,新行,格式化问题和嵌入条件来处理多余的逗号或 AND 连接词之前。事实上，在Java代码中来动态生成SQL代码就是一场噩梦。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String sql = "<span class="keyword">SELECT</span> P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME, <span class="string">"</span></span><br><span class="line"><span class="string">"</span>P.LAST_NAME,P.CREATED_ON, P.UPDATED_ON <span class="string">" +</span></span><br><span class="line"><span class="string">"</span><span class="keyword">FROM</span> PERSON P, <span class="keyword">ACCOUNT</span> A <span class="string">" +</span></span><br><span class="line"><span class="string">"</span><span class="keyword">INNER</span> <span class="keyword">JOIN</span> DEPARTMENT D <span class="keyword">on</span> D.ID = P.DEPARTMENT_ID <span class="string">" +</span></span><br><span class="line"><span class="string">"</span><span class="keyword">INNER</span> <span class="keyword">JOIN</span> COMPANY C <span class="keyword">on</span> D.COMPANY_ID = C.ID <span class="string">" +</span></span><br><span class="line"><span class="string">"</span><span class="keyword">WHERE</span> (P.ID = A.ID <span class="keyword">AND</span> P.FIRST_NAME <span class="keyword">like</span> ?) <span class="string">" +</span></span><br><span class="line"><span class="string">"</span><span class="keyword">OR</span> (P.LAST_NAME <span class="keyword">like</span> ?) <span class="string">" +</span></span><br><span class="line"><span class="string">"</span><span class="keyword">GROUP</span> <span class="keyword">BY</span> P.ID <span class="string">" +</span></span><br><span class="line"><span class="string">"</span><span class="keyword">HAVING</span> (P.LAST_NAME <span class="keyword">like</span> ?) <span class="string">" +</span></span><br><span class="line"><span class="string">"</span><span class="keyword">OR</span> (P.FIRST_NAME <span class="keyword">like</span> ?) <span class="string">" +</span></span><br><span class="line"><span class="string">"</span><span class="keyword">ORDER</span> <span class="keyword">BY</span> P.ID, P.FULL_NAME<span class="string">";</span></span><br></pre></td></tr></table></figure><h3 id="The-Solution"><a href="#The-Solution" class="headerlink" title="The Solution"></a>The Solution</h3><p>MyBatis 3提供了方便的工具类来帮助解决该问题。使用SQL类，简单地创建一个实例来调用方法生成SQL语句。上面示例中的问题就像重写SQL类那样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">selectPersonSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SQL() &#123;&#123;</span><br><span class="line">    SELECT(<span class="string">"P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME"</span>);</span><br><span class="line">    SELECT(<span class="string">"P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON"</span>);</span><br><span class="line">    FROM(<span class="string">"PERSON P"</span>);</span><br><span class="line">    FROM(<span class="string">"ACCOUNT A"</span>);</span><br><span class="line">    INNER_JOIN(<span class="string">"DEPARTMENT D on D.ID = P.DEPARTMENT_ID"</span>);</span><br><span class="line">    INNER_JOIN(<span class="string">"COMPANY C on D.COMPANY_ID = C.ID"</span>);</span><br><span class="line">    WHERE(<span class="string">"P.ID = A.ID"</span>);</span><br><span class="line">    WHERE(<span class="string">"P.FIRST_NAME like ?"</span>);</span><br><span class="line">    OR();</span><br><span class="line">    WHERE(<span class="string">"P.LAST_NAME like ?"</span>);</span><br><span class="line">    GROUP_BY(<span class="string">"P.ID"</span>);</span><br><span class="line">    HAVING(<span class="string">"P.LAST_NAME like ?"</span>);</span><br><span class="line">    OR();</span><br><span class="line">    HAVING(<span class="string">"P.FIRST_NAME like ?"</span>);</span><br><span class="line">    ORDER_BY(<span class="string">"P.ID"</span>);</span><br><span class="line">    ORDER_BY(<span class="string">"P.FULL_NAME"</span>);</span><br><span class="line">  &#125;&#125;.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例中有什么特殊之处？当你仔细看时，那不用担心偶然间重复出现的”AND”关键字，或者在”WHERE”和”AND”之间的选择，抑或什么都不选。该SQL类非常注意”WHERE”应该出现在何处，哪里又应该使用”AND”，还有所有的字符串链接。</p><h3 id="SQL类"><a href="#SQL类" class="headerlink" title="SQL类"></a>SQL类</h3><p>这里给出一些示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anonymous inner class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deletePersonSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SQL() &#123;&#123;</span><br><span class="line">    DELETE_FROM(<span class="string">"PERSON"</span>);</span><br><span class="line">    WHERE(<span class="string">"ID = $&#123;id&#125;"</span>);</span><br><span class="line">  &#125;&#125;.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builder / Fluent style</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">insertPersonSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String sql = <span class="keyword">new</span> SQL()</span><br><span class="line">    .INSERT_INTO(<span class="string">"PERSON"</span>)</span><br><span class="line">    .VALUES(<span class="string">"ID, FIRST_NAME"</span>, <span class="string">"$&#123;id&#125;, $&#123;firstName&#125;"</span>)</span><br><span class="line">    .VALUES(<span class="string">"LAST_NAME"</span>, <span class="string">"$&#123;lastName&#125;"</span>)</span><br><span class="line">    .toString();</span><br><span class="line">  <span class="keyword">return</span> sql;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// With conditionals (note the final parameters, required for the anonymous inner class to access them)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">selectPersonLike</span><span class="params">(<span class="keyword">final</span> String id, <span class="keyword">final</span> String firstName, <span class="keyword">final</span> String lastName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SQL() &#123;&#123;</span><br><span class="line">    SELECT(<span class="string">"P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME"</span>);</span><br><span class="line">    FROM(<span class="string">"PERSON P"</span>);</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span>) &#123;</span><br><span class="line">      WHERE(<span class="string">"P.ID like $&#123;id&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (firstName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      WHERE(<span class="string">"P.FIRST_NAME like $&#123;firstName&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      WHERE(<span class="string">"P.LAST_NAME like $&#123;lastName&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ORDER_BY(<span class="string">"P.LAST_NAME"</span>);</span><br><span class="line">  &#125;&#125;.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deletePersonSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SQL() &#123;&#123;</span><br><span class="line">    DELETE_FROM(<span class="string">"PERSON"</span>);</span><br><span class="line">    WHERE(<span class="string">"ID = $&#123;id&#125;"</span>);</span><br><span class="line">  &#125;&#125;.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">insertPersonSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SQL() &#123;&#123;</span><br><span class="line">    INSERT_INTO(<span class="string">"PERSON"</span>);</span><br><span class="line">    VALUES(<span class="string">"ID, FIRST_NAME"</span>, <span class="string">"$&#123;id&#125;, $&#123;firstName&#125;"</span>);</span><br><span class="line">    VALUES(<span class="string">"LAST_NAME"</span>, <span class="string">"$&#123;lastName&#125;"</span>);</span><br><span class="line">  &#125;&#125;.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updatePersonSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SQL() &#123;&#123;</span><br><span class="line">    UPDATE(<span class="string">"PERSON"</span>);</span><br><span class="line">    SET(<span class="string">"FIRST_NAME = $&#123;firstName&#125;"</span>);</span><br><span class="line">    WHERE(<span class="string">"ID = $&#123;id&#125;"</span>);</span><br><span class="line">  &#125;&#125;.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>SELECT(String)</code></td><td>开始或插入到 <code>SELECT</code>子句。 可以被多次调用，参数也会添加到 <code>SELECT</code>子句。 参数通常使用逗号分隔的列名和别名列表，但也可以是数据库驱动程序接受的任意类型。</td></tr><tr><td><code>SELECT_DISTINCT(String)</code></td><td>开始或插入到 <code>SELECT</code>子句， 也可以插入 <code>DISTINCT</code>关键字到生成的查询语句中。 可以被多次调用，参数也会添加到 <code>SELECT</code>子句。 参数通常使用逗号分隔的列名和别名列表，但也可以是数据库驱动程序接受的任意类型。</td></tr><tr><td><code>FROM(String)</code></td><td>开始或插入到 <code>FROM</code>子句。 可以被多次调用，参数也会添加到 <code>FROM</code>子句。 参数通常是表名或别名，也可以是数据库驱动程序接受的任意类型。</td></tr><tr><td><code>JOIN(String)</code>,<code>INNER_JOIN(String)</code>,<code>LEFT_OUTER_JOIN(String)</code>,<code>RIGHT_OUTER_JOIN(String)</code></td><td>基于调用的方法，添加新的合适类型的 <code>JOIN</code>子句。 参数可以包含由列命和join on条件组合成标准的join。</td></tr><tr><td><code>WHERE(String)</code></td><td>插入新的 <code>WHERE</code>子句条件， 由<code>AND</code>链接。可以多次被调用，每次都由<code>AND</code>来链接新条件。使用 <code>OR()</code> 来分隔<code>OR</code>。</td></tr><tr><td><code>OR()</code></td><td>使用<code>OR</code>来分隔当前的 <code>WHERE</code>子句条件。 可以被多次调用，但在一行中多次调用或生成不稳定的<code>SQL</code>。</td></tr><tr><td><code>AND()</code></td><td>使用<code>AND</code>来分隔当前的 <code>WHERE</code>子句条件。 可以被多次调用，但在一行中多次调用或生成不稳定的<code>SQL</code>。因为 <code>WHERE</code> 和 <code>HAVING</code> 二者都会自动链接 <code>AND</code>, 这是非常罕见的方法，只是为了完整性才被使用。</td></tr><tr><td><code>GROUP_BY(String)</code></td><td>插入新的 <code>GROUP BY</code>子句元素，由逗号连接。 可以被多次调用，每次都由逗号连接新的条件。</td></tr><tr><td><code>HAVING(String)</code></td><td>插入新的 <code>HAVING</code>子句条件。 由AND连接。可以被多次调用，每次都由<code>AND</code>来连接新的条件。使用 <code>OR()</code> 来分隔<code>OR</code>.</td></tr><tr><td><code>ORDER_BY(String)</code></td><td>插入新的 <code>ORDER BY</code>子句元素， 由逗号连接。可以多次被调用，每次由逗号连接新的条件。</td></tr><tr><td><code>DELETE_FROM(String)</code></td><td>开始一个delete语句并指定需要从哪个表删除的表名。通常它后面都会跟着WHERE语句！</td></tr><tr><td><code>INSERT_INTO(String)</code></td><td>开始一个insert语句并指定需要插入数据的表名。后面都会跟着一个或者多个VALUES()。</td></tr><tr><td><code>SET(String)</code></td><td>针对update语句，插入到”set”列表中</td></tr><tr><td><code>UPDATE(String)</code></td><td>开始一个update语句并指定需要更新的表明。后面都会跟着一个或者多个SET()，通常也会有一个WHERE()。</td></tr><tr><td><code>VALUES(String, String)</code></td><td>插入到insert语句中。第一个参数是要插入的列名，第二个参数则是该列的值。</td></tr></tbody></table><h3 id="SqlBuilder-和-SelectBuilder-已经废弃"><a href="#SqlBuilder-和-SelectBuilder-已经废弃" class="headerlink" title="SqlBuilder 和 SelectBuilder (已经废弃)"></a>SqlBuilder 和 SelectBuilder (已经废弃)</h3><p>在3.2版本之前，我们使用了一点不同的做法，通过实现ThreadLocal变量来掩盖一些导致Java DSL麻烦的语言限制。但这种方式已经废弃了，现代的框架都欢迎人们使用构建器类型和匿名内部类的想法。因此，SelectBuilder 和 SqlBuilder 类都被废弃了。</p><p>下面的方法仅仅适用于废弃的SqlBuilder 和 SelectBuilder 类。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>BEGIN()</code> / <code>RESET()</code></td><td>这些方法清空SelectBuilder类的ThreadLocal状态，并且准备一个新的构建语句。开始新的语句时， <code>BEGIN()</code>读取得最好。 由于一些原因（在某些条件下，也许是逻辑需要一个完全不同的语句），在执行中清理语句 <code>RESET()</code>读取得最好。</td></tr><tr><td><code>SQL()</code></td><td>返回生成的 <code>SQL()</code> 并重置 <code>SelectBuilder</code> 状态 (好像 <code>BEGIN()</code> 或 <code>RESET()</code> 被调用了). 因此，该方法只能被调用一次！</td></tr></tbody></table><p>SelectBuilder 和 SqlBuilder 类并不神奇，但是知道它们如何工作也是很重要的。 SelectBuilder 使用 SqlBuilder 使用了静态导入和ThreadLocal变量的组合来开启整洁语法，可以很容易地和条件交错。使用它们，静态导入类的方法即可，就像这样(一个或其它，并非两者):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.ibatis.jdbc.SelectBuilder.*;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.ibatis.jdbc.SqlBuilder.*;</span><br></pre></td></tr></table></figure><p>这就允许像下面这样来创建方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DEPRECATED */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">selectBlogsSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BEGIN(); <span class="comment">// Clears ThreadLocal variable</span></span><br><span class="line">  SELECT(<span class="string">"*"</span>);</span><br><span class="line">  FROM(<span class="string">"BLOG"</span>);</span><br><span class="line">  <span class="keyword">return</span> SQL();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DEPRECATED */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">selectPersonSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BEGIN(); <span class="comment">// Clears ThreadLocal variable</span></span><br><span class="line">  SELECT(<span class="string">"P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME"</span>);</span><br><span class="line">  SELECT(<span class="string">"P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON"</span>);</span><br><span class="line">  FROM(<span class="string">"PERSON P"</span>);</span><br><span class="line">  FROM(<span class="string">"ACCOUNT A"</span>);</span><br><span class="line">  INNER_JOIN(<span class="string">"DEPARTMENT D on D.ID = P.DEPARTMENT_ID"</span>);</span><br><span class="line">  INNER_JOIN(<span class="string">"COMPANY C on D.COMPANY_ID = C.ID"</span>);</span><br><span class="line">  WHERE(<span class="string">"P.ID = A.ID"</span>);</span><br><span class="line">  WHERE(<span class="string">"P.FIRST_NAME like ?"</span>);</span><br><span class="line">  OR();</span><br><span class="line">  WHERE(<span class="string">"P.LAST_NAME like ?"</span>);</span><br><span class="line">  GROUP_BY(<span class="string">"P.ID"</span>);</span><br><span class="line">  HAVING(<span class="string">"P.LAST_NAME like ?"</span>);</span><br><span class="line">  OR();</span><br><span class="line">  HAVING(<span class="string">"P.FIRST_NAME like ?"</span>);</span><br><span class="line">  ORDER_BY(<span class="string">"P.ID"</span>);</span><br><span class="line">  ORDER_BY(<span class="string">"P.FULL_NAME"</span>);</span><br><span class="line">  <span class="keyword">return</span> SQL();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>作者:W3Cschool<br>来源:<a href="https://www.w3cschool.cn/mybatis/k8ay1im3.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.w3cschool.cn/mybatis/k8ay1im3.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
            <tag> MyBatis基础教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis Java API</title>
      <link href="/mybatis-java-api/"/>
      <url>/mybatis-java-api/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h2><p>既然你已经知道如何配置 MyBatis 和创建映射文件,你就已经准备好来提升技能了。 MyBatis 的 Java API 就是你收获你所做的努力的地方。正如你即将看到的,和 JDBC 相比, MyBatis 很大程度简化了你的代码而且保持简洁,很容易理解和维护。MyBatis 3 已经引入 了很多重要的改进来使得 SQL 映射更加优秀。</p><h2 id="应用目录结构"><a href="#应用目录结构" class="headerlink" title="应用目录结构"></a>应用目录结构</h2><p>在我们深入 Java API 之前,理解关于目录结构的最佳实践是很重要的。MyBatis 非常灵 活, 你可以用你自己的文件来做几乎所有的事情。 但是对于任一框架, 都有一些最佳的方式。</p><p>让我们看一下典型应用的目录结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;my_application</span><br><span class="line">  &#x2F;bin</span><br><span class="line">  &#x2F;devlib</span><br><span class="line">  &#x2F;lib                &lt;-- MyBatis *.jar文件在这里。</span><br><span class="line">  &#x2F;src</span><br><span class="line">    &#x2F;org&#x2F;myapp&#x2F;</span><br><span class="line">      &#x2F;action</span><br><span class="line">      &#x2F;data           &lt;-- MyBatis配置文件在这里, 包括映射器类, XML配置, XML映射文件。</span><br><span class="line">        &#x2F;mybatis-config.xml</span><br><span class="line">        &#x2F;BlogMapper.java</span><br><span class="line">        &#x2F;BlogMapper.xml</span><br><span class="line">      &#x2F;model</span><br><span class="line">      &#x2F;service</span><br><span class="line">      &#x2F;view</span><br><span class="line">    &#x2F;properties       &lt;-- 在你XML中配置的属性 文件在这里。</span><br><span class="line">  &#x2F;test</span><br><span class="line">    &#x2F;org&#x2F;myapp&#x2F;</span><br><span class="line">      &#x2F;action</span><br><span class="line">      &#x2F;data</span><br><span class="line">      &#x2F;model</span><br><span class="line">      &#x2F;service</span><br><span class="line">      &#x2F;view</span><br><span class="line">    &#x2F;properties</span><br><span class="line">  &#x2F;web</span><br><span class="line">    &#x2F;WEB-INF</span><br><span class="line">      &#x2F;web.xml</span><br></pre></td></tr></table></figure><p>Remember, these are preferences, not requirements, but others will thank you for using a common directory structure.</p><p>这部分内容剩余的示例将假设你使用了这种目录结构。</p><h2 id="SqlSessions"><a href="#SqlSessions" class="headerlink" title="SqlSessions"></a>SqlSessions</h2><p>使用 MyBatis 的主要 Java 接口就是 SqlSession。尽管你可以使用这个接口执行命令,获 取映射器和管理事务。我们会讨论 SqlSession 本身更多,但是首先我们还是要了解如果获取 一个 SqlSession 实例。SqlSessions 是由 SqlSessionFactory 实例创建的。SqlSessionFactory 对 象 包 含 创 建 SqlSession 实 例 的 所 有 方 法 。 而 SqlSessionFactory 本 身 是 由 SqlSessionFactoryBuilder 创建的,它可以从 XML 配置,注解或手动配置 Java 来创建 SqlSessionFactory。</p><p>NOTE When using MyBatis with a dependency injection framework like Spring or Guice, SqlSessions are created and injected by the DI framework so you don’t need to use the SqlSessionFactoryBuilder or SqlSessionFactory and can go directly to the SqlSession section. Please refer to the MyBatis-Spring or MyBatis-Guice manuals for further info.</p><h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><p>SqlSessionFactoryBuilder 有五个 build()方法,每一种都允许你从不同的资源中创建一个 SqlSession 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream)</span></span></span><br><span class="line"><span class="function">SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment)</span></span></span><br><span class="line"><span class="function">SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, Properties properties)</span></span></span><br><span class="line"><span class="function">SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String env, Properties props)</span></span></span><br><span class="line"><span class="function">SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span></span></span><br></pre></td></tr></table></figure><p>第一种方法是最常用的,它使用了一个参照了 XML 文档或上面讨论过的更特定的 mybatis-config.xml 文件的 Reader 实例。 可选的参数是 environment 和 properties。 Environment 决定加载哪种环境,包括数据源和事务管理器。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"production"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"MANAGED"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"JNDI"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你调用了 一个使用 environment 参数 方 式的 build 方法, 那么 MyBatis 将会使用 configuration 对象来配置这个 environment。 当然, 如果你指定了一个不合法的 environment, 你会得到错误提示。 如果你调用了其中之一没有 environment 参数的 build 方法, 那么就使用 默认的 environment(在上面的示例中就会指定为 default=”development”)。</p><p>如果你调用了使用 properties 实例的方法,那么 MyBatis 就会加载那些 properties(属性 配置文件) ,并你在你配置中可使用它们。那些属性可以用${propName}语法形式多次用在 配置文件中。</p><p>回想一下,属性可以从 mybatis-config.xml 中被引用,或者直接指定它。因此理解优先 级是很重要的。我们在文档前面已经提及它了,但是这里要再次重申:</p><p>如果一个属性存在于这些位置,那么 MyBatis 将会按找下面的顺序来加载它们:</p><ul><li>在 properties 元素体中指定的属性首先被读取,</li><li>从 properties 元素的类路径 resource 或 url 指定的属性第二个被读取, 可以覆盖已经 指定的重复属性,</li><li>作为方法参 数传递 的属性最 后被读 取,可以 覆盖已 经从 properties 元 素体和 resource/url 属性中加载的任意重复属性。</li></ul><p>因此,最高优先级的属性是通过方法参数传递的,之后是 resource/url 属性指定的,最 后是在 properties 元素体中指定的属性。</p><p>总结一下,前四个方法很大程度上是相同的,但是由于可以覆盖,就允许你可选地指定 environment 和/或 properties。 这里给出一个从 mybatis-config.xml 文件创建 SqlSessionFactory 的示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String **resource** = <span class="string">"org/mybatis/builder/mybatis-config.xml"</span>;</span><br><span class="line">InputStream **inputStream** = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactoryBuilder **builder** = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">SqlSessionFactory **factory** = builder.build(inputStream);</span><br></pre></td></tr></table></figure><p>注意这里我们使用了 Resources 工具类,这个类在 org.mybatis.io 包中。Resources 类正 如其名,会帮助你从类路径下,文件系统或一个 web URL 加载资源文件。看一下这个类的 源代码或者通过你的 IDE 来查看,就会看到一整套有用的方法。这里给出一个简表:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">URL <span class="title">getResourceURL</span><span class="params">(String resource)</span></span></span><br><span class="line"><span class="function">URL <span class="title">getResourceURL</span><span class="params">(ClassLoader loader, String resource)</span></span></span><br><span class="line"><span class="function">InputStream <span class="title">getResourceAsStream</span><span class="params">(String resource)</span></span></span><br><span class="line"><span class="function">InputStream <span class="title">getResourceAsStream</span><span class="params">(ClassLoader loader, String resource)</span></span></span><br><span class="line"><span class="function">Properties <span class="title">getResourceAsProperties</span><span class="params">(String resource)</span></span></span><br><span class="line"><span class="function">Properties <span class="title">getResourceAsProperties</span><span class="params">(ClassLoader loader, String resource)</span></span></span><br><span class="line"><span class="function">Reader <span class="title">getResourceAsReader</span><span class="params">(String resource)</span></span></span><br><span class="line"><span class="function">Reader <span class="title">getResourceAsReader</span><span class="params">(ClassLoader loader, String resource)</span></span></span><br><span class="line"><span class="function">File <span class="title">getResourceAsFile</span><span class="params">(String resource)</span></span></span><br><span class="line"><span class="function">File <span class="title">getResourceAsFile</span><span class="params">(ClassLoader loader, String resource)</span></span></span><br><span class="line"><span class="function">InputStream <span class="title">getUrlAsStream</span><span class="params">(String urlString)</span></span></span><br><span class="line"><span class="function">Reader <span class="title">getUrlAsReader</span><span class="params">(String urlString)</span></span></span><br><span class="line"><span class="function">Properties <span class="title">getUrlAsProperties</span><span class="params">(String urlString)</span></span></span><br><span class="line"><span class="function">Class <span class="title">classForName</span><span class="params">(String className)</span></span></span><br></pre></td></tr></table></figure><p>最后一个 build 方法使用了一个 Configuration 实例。configuration 类包含你可能需要了 解 SqlSessionFactory 实例的所有内容。Configuration 类对于配置的自查很有用,包含查找和 操作 SQL 映射(不推荐使用,因为应用正接收请求) 。configuration 类有所有配置的开关, 这些你已经了解了,只在 Java API 中露出来。这里有一个简单的示例,如何手动配置 configuration 实例,然后将它传递给 build()方法来创建 SqlSessionFactory。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DataSource dataSource = BaseDataTest.createBlogDataSource();</span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line"></span><br><span class="line">Environment environment = <span class="keyword">new</span> Environment(<span class="string">"development"</span>, transactionFactory, dataSource);</span><br><span class="line"></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br><span class="line">configuration.setLazyLoadingEnabled(<span class="keyword">true</span>);</span><br><span class="line">configuration.setEnhancementEnabled(<span class="keyword">true</span>);</span><br><span class="line">configuration.getTypeAliasRegistry().registerAlias(Blog<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">configuration.getTypeAliasRegistry().registerAlias(Post<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">configuration.getTypeAliasRegistry().registerAlias(Author<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">configuration.addMapper(BoundBlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">configuration.addMapper(BoundAuthorMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">SqlSessionFactory factory = builder.build(configuration);</span><br></pre></td></tr></table></figure><p>现在你有一个 SqlSessionFactory,可以用来创建 SqlSession 实例。</p><h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p>SqlSessionFactory 有六个方法可以用来创建 SqlSession 实例。通常来说,如何决定是你 选择下面这些方法时:</p><ul><li><strong>Transaction (事务)</strong>: 你想为 session 使用事务或者使用自动提交(通常意味着很多 数据库和/或 JDBC 驱动没有事务)?</li><li><strong>Connection (连接)</strong>: 你想 MyBatis 获得来自配置的数据源的连接还是提供你自己</li><li><strong>Execution (执行)</strong>: 你想 MyBatis 复用预处理语句和/或批量更新语句(包括插入和 删除)?</li></ul><p>重载的 openSession()方法签名设置允许你选择这些可选中的任何一个组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">()</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(Connection connection)</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(TransactionIsolationLevel level)</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType,TransactionIsolationLevel level)</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType)</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType, <span class="keyword">boolean</span> autoCommit)</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType, Connection connection)</span></span></span><br><span class="line"><span class="function">Configuration <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>默认的 openSession()方法没有参数,它会创建有如下特性的 SqlSession:</p><ul><li>会开启一个事务(也就是不自动提交)</li><li>连接对象会从由活动环境配置的数据源实例中得到。</li><li>事务隔离级别将会使用驱动或数据源的默认设置。</li><li>预处理语句不会被复用,也不会批量处理更新。</li></ul><p>这些方法大都可以自我解释的。 开启自动提交, “true” 传递 给可选的 autoCommit 参数。 提供自定义的连接,传递一个 Connection 实例给 connection 参数。注意没有覆盖同时设置 Connection 和 autoCommit 两者的方法,因为 MyBatis 会使用当前 connection 对象提供的设 置。 MyBatis 为事务隔离级别调用使用一个 Java 枚举包装器, 称为 TransactionIsolationLevel, 否则它们按预期的方式来工作,并有 JDBC 支持的 5 级 ( NONE,READ_UNCOMMITTED,READ_COMMITTED,REPEA TABLE_READ,SERIALIZA BLE)</p><p>还有一个可能对你来说是新见到的参数,就是 ExecutorType。这个枚举类型定义了 3 个 值:</p><ul><li><code>ExecutorType.SIMPLE</code>: 这个执行器类型不做特殊的事情。它为每个语句的执行创建一个新的预处理语句。</li><li><code>ExecutorType.REUSE</code>: 这个执行器类型会复用预处理语句。</li><li><code>ExecutorType.BATCH</code>: 这个执行器会批量执行所有更新语句,如果 SELECT 在它们中间执行还会标定它们是 必须的,来保证一个简单并易于理解的行为。</li></ul><p>注意 在 SqlSessionFactory 中还有一个方法我们没有提及,就是 getConfiguration()。这 个方法会返回一个 Configuration 实例,在运行时你可以使用它来自检 MyBatis 的配置。</p><p>注意 如果你已经使用之前版本 MyBatis,你要回忆那些 session,transaction 和 batch 都是分离的。现在和以往不同了,这些都包含在 session 的范围内了。你需要处理分开处理 事务或批量操作来得到它们的效果。</p><h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><p>如上面所提到的,SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会发现 所有执行语句的方法,提交或回滚事务,还有获取映射器实例。</p><p>在 SqlSession 类中有超过 20 个方法,所以将它们分开成易于理解的组合。</p><h5 id="语句执行方法"><a href="#语句执行方法" class="headerlink" title="语句执行方法"></a>语句执行方法</h5><p>这些方法被用来执行定义在 SQL 映射的 XML 文件中的 SELECT,INSERT,UPDA E T 和 DELETE 语句。它们都会自行解释,每一句都使用语句的 ID 属性和参数对象,参数可以 是原生类型(自动装箱或包装类) ,JavaBean,POJO 或 Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function"> List <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function"> Map <span class="title">selectMap</span><span class="params">(String statement, Object parameter, String mapKey)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement, Object parameter)</span></span></span><br></pre></td></tr></table></figure><p>selectOne 和 selectList 的不同仅仅是 selectOne 必须返回一个对象。 如果多余一个, 或者 没有返回 (或返回了 null) 那么就会抛出异常。 , 如果你不知道需要多少对象, 使用 selectList。</p><p>如果你想检查一个对象是否存在,那么最好返回统计数(0 或 1) 。因为并不是所有语句都需 要参数,这些方法都是有不同重载版本的,它们可以不需要参数对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">T <span class="title">selectOne</span><span class="params">(String statement)</span></span></span><br><span class="line"><span class="function"> List <span class="title">selectList</span><span class="params">(String statement)</span></span></span><br><span class="line"><span class="function"> Map <span class="title">selectMap</span><span class="params">(String statement, String mapKey)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement)</span></span></span><br></pre></td></tr></table></figure><p>最后,还有查询方法的三个高级版本,它们允许你限制返回行数的范围,或者提供自定 义结果控制逻辑,这通常用于大量的数据集合。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">E</span>&gt;</span> List<span class="tag">&lt;<span class="name">E</span>&gt;</span> selectList (String statement, Object parameter, RowBounds rowBounds)</span><br><span class="line"><span class="tag">&lt;<span class="name">K,V</span>&gt;</span> Map<span class="tag">&lt;<span class="name">K,V</span>&gt;</span> selectMap(String statement, Object parameter, String mapKey, RowBounds rowbounds)</span><br><span class="line">void select (String statement, Object parameter, ResultHandler<span class="tag">&lt;<span class="name">T</span>&gt;</span> handler)</span><br><span class="line">void select (String statement, Object parameter, RowBounds rowBounds, ResultHandler<span class="tag">&lt;<span class="name">T</span>&gt;</span> handler)</span><br></pre></td></tr></table></figure><p>RowBounds 参数会告诉 MyBatis 略过指定数量的记录,还有限制返回结果的数量。 RowBounds 类有一个构造方法来接收 offset 和 limit,否则是不可改变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> offset = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> limit = <span class="number">25</span>;</span><br><span class="line">RowBounds rowBounds = <span class="keyword">new</span> RowBounds(offset, limit);</span><br></pre></td></tr></table></figure><p>不同的驱动会实现这方面的不同级别的效率。对于最佳的表现,使用结果集类型的 SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE(或句话说:不是 FORWARD_ONLY)。</p><p>ResultHandler 参数允许你按你喜欢的方式处理每一行。你可以将它添加到 List 中,创 建 Map, 或抛出每个结果而不是只保留总计。 Set 你可以使用 ResultHandler 做很多漂亮的事, 那就是 MyBatis 内部创建结果集列表。</p><p>它的接口很简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(ResultContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ResultContext 参数给你访问结果对象本身的方法, 大量结果对象被创建, 你可以使用布 尔返回值的 stop()方法来停止 MyBatis 加载更多的结果。</p><h5 id="事务控制方法"><a href="#事务控制方法" class="headerlink" title="事务控制方法"></a>事务控制方法</h5><p>控制事务范围有四个方法。 当然, 如果你已经选择了自动提交或你正在使用外部事务管 理器,这就没有任何效果了。然而,如果你正在使用 JDBC 事务管理员,由 Connection 实 例来控制,那么这四个方法就会派上用场:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> force)</span></span></span><br></pre></td></tr></table></figure><p>默认情况下 MyBatis 不会自动提交事务, 除非它侦测到有插入, 更新或删除操作改变了 数据库。如果你已经做出了一些改变而没有使用这些方法,那么你可以传递 true 到 commit 和 rollback 方法来保证它会被提交(注意,你不能在自动提交模式下强制 session,或者使用 了外部事务管理器时) 。很多时候你不用调用 rollback(),因为如果你没有调用 commit 时 MyBatis 会替你完成。然而,如果你需要更多对多提交和回滚都可能的 session 的细粒度控 制,你可以使用回滚选择来使它成为可能。</p><p>NOTE MyBatis-Spring and MyBatis-Guice provide declarative transaction handling. So if you are using MyBatis with Spring or Guice please refer to their specific manuals.</p><h5 id="清理-Session-级的缓存"><a href="#清理-Session-级的缓存" class="headerlink" title="清理 Session 级的缓存"></a>清理 Session 级的缓存</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>SqlSession 实例有一个本地缓存在执行 update,commit,rollback 和 close 时被清理。要 明确地关闭它(获取打算做更多的工作) ,你可以调用 clearCache()。</p><h5 id="确保-SqlSession-被关闭"><a href="#确保-SqlSession-被关闭" class="headerlink" title="确保 SqlSession 被关闭"></a>确保 SqlSession 被关闭</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>你必须保证的最重要的事情是你要关闭所打开的任何 session。保证做到这点的最佳方 式是下面的工作模式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// following 3 lines pseudocod for "doing some work"</span></span><br><span class="line">    session.insert(...);</span><br><span class="line">    session.update(...);</span><br><span class="line">    session.delete(...);</span><br><span class="line">    session.commit();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Or, If you are using jdk 1.7+ and MyBatis 3.2+, you can use the try-with-resources statement:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="comment">// following 3 lines pseudocode for "doing some work"</span></span><br><span class="line">    session.insert(...);</span><br><span class="line">    session.update(...);</span><br><span class="line">    session.delete(...);</span><br><span class="line">    session.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 就像 SqlSessionFactory,你可以通过调用 getConfiguration()方法获得 SqlSession 使用的 Configuration 实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Configuration <span class="title">getConfiguration</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h5 id="使用映射器"><a href="#使用映射器" class="headerlink" title="使用映射器"></a>使用映射器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">getMapper</span><span class="params">(Class type)</span></span></span><br></pre></td></tr></table></figure><p>上述的各个 insert,update,delete 和 select 方法都很强大,但也有些繁琐,没有类型安 全,对于你的 IDE 也没有帮助,还有可能的单元测试。在上面的入门章节中我们已经看到 了一个使用映射器的示例。</p><p>因此, 一个更通用的方式来执行映射语句是使用映射器类。 一个映射器类就是一个简单 的接口,其中的方法定义匹配于 SqlSession 方法。下面的示例展示了一些方法签名和它们是 如何映射到 SqlSession 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthorMapper</span> </span>&#123;</span><br><span class="line">  <span class="comment">// (Author) selectOne("selectAuthor",5);</span></span><br><span class="line">  <span class="function">Author <span class="title">selectAuthor</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">  <span class="comment">// (List) selectList("selectAuthors")</span></span><br><span class="line">  <span class="function">List <span class="title">selectAuthors</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// (Map) selectMap("selectAuthors", "id")</span></span><br><span class="line">  <span class="meta">@MapKey</span>(<span class="string">"id"</span>)</span><br><span class="line">  <span class="function">Map <span class="title">selectAuthors</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// insert("insertAuthor", author)</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">insertAuthor</span><span class="params">(Author author)</span></span>;</span><br><span class="line">  <span class="comment">// updateAuthor("updateAuthor", author)</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">updateAuthor</span><span class="params">(Author author)</span></span>;</span><br><span class="line">  <span class="comment">// delete("deleteAuthor",5)</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">deleteAuthor</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之, 每个映射器方法签名应该匹配相关联的 SqlSession 方法, 而没有字符串参数 ID。 相反,方法名必须匹配映射语句的 ID。</p><p>此外,返回类型必须匹配期望的结果类型。所有常用的类型都是支持的,包括:原生类 型,Map,POJO 和 JavaBean。</p><p>映射器接口不需要去实现任何接口或扩展任何类。 只要方法前面可以被用来唯一标识对 应的映射语句就可以了。</p><p>映射器接口可以扩展其他接口。当使用 XML 来构建映射器接口时要保证在合适的命名 空间中有语句。 而且, 唯一的限制就是你不能在两个继承关系的接口中有相同的方法签名 (这 也是不好的想法)。</p><p>你可以传递多个参数给一个映射器方法。 如果你这样做了, 默认情况下它们将会以它们 在参数列表中的位置来命名,比如:#{param1},#{param2}等。如果你想改变参数的名称(只在多参数 情况下) ,那么你可以在参数上使用@Param(“paramName”)注解。</p><p>你也可以给方法传递一个 RowBounds 实例来限制查询结果。</p><h5 id="映射器注解"><a href="#映射器注解" class="headerlink" title="映射器注解"></a>映射器注解</h5><p>因为最初设计时,MyBatis 是一个 XML 驱动的框架。配置信息是基于 XML 的,而且 映射语句也是定义在 XML 中的。而到了 MyBatis 3,有新的可用的选择了。MyBatis 3 构建 在基于全面而且强大的 Java 配置 API 之上。这个配置 API 是基于 XML 的 MyBatis 配置的 基础,也是新的基于注解配置的基础。注解提供了一种简单的方式来实现简单映射语句,而 不会引入大量的开销。</p><p>注意 不幸的是,Java 注解限制了它们的表现和灵活。尽管很多时间都花调查,设计和 实验上,最强大的 MyBatis 映射不能用注解来构建,那并不可笑。C#属性(做示例)就没 有这些限制,因此 MyBatis.NET 将会比 XML 有更丰富的选择。也就是说,基于 Java 注解 的配置离不开它的特性。</p><p><strong>注解有下面这些:</strong></p><table><thead><tr><th>注解</th><th>目标</th><th>相对应的 XML</th><th>描述</th></tr></thead><tbody><tr><td><code>@CacheNamespace</code></td><td><code>类</code></td><td>``</td><td>为给定的命名空间 (比如类) 配置缓存。 属性:implemetation,eviction, flushInterval,size 和 readWrite。</td></tr><tr><td><code>@CacheNamespaceRef</code></td><td><code>类</code></td><td>``</td><td>参照另外一个命名空间的缓存来使用。 属性:value,应该是一个名空间的字 符串值(也就是类的完全限定名) 。</td></tr><tr><td><code>@ConstructorArgs</code></td><td><code>Method</code></td><td>``</td><td>收集一组结果传递给一个劫夺对象的 构造方法。属性:value,是形式参数 的数组。</td></tr><tr><td><code>@Arg</code></td><td><code>方法</code></td><td></td><td>单 独 的 构 造 方 法 参 数 , 是 ConstructorArgs 集合的一部分。属性: id,column,javaType,typeHandler。 id 属性是布尔值, 来标识用于比较的属 性,和XML 元素相似。</td></tr><tr><td><code>@TypeDiscriminator</code></td><td><code>方法</code></td><td>``</td><td>一组实例值被用来决定结果映射的表 现。 属性: column, javaType, jdbcType, typeHandler,cases。cases 属性就是实 例的数组。</td></tr><tr><td><code>@Case</code></td><td><code>方法</code></td><td>``</td><td>单独实例的值和它对应的映射。属性: value,type,results。Results 属性是结 果数组,因此这个注解和实际的 ResultMap 很相似,由下面的 Results 注解指定。</td></tr><tr><td><code>@Results</code></td><td><code>方法</code></td><td>``</td><td>结果映射的列表, 包含了一个特别结果 列如何被映射到属性或字段的详情。 属 性:value,是 Result 注解的数组。</td></tr><tr><td><code>@Result</code></td><td><code>方法</code></td><td></td><td>在列和属性或字段之间的单独结果映 射。属 性:id,column, property, javaType ,jdbcType ,type Handler, one,many。id 属性是一个布尔值,表 示了应该被用于比较(和在 XML 映射 中的相似)的属性。one 属性是单 独 的 联 系, 和 相 似 , 而 many 属 性 是 对 集 合 而 言 的 , 和 相似。 它们这样命名是为了 避免名称冲突。</td></tr><tr><td><code>@One</code></td><td><code>方法</code></td><td>``</td><td>复杂类型的单独属性值映射。属性: select,已映射语句(也就是映射器方 法)的完全限定名,它可以加载合适类 型的实例。注意:联合映射在注解 API 中是不支持的。这是因为 Java 注解的 限制,不允许循环引用。<code>fetchType</code>, which supersedes the global configuration parameter<code>lazyLoadingEnabled</code> for this mapping.</td></tr><tr><td><code>@Many</code></td><td><code>方法</code></td><td>``</td><td>A mapping to a collection property of a complex type. Attributes:<code>select</code>, which is the fully qualified name of a mapped statement (i.e. mapper method) that can load a collection of instances of the appropriate types,<code>fetchType</code>, which supersedes the global configuration parameter<code>lazyLoadingEnabled</code> for this mapping. NOTE You will notice that join mapping is not supported via the Annotations API. This is due to the limitation in Java Annotations that does not allow for circular references.</td></tr><tr><td><code>@MapKey</code></td><td><code>方法</code></td><td></td><td>复 杂 类 型 的 集合 属 性 映射 。 属 性 : select,是映射语句(也就是映射器方 法)的完全限定名,它可以加载合适类 型的一组实例。注意:联合映射在 Java 注解中是不支持的。这是因为 Java 注 解的限制,不允许循环引用。</td></tr><tr><td><code>@Options</code></td><td><code>方法</code></td><td>映射语句的属性</td><td>这个注解提供访问交换和配置选项的 宽广范围, 它们通常在映射语句上作为 属性出现。 而不是将每条语句注解变复 杂,Options 注解提供连贯清晰的方式 来访问它们。属性:useCache=true , flushCache=false , resultSetType=FORWARD_ONLY , statementType=PREPARED , fetchSize=-1 , , timeout=-1 useGeneratedKeys=false , keyProperty=”id”。 理解 Java 注解是很 重要的,因为没有办法来指定”null” 作为值。因此,一旦你使用了 Options 注解,语句就受所有默认值的支配。要 注意什么样的默认值来避免不期望的 行为。</td></tr><tr><td>* <code>@Insert</code>,<code>@Update</code>, <code>@Delete</code>, <code>@Select</code></td><td><code>方法</code></td><td><code>&lt;insert&gt;</code>,<code>&lt;update&gt;</code>,<code>&lt;delete&gt;</code>,<code>&lt;select&gt;</code></td><td>这些注解中的每一个代表了执行的真 实 SQL。 它们每一个都使用字符串数组 (或单独的字符串)。如果传递的是字 符串数组, 它们由每个分隔它们的单独 空间串联起来。这就当用 Java 代码构 建 SQL 时避免了”丢失空间”的问题。 然而,如果你喜欢,也欢迎你串联单独 的字符串。属性:value,这是字符串 数组用来组成单独的 SQL 语句。</td></tr><tr><td>@InsertProvider,@UpdateProvider,@DeleteProvider,@SelectProvider</td><td>方法</td><td><code>&lt;insert&gt;</code>,<code>&lt;update&gt;</code>,<code>&lt;delete&gt;</code>,<code>&lt;select&gt;</code></td><td>这些可选的 SQL 注解允许你指定一个 类名和一个方法在执行时来返回运行 允许创建动态 的 SQL。 基于执行的映射语句, MyBatis 会实例化这个类,然后执行由 provider 指定的方法. 这个方法可以选择性的接 受参数对象作为它的唯一参数, 但是必 须只指定该参数或者没有参数。属性: type,method。type 属性是类的完全限 定名。method 是该类中的那个方法名。 注意: 这节之后是对 SelectBuilder 类的 讨论,它可以帮助你以干净,容于阅读 的方式来构建动态 SQL。</td></tr><tr><td><code>@Param</code></td><td><code>Parameter</code></td><td>N/A</td><td>如果你的映射器的方法需要多个参数, 这个注解可以被应用于映射器的方法 参数来给每个参数一个名字。否则,多 参数将会以它们的顺序位置来被命名 (不包括任何 RowBounds 参数) 比如。 #{param1} , #{param2} 等 , 这 是 默 认 的 。 使 用 @Param(“person”),参数应该被命名为 #{person}。</td></tr><tr><td><code>@SelectKey</code></td><td><code>Method</code></td><td><code>&lt;selectKey&gt;</code></td><td>This annotation duplicates the `` functionality for methods annotated with<code>@Insert</code>,<code>@InsertProvider</code>,<code>@Update</code>or<code>@UpdateProvider</code>. It is ignored for other methods. If you specify a<code>@SelectKey</code>annotation, then MyBatis will ignore any generated key properties set via the<code>@Options</code>annotation, or configuration properties. Attributes: statement an array of strings which is the SQL statement to execute,<code>keyProperty</code>which is the property of the parameter object that will be updated with the new value, before which must be either<code>true</code>or<code>false</code>to denote if the SQL statement should be executed before or after the insert,<code>resultType</code>which is the Java type of the<code>keyProperty</code>, and<code>statementType=PREPARED</code>.</td></tr><tr><td><code>@ResultMap</code></td><td><code>Method</code></td><td>N/A</td><td>This annotation is used to provide the id of a `` element in an XML mapper to a<code>@Select</code>or<code>@SelectProvider</code>annotation. This allows annotated selects to reuse resultmaps that are defined in XML. This annotation will override any<code>@Results</code>or<code>@ConstructorArgs</code> annotation if both are specified on an annotated select.</td></tr><tr><td><code>@ResultType</code></td><td><code>Method</code></td><td>N/A</td><td>This annotation is used when using a result handler. In that case, the return type is void so MyBatis must have a way to determine the type of object to construct for each row. If there is an XML result map, use the @ResultMap annotation. If the result type is specified in XML on the ` Night Mode</td></tr></tbody></table><h4 id="映射申明样例"><a href="#映射申明样例" class="headerlink" title="映射申明样例"></a>映射申明样例</h4><p>这个例子展示了如何使用 @SelectKey 注解来在插入前读取数据库序列的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into table3 (id, name) values(#&#123;nameId&#125;, #&#123;name&#125;)"</span>)</span><br><span class="line"><span class="meta">@SelectKey</span>(statement=<span class="string">"call next value for TestSequence"</span>, keyProperty=<span class="string">"nameId"</span>, before=<span class="keyword">true</span>, resultType=<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">insertTable3</span>(<span class="title">Name</span> <span class="title">name</span>)</span>;</span><br></pre></td></tr></table></figure><p>这个例子展示了如何使用 @SelectKey 注解来在插入后读取数据库识别列的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into table2 (name) values(#&#123;name&#125;)"</span>)</span><br><span class="line"><span class="meta">@SelectKey</span>(statement=<span class="string">"call identity()"</span>, keyProperty=<span class="string">"nameId"</span>, before=<span class="keyword">false</span>, resultType=<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">insertTable2</span>(<span class="title">Name</span> <span class="title">name</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>作者:W3Cschool<br>来源:<a href="https://www.w3cschool.cn/mybatis/ud8n1im1.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.w3cschool.cn/mybatis/ud8n1im1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
            <tag> MyBatis基础教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 动态SQL</title>
      <link href="/mybatis-dynamic-sql/"/>
      <url>/mybatis-dynamic-sql/</url>
      
        <content type="html"><![CDATA[<h2 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h2><p>MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其他类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句有多么痛苦。拼接的时候要确保不能忘了必要的空格，还要注意省掉列名列表最后的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。</p><p>通常使用动态 SQL 不可能是独立的一部分,MyBatis 当然使用一种强大的动态 SQL 语言来改进这种情形,这种语言可以被用在任意的 SQL 映射语句中。</p><p>动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似。在 MyBatis 之前的版本中,有很多的元素需要来了解。MyBatis 3 大大提升了它们,现在用不到原先一半的元素就可以了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。</p><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>动态 SQL 通常要做的事情是有条件地包含 where 子句的一部分。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogWithTitleLike"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE state = 'ACTIVE'</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这条语句提供了一个可选的文本查找类型的功能。如果没有传入”title”，那么所有处于”ACTIVE”状态的BLOG都会返回；反之若传入了”title”，那么就会把模糊查找”title”内容的BLOG结果返回（就这个例子而言，细心的读者会发现其中的参数值是可以包含一些掩码或通配符的）。</p><p>如果想可选地通过”title”和”author”两个条件搜索该怎么办呢？首先，改变语句的名称让它更具实际意义；然后只要加入另一个条件即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogLike"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = 'ACTIVE'</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose, when, otherwise"></a>choose, when, otherwise</h2><p>有些时候，我们不想用到所有的条件语句，而只想从中择其一二。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><p>还是上面的例子，但是这次变为提供了”title”就按”title”查找，提供了”author”就按”author”查找，若两者都没有提供，就返回所有符合条件的BLOG（实际情况可能是由管理员按一定策略选出BLOG列表，而不是返回大量无意义的随机结果）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogLike"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = 'ACTIVE'</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim, where, set"></a>trim, where, set</h2><p>前面几个例子已经合宜地解决了一个臭名昭著的动态 SQL 问题。现在考虑回到”if”示例，这次我们将”ACTIVE = 1”也设置成动态的条件，看看会发生什么。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogLike"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"state != null"</span>&gt;</span></span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果这些条件没有一个能匹配上将会怎样？最终这条 SQL 会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM BLOG</span><br><span class="line">WHERE</span><br></pre></td></tr></table></figure><p>这会导致查询失败。如果仅仅第二个条件匹配又会怎样？这条 SQL 最终会是这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM BLOG</span><br><span class="line">WHERE</span><br><span class="line">AND title like &#39;someTitle&#39;</span><br></pre></td></tr></table></figure><p>这个查询也会失败。这个问题不能简单的用条件句式来解决，如果你也曾经被迫这样写过，那么你很可能从此以后都不想再这样去写了。</p><p>MyBatis 有一个简单的处理，这在90%的情况下都会有用。而在不能使用的地方，你可以自定义处理方式来令其正常工作。一处简单的修改就能得到想要的效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogLike"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"state != null"</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>where 元素知道只有在一个以上的if条件有值的情况下才去插入”WHERE”子句。而且，若最后的内容是”AND”或”OR”开头的，where 元素也知道如何将他们去除。</p><p>如果 where 元素没有按正常套路出牌，我们还是可以通过自定义 trim 元素来定制我们想要的功能。比如，和 where 元素等价的自定义 trim 元素为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"WHERE"</span> <span class="attr">prefixOverrides</span>=<span class="string">"AND |OR "</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它带来的结果就是所有在 prefixOverrides 属性中指定的内容将被移除，并且插入 prefix 属性中指定的内容。</p><p>类似的用于动态更新语句的解决方案叫做 set。set 元素可以被用于动态包含需要更新的列，而舍去其他的。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateAuthorIfNecessary"</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null"</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password != null"</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null"</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bio != null"</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里，set 元素会动态前置 SET 关键字，同时也会消除无关的逗号，因为用了条件语句之后很可能就会在生成的赋值语句的后面留下这些逗号。</p><p>若你对等价的自定义 trim 元素的样子感兴趣，那这就应该是它的真面目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"SET"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里我们忽略的是后缀中的值，而又一次附加了前缀中的值。</p><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPostIn"</span> <span class="attr">resultType</span>=<span class="string">"domain.blog.Post"</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">collection</span>=<span class="string">"list"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>foreach 元素的功能是非常强大的，它允许你指定一个集合，声明可以用在元素体内的集合项和索引变量。它也允许你指定开闭匹配的字符串以及在迭代中间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。</p><p>注意 你可以将一个 List 实例或者数组作为参数对象传给 MyBatis，当你这么做的时候，MyBatis 会自动将它包装在一个 Map 中并以名称为键。List 实例将会以”list”作为键，而数组实例的键将是”array”。</p><p>到此我们已经完成了涉及 XML 配置文件和 XML 映射文件的讨论。下一部分将详细探讨 Java API，这样才能从已创建的映射中获取最大利益。</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><code>bind</code> 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlogsLike"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"'%' + _parameter.getTitle() + '%'"</span> /&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE title LIKE #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Multi-db-vendor-support"><a href="#Multi-db-vendor-support" class="headerlink" title="Multi-db vendor support"></a>Multi-db vendor support</h2><p>一个配置了”_databaseId”变量的 databaseIdProvider 对于动态代码来说是可用的，这样就可以根据不同的数据库厂商构建特定的语句。比如下面的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"int"</span> <span class="attr">order</span>=<span class="string">"BEFORE"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"_databaseId == 'oracle'"</span>&gt;</span></span><br><span class="line">      select seq_users.nextval from dual</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"_databaseId == 'db2'"</span>&gt;</span></span><br><span class="line">      select nextval for seq_users from sysibm.sysdummy1"</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">  insert into users values (#&#123;id&#125;, #&#123;name&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态-SQL-中可插拔的脚本语言"><a href="#动态-SQL-中可插拔的脚本语言" class="headerlink" title="动态 SQL 中可插拔的脚本语言"></a>动态 SQL 中可插拔的脚本语言</h2><p>MyBatis 从 3.2 开始支持可插拔的脚本语言，因此你可以在插入一种语言的驱动（language driver）之后来写基于这种语言的动态 SQL 查询。</p><p>可以通过实现下面接口的方式来插入一种语言：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface LanguageDriver &#123;</span><br><span class="line">  ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql);</span><br><span class="line">  SqlSource createSqlSource(Configuration configuration, XNode script, Class parameterType);</span><br><span class="line">  SqlSource createSqlSource(Configuration configuration, String script, Class parameterType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦有了自定义的语言驱动，你就可以在 mybatis-config.xml 文件中将它设置为默认语言：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"org.sample.MyLanguageDriver"</span> <span class="attr">alias</span>=<span class="string">"myLanguage"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultScriptingLanguage"</span> <span class="attr">value</span>=<span class="string">"myLanguage"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了设置默认语言，你也可以针对特殊的语句指定特定语言，这可以通过如下的 <code>lang</code> 属性来完成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">lang</span>=<span class="string">"myLanguage"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者在你正在使用的映射中加上注解 <code>@Lang</code> 来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Mapper &#123;</span><br><span class="line">  @Lang(MyLanguageDriver.class)</span><br><span class="line">  @Select(&quot;SELECT * FROM BLOG&quot;)</span><br><span class="line">  List selectBlog();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 可以将 Apache Velocity 作为动态语言来使用，更多细节请参考 MyBatis-Velocity 项目。</p><p>你前面看到的所有 xml 标签都是默认 MyBatis 语言提供的，它是由别名为 <code>xml</code> 语言驱动器 <code>org.apache.ibatis.scripting.xmltags.XmlLanguageDriver</code> 驱动的。</p><blockquote><p>作者:W3Cschool<br>来源:<a href="https://www.w3cschool.cn/mybatis/l5cx1ilz.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.w3cschool.cn/mybatis/l5cx1ilz.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
            <tag> MyBatis基础教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis XML映射文件</title>
      <link href="/mybatis-xml-mapping/"/>
      <url>/mybatis-xml-mapping/</url>
      
        <content type="html"><![CDATA[<h2 id="Mapper-XML-文件"><a href="#Mapper-XML-文件" class="headerlink" title="Mapper XML 文件"></a>Mapper XML 文件</h2><p>MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。</p><p>SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）：</p><ul><li><code>cache</code> – 给定命名空间的缓存配置。</li><li><code>cache-ref</code> – 其他命名空间缓存配置的引用。</li><li><code>resultMap</code> – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</li><li><code>sql</code> – 可被其他语句引用的可重用语句块。</li><li><code>insert</code> – 映射插入语句</li><li><code>update</code> – 映射更新语句</li><li><code>delete</code> – 映射删除语句</li><li><code>select</code> – 映射查询语句</li></ul><p>下一部分将从语句本身开始来描述每个元素的细节。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>查询语句是 MyBatis 中最常用的元素之一，光能把数据存到数据库中价值并不大，如果还能重新取出来才有用，多数应用也都是查询比修改要频繁。对每个插入、更新或删除操作，通常对应多个查询操作。这是 MyBatis 的基本原则之一，也是将焦点和努力放到查询和结果映射的原因。简单查询的 select 元素是非常简单的。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPerson"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"hashmap"</span>&gt;</span></span><br><span class="line">  SELECT * FROM PERSON WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p><p>注意参数符号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;id&#125;</span><br></pre></td></tr></table></figure><p>这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL 中会由一个”?”来标识，并被传递到一个新的预处理语句中，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Similar JDBC code, NOT MyBatis...</span><br><span class="line">String selectPerson &#x3D; &quot;SELECT * FROM PERSON WHERE ID&#x3D;?&quot;;</span><br><span class="line">PreparedStatement ps &#x3D; conn.prepareStatement(selectPerson);</span><br><span class="line">ps.setInt(1,id);</span><br></pre></td></tr></table></figure><p>当然，这需要很多单独的 JDBC 的代码来提取结果并将它们映射到对象实例中，这就是 MyBatis 节省你时间的地方。我们需要深入了解参数和结果映射，细节部分我们下面来了解。</p><p>select 元素有很多属性允许你配置，来决定每条语句的作用细节。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"selectPerson"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"int"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterMap</span>=<span class="string">"deprecated"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultType</span>=<span class="string">"hashmap"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultMap</span>=<span class="string">"personResultMap"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">useCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">fetchSize</span>=<span class="string">"256"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultSetType</span>=<span class="string">"FORWARD_ONLY"</span> &gt;</span></span><br></pre></td></tr></table></figure><p>Select Attributes</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td>parameterType</td><td>将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td></tr><tr><td>resultType</td><td>从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。</td></tr><tr><td>resultMap</td><td>外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。</td></tr><tr><td>flushCache</td><td>将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。</td></tr><tr><td>useCache</td><td>将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。</td></tr><tr><td>timeout</td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。</td></tr><tr><td>fetchSize</td><td>这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。</td></tr><tr><td>statementType</td><td>STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td>resultSetType</td><td>FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。</td></tr><tr><td>databaseId</td><td>如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td></tr><tr><td>resultOrdered</td><td>这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。</td></tr><tr><td>resultSets</td><td>这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。</td></tr></tbody></table><h3 id="insert-update-和-delete"><a href="#insert-update-和-delete" class="headerlink" title="insert, update 和 delete"></a>insert, update 和 delete</h3><p>数据变更语句 insert，update 和 delete 的实现非常接近：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"insertAuthor"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"domain.blog.Author"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">keyProperty</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">  <span class="attr">keyColumn</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">  <span class="attr">useGeneratedKeys</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"updateAuthor"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"domain.blog.Author"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"deleteAuthor"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"domain.blog.Author"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Insert, Update 和 Delete 的属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>命名空间中的唯一标识符，可被用来代表这条语句。</td></tr><tr><td>parameterType</td><td>将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td></tr><tr><td>flushCache</td><td>将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。</td></tr><tr><td>timeout</td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。</td></tr><tr><td>statementType</td><td>STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td>useGeneratedKeys</td><td>（仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td>keyProperty</td><td>（仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td>keyColumn</td><td>（仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td>databaseId</td><td>如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td></tr></tbody></table><p>下面就是 insert，update 和 delete 语句的示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertAuthor"</span>&gt;</span></span><br><span class="line">  insert into Author (id,username,password,email,bio)</span><br><span class="line">  values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateAuthor"</span>&gt;</span></span><br><span class="line">  update Author set</span><br><span class="line">    username = #&#123;username&#125;,</span><br><span class="line">    password = #&#123;password&#125;,</span><br><span class="line">    email = #&#123;email&#125;,</span><br><span class="line">    bio = #&#123;bio&#125;</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteAuthor"</span>&gt;</span></span><br><span class="line">  delete from Author where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如前所述，插入语句的配置规则更加丰富，在插入语句里面有一些额外的属性和子元素用来处理主键的生成，而且有多种生成方式。</p><p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就OK了。例如，如果上面的 Author 表已经对 id 使用了自动生成的列类型，那么语句可以修改为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertAuthor"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">  insert into Author (username,password,email,bio)</span><br><span class="line">  values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于不支持自动生成类型的数据库或可能不支持自动生成主键 JDBC 驱动来说，MyBatis 有另外一种方法来生成主键。</p><p>这里有一个简单（甚至很傻）的示例，它可以生成一个随机 ID（你最好不要这么做，但这里展示了 MyBatis 处理问题的灵活性及其所关心的广度）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertAuthor"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"int"</span> <span class="attr">order</span>=<span class="string">"BEFORE"</span>&gt;</span></span><br><span class="line">    select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">  insert into Author</span><br><span class="line">    (id, username, password, email,bio, favourite_section)</span><br><span class="line">  values</span><br><span class="line">    (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;, #&#123;bio&#125;, #&#123;favouriteSection,jdbcType=VARCHAR&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，selectKey 元素将会首先运行，Author 的 id 会被设置，然后插入语句会被调用。这给你了一个和数据库中来处理自动生成的主键类似的行为，避免了使 Java 代码变得复杂。</p><p>selectKey 元素描述如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selectKey</span></span></span><br><span class="line"><span class="tag">  <span class="attr">keyProperty</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultType</span>=<span class="string">"int"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">order</span>=<span class="string">"BEFORE"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>selectKey 的属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>keyProperty</td><td>selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td>keyColumn</td><td>匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr><tr><td>resultType</td><td>结果的类型。MyBatis 通常可以推算出来，但是为了更加确定写上也不会有什么问题。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。</td></tr><tr><td>order</td><td>这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先选择主键，设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 元素 - 这和像 Oracle 的数据库相似，在插入语句内部可能有嵌入索引调用。</td></tr><tr><td>statementType</td><td>与前面相同，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 语句的映射类型，分别代表 PreparedStatement 和 CallableStatement 类型。</td></tr></tbody></table><h3 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h3><p>这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。It can be statically (during load phase) parametrized. Different property values can vary in include instances. 比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"userColumns"</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 SQL 片段可以被包含在其他语句中，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t1"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t2"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  from some_table t1</span><br><span class="line">    cross join some_table t2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Property value can be also used in include refid attribute or property values inside include clause, for example:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"sometable"</span>&gt;</span></span><br><span class="line">  $&#123;prefix&#125;Table</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"someinclude"</span>&gt;</span></span><br><span class="line">  from</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"$&#123;include_target&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"select"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    field1, field2, field3</span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"someinclude"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"Some"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"include_target"</span> <span class="attr">value</span>=<span class="string">"sometable"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参数（Parameters）"><a href="#参数（Parameters）" class="headerlink" title="参数（Parameters）"></a>参数（Parameters）</h3><p>前面的所有语句中你所见到的都是简单参数的例子，实际上参数是 MyBatis 非常强大的元素，对于简单的做法，大概 90% 的情况参数都很少，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  select id, username, password</span><br><span class="line">  from users</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的这个示例说明了一个非常简单的命名参数映射。参数类型被设置为 <code>int</code>，这样这个参数就可以被设置成任何内容。原生的类型或简单数据类型（比如整型和字符串）因为没有相关属性，它会完全用参数值来替代。然而，如果传入一个复杂的对象，行为就会有一点不同了。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  insert into users (id, username, password)</span><br><span class="line">  values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 User 类型的参数对象传递到了语句中，id、username 和 password 属性将会被查找，然后将它们的值传入预处理语句的参数中。</p><p>这点对于向语句中传参是比较好的而且又简单，不过参数映射的功能远不止于此。</p><p>首先，像 MyBatis 的其他部分一样，参数也可以指定一个特殊的数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;property,javaType&#x3D;int,jdbcType&#x3D;NUMERIC&#125;</span><br></pre></td></tr></table></figure><p>像 MyBatis 的剩余部分一样，javaType 通常可以从参数对象中来去确定，前提是只要对象不是一个 HashMap。那么 javaType 应该被确定来保证使用正确类型处理器。</p><p>NOTE 如果 null 被当作值来传递，对于所有可能为空的列，JDBC Type 是需要的。你可以自己通过阅读预处理语句的 setNull() 方法的 JavaDocs 文档来研究这种情况。</p><p>为了以后定制类型处理方式，你也可以指定一个特殊的类型处理器类（或别名），比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;age,javaType&#x3D;int,jdbcType&#x3D;NUMERIC,typeHandler&#x3D;MyTypeHandler&#125;</span><br></pre></td></tr></table></figure><p>尽管看起来配置变得越来越繁琐，但实际上是很少去设置它们。</p><p>对于数值类型，还有一个小数保留位数的设置，来确定小数点后保留的位数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;height,javaType&#x3D;double,jdbcType&#x3D;NUMERIC,numericScale&#x3D;2&#125;</span><br></pre></td></tr></table></figure><p>最后，mode 属性允许你指定 IN，OUT 或 INOUT 参数。如果参数为 OUT 或 INOUT，参数对象属性的真实值将会被改变，就像你在获取输出参数时所期望的那样。如果 mode 为 OUT（或 INOUT），而且 jdbcType 为 CURSOR(也就是 Oracle 的 REFCURSOR)，你必须指定一个 resultMap 来映射结果集到参数类型。要注意这里的 javaType 属性是可选的，如果左边的空白是 jdbcType 的 CURSOR 类型，它会自动地被设置为结果集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;department, mode&#x3D;OUT, jdbcType&#x3D;CURSOR, javaType&#x3D;ResultSet, resultMap&#x3D;departmentResultMap&#125;</span><br></pre></td></tr></table></figure><p>MyBatis 也支持很多高级的数据类型，比如结构体，但是当注册 out 参数时你必须告诉它语句类型名称。比如（再次提示，在实际中要像这样不能换行）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;middleInitial, mode&#x3D;OUT, jdbcType&#x3D;STRUCT, jdbcTypeName&#x3D;MY_TYPE, resultMap&#x3D;departmentResultMap&#125;</span><br></pre></td></tr></table></figure><p>尽管所有这些强大的选项很多时候你只简单指定属性名，其他的事情 MyBatis 会自己去推断，最多你需要为可能为空的列名指定 <code>jdbcType</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#&#123;firstName&#125;</span><br><span class="line">#&#123;middleInitial,jdbcType&#x3D;VARCHAR&#125;</span><br><span class="line">#&#123;lastName&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><p>默认情况下,使用#{}格式的语法会导致 MyBatis 创建预处理语句属性并安全地设置值（比如?）。这样做更安全，更迅速，通常也是首选做法，不过有时你只是想直接在 SQL 语句中插入一个不改变的字符串。比如，像 ORDER BY，你可以这样来使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORDER BY $&#123;columnName&#125;</span><br></pre></td></tr></table></figure><p>这里 MyBatis 不会修改或转义字符串。</p><p>NOTE 以这种方式接受从用户输出的内容并提供给语句中不变的字符串是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。</p><h3 id="Result-Maps"><a href="#Result-Maps" class="headerlink" title="Result Maps"></a>Result Maps</h3><p>resultMap 元素是 MyBatis 中最重要最强大的元素。它就是让你远离 90%的需要从结果 集中取出数据的 JDBC 代码的那个东西, 而且在一些情形下允许你做一些 JDBC 不支持的事 情。 事实上, 编写相似于对复杂语句联合映射这些等同的代码, 也许可以跨过上千行的代码。 ResultMap 的设计就是简单语句不需要明确的结果映射,而很多复杂语句确实需要描述它们 的关系。</p><p>你已经看到简单映射语句的示例了,但没有明确的 resultMap。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样一个语句简单作用于所有列被自动映射到 HashMap 的键上,这由 resultType 属性 指定。这在很多情况下是有用的,但是 HashMap 不能很好描述一个领域模型。那样你的应 用程序将会使用 JavaBeans 或 POJOs(Plain Old Java Objects,普通 Java 对象)来作为领域 模型。MyBatis 对两者都支持。看看下面这个 JavaBean:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.someapp.model;</span><br><span class="line">public class User &#123;</span><br><span class="line">  private int id;</span><br><span class="line">  private String username;</span><br><span class="line">  private String hashedPassword;</span><br><span class="line"></span><br><span class="line">  public int getId() &#123;</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setId(int id) &#123;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">  &#125;</span><br><span class="line">  public String getUsername() &#123;</span><br><span class="line">    return username;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setUsername(String username) &#123;</span><br><span class="line">    this.username &#x3D; username;</span><br><span class="line">  &#125;</span><br><span class="line">  public String getHashedPassword() &#123;</span><br><span class="line">    return hashedPassword;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setHashedPassword(String hashedPassword) &#123;</span><br><span class="line">    this.hashedPassword &#x3D; hashedPassword;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 JavaBean 的规范,上面这个类有 3 个属性:id,username 和 hashedPassword。这些 在 select 语句中会精确匹配到列名。</p><p>这样的一个 JavaBean 可以被映射到结果集,就像映射到 HashMap 一样简单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"com.someapp.model.User"</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要记住类型别名是你的伙伴。使用它们你可以不用输入类的全路径。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- In mybatis-config.xml file --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"com.someapp.model.User"</span> <span class="attr">alias</span>=<span class="string">"User"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- In SQL Mapping XML file --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些情况下,MyBatis 会在幕后自动创建一个 ResultMap,基于属性名来映射列到 JavaBean 的属性上。如果列名没有精确匹配,你可以在列名上使用 select 字句的别名(一个 基本的 SQL 特性)来匹配标签。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    user_id             as "id",</span><br><span class="line">    user_name           as "userName",</span><br><span class="line">    hashed_password     as "hashedPassword"</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ResultMap 最优秀的地方你已经了解了很多了,但是你还没有真正的看到一个。这些简 单的示例不需要比你看到的更多东西。 只是出于示例的原因, 让我们来看看最后一个示例中 外部的 resultMap 是什么样子的,这也是解决列名不匹配的另外一种方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"user_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引用它的语句使用 resultMap 属性就行了(注意我们去掉了 resultType 属性)。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultMap</span>=<span class="string">"userResultMap"</span>&gt;</span></span><br><span class="line">  select user_id, user_name, hashed_password</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果世界总是这么简单就好了。</p><h4 id="高级结果映射"><a href="#高级结果映射" class="headerlink" title="高级结果映射"></a>高级结果映射</h4><p>MyBatis 创建的一个想法:数据库不用永远是你想要的或需要它们是什么样的。而我们 最喜欢的数据库最好是第三范式或 BCNF 模式,但它们有时不是。如果可能有一个单独的 数据库映射,所有应用程序都可以使用它,这是非常好的,但有时也不是。结果映射就是 MyBatis 提供处理这个问题的答案。</p><p>比如,我们如何映射下面这个语句?</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Very Complex Statement --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlogDetails"</span> <span class="attr">resultMap</span>=<span class="string">"detailedBlogResultMap"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">       B.id as blog_id,</span><br><span class="line">       B.title as blog_title,</span><br><span class="line">       B.author_id as blog_author_id,</span><br><span class="line">       A.id as author_id,</span><br><span class="line">       A.username as author_username,</span><br><span class="line">       A.password as author_password,</span><br><span class="line">       A.email as author_email,</span><br><span class="line">       A.bio as author_bio,</span><br><span class="line">       A.favourite_section as author_favourite_section,</span><br><span class="line">       P.id as post_id,</span><br><span class="line">       P.blog_id as post_blog_id,</span><br><span class="line">       P.author_id as post_author_id,</span><br><span class="line">       P.created_on as post_created_on,</span><br><span class="line">       P.section as post_section,</span><br><span class="line">       P.subject as post_subject,</span><br><span class="line">       P.draft as draft,</span><br><span class="line">       P.body as post_body,</span><br><span class="line">       C.id as comment_id,</span><br><span class="line">       C.post_id as comment_post_id,</span><br><span class="line">       C.name as comment_name,</span><br><span class="line">       C.comment as comment_text,</span><br><span class="line">       T.id as tag_id,</span><br><span class="line">       T.name as tag_name</span><br><span class="line">  from Blog B</span><br><span class="line">       left outer join Author A on B.author_id = A.id</span><br><span class="line">       left outer join Post P on B.id = P.blog_id</span><br><span class="line">       left outer join Comment C on P.id = C.post_id</span><br><span class="line">       left outer join Post_Tag PT on PT.post_id = P.id</span><br><span class="line">       left outer join Tag T on PT.tag_id = T.id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可能想把它映射到一个智能的对象模型,包含一个作者写的博客,有很多的博文,每 篇博文有零条或多条的评论和标签。 下面是一个完整的复杂结果映射例子 (假设作者, 博客, 博文, 评论和标签都是类型的别名) 我们来看看, 。 但是不用紧张, 我们会一步一步来说明。 当天最初它看起来令人生畏,但实际上非常简单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Very Complex Result Map --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"detailedBlogResultMap"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> <span class="attr">javaType</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"author_password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"email"</span> <span class="attr">column</span>=<span class="string">"author_email"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bio"</span> <span class="attr">column</span>=<span class="string">"author_bio"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"favouriteSection"</span> <span class="attr">column</span>=<span class="string">"author_favourite_section"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"comments"</span> <span class="attr">ofType</span>=<span class="string">"Comment"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"comment_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"tags"</span> <span class="attr">ofType</span>=<span class="string">"Tag"</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"tag_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">"int"</span> <span class="attr">column</span>=<span class="string">"draft"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">resultType</span>=<span class="string">"DraftPost"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>resultMap 元素有很多子元素和一个值得讨论的结构。 下面是 resultMap 元素的概念视图</p><h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><ul><li><code>constructor</code> - 类在实例化时,用来注入结果到构造方法中<ul><li><code>idArg</code> - ID 参数;标记结果作为 ID 可以帮助提高整体效能</li><li><code>arg</code> - 注入到构造方法的一个普通结果</li></ul></li><li><code>id</code> – 一个 ID 结果;标记结果作为 ID 可以帮助提高整体效能</li><li><code>result</code> – 注入到字段或 JavaBean 属性的普通结果</li><li><code>association</code> – 一个复杂的类型关联;许多结果将包成这种类型<ul><li>嵌入结果映射 – 结果映射自身的关联,或者参考一个</li></ul></li><li><code>collection</code> – 复杂类型的集<ul><li>嵌入结果映射 – 结果映射自身的集,或者参考一个</li></ul></li><li><code>discriminator</code> – 使用结果值来决定使用哪个结果映射<ul><li><code>case</code> – 基于某些值的结果映射<ul><li>嵌入结果映射 – 这种情形结果也映射它本身,因此可以包含很多相 同的元素,或者它可以参照一个外部的结果映射。</li></ul></li></ul></li></ul><p>ResultMap Attributes</p><table><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td><code>id</code></td><td>A unique identifier in this namespace that can be used to reference this result map.</td></tr><tr><td><code>type</code></td><td>A fully qualified Java class name, or a type alias (see the table above for the list of built-in type aliases).</td></tr><tr><td><code>autoMapping</code></td><td>If present, MyBatis will enable or disable the automapping for this ResultMap. This attribute overrides the global autoMappingBehavior. Default: unset.</td></tr></tbody></table><p>最佳实践 通常逐步建立结果映射。单元测试的真正帮助在这里。如果你尝试创建 一次创建一个向上面示例那样的巨大的结果映射, 那么可能会有错误而且很难去控制它 来工作。开始简单一些,一步一步的发展。而且要进行单元测试!使用该框架的缺点是 它们有时是黑盒(是否可见源代码) 。你确定你实现想要的行为的最好选择是编写单元 测试。它也可以你帮助得到提交时的错误。</p><p>下面一部分将详细说明每个元素。</p><h4 id="id-amp-result"><a href="#id-amp-result" class="headerlink" title="id &amp; result"></a>id &amp; result</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这些是结果映射最基本内容。id 和 result 都映射一个单独列的值到简单数据类型(字符 串,整型,双精度浮点数,日期等)的单独属性或字段。</p><p>这两者之间的唯一不同是 id 表示的结果将是当比较对象实例时用到的标识属性。这帮 助来改进整体表现,特别是缓存和嵌入结果映射(也就是联合映射) 。</p><p>每个都有一些属性:</p><p>Id and Result Attributes</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>property</code></td><td>映射到列结果的字段或属性。如果匹配的是存在的,和给定名称相同 的 JavaBeans 的属性,那么就会使用。否则 MyBatis 将会寻找给定名称 property 的字段。这两种情形你可以使用通常点式的复杂属性导航。比如,你 可以这样映射一些东西: “username” ,或者映射到一些复杂的东西: “address.street.number” 。</td></tr><tr><td><code>column</code></td><td>从数据库中得到的列名,或者是列名的重命名标签。这也是通常和会 传递给 resultSet.getString(columnName)方法参数中相同的字符串。</td></tr><tr><td><code>javaType</code></td><td>一个 Java 类的完全限定名,或一个类型别名(参考上面内建类型别名 的列表) 。如果你映射到一个 JavaBean,MyBatis 通常可以断定类型。 然而,如果你映射到的是 HashMap,那么你应该明确地指定 javaType 来保证所需的行为。</td></tr><tr><td><code>jdbcType</code></td><td>在这个表格之后的所支持的 JDBC 类型列表中的类型。JDBC 类型是仅 仅需要对插入,更新和删除操作可能为空的列进行处理。这是 JDBC jdbcType 的需要,而不是 MyBatis 的。如果你直接使用 JDBC 编程,你需要指定 这个类型-但仅仅对可能为空的值。</td></tr><tr><td><code>typeHandler</code></td><td>我们在前面讨论过默认的类型处理器。使用这个属性,你可以覆盖默 认的类型处理器。这个属性值是类的完全限定名或者是一个类型处理 器的实现,或者是类型别名。</td></tr></tbody></table><h4 id="支持的-JDBC-类型"><a href="#支持的-JDBC-类型" class="headerlink" title="支持的 JDBC 类型"></a>支持的 JDBC 类型</h4><p>为了未来的参考,MyBatis 通过包含的 jdbcType 枚举型,支持下面的 JDBC 类型。</p><table><thead><tr><th><code>BIT</code></th><th><code>FLOAT</code></th><th><code>CHAR</code></th><th><code>TIMESTAMP</code></th><th><code>OTHER</code></th><th><code>UNDEFINED</code></th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td><code>REAL</code></td><td><code>VARCHAR</code></td><td><code>BINARY</code></td><td><code>BLOG</code></td><td><code>NVARCHAR</code></td></tr><tr><td><code>SMALLINT</code></td><td><code>DOUBLE</code></td><td><code>LONGVARCHAR</code></td><td><code>VARBINARY</code></td><td><code>CLOB</code></td><td><code>NCHAR</code></td></tr><tr><td><code>INTEGER</code></td><td><code>NUMERIC</code></td><td><code>DATE</code></td><td><code>LONGVARBINARY</code></td><td><code>BOOLEAN</code></td><td><code>NCLOB</code></td></tr><tr><td><code>BIGINT</code></td><td><code>DECIMAL</code></td><td><code>TIME</code></td><td><code>NULL</code></td><td><code>CURSOR</code></td><td><code>ARRAY</code></td></tr></tbody></table><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">javaType</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">arg</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">javaType</span>=<span class="string">"String"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于大多数数据传输对象(Data Transfer Object,DTO)类型,属性可以起作用,而且像 你绝大多数的领域模型, 指令也许是你想使用一成不变的类的地方。 通常包含引用或查询数 据的表很少或基本不变的话对一成不变的类来说是合适的。 构造方法注入允许你在初始化时 为类设置属性的值,而不用暴露出公有方法。MyBatis 也支持私有属性和私有 JavaBeans 属 性来达到这个目的,但是一些人更青睐构造方法注入。构造方法元素支持这个。</p><p>看看下面这个构造方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">   &#x2F;&#x2F;...</span><br><span class="line">   public User(int id, String username) &#123;</span><br><span class="line">     &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了向这个构造方法中注入结果,MyBatis 需要通过它的参数的类型来标识构造方法。 Java 没有自查(反射)参数名的方法。所以当创建一个构造方法元素时,保证参数是按顺序 排列的,而且数据类型也是确定的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">javaType</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">arg</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">javaType</span>=<span class="string">"String"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br></pre></td></tr></table></figure><p>剩余的属性和规则和固定的 id 和 result 元素是相同的。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>column</code></td><td>来自数据库的类名,或重命名的列标签。这和通常传递给 resultSet.getString(columnName)方法的字符串是相同的。</td></tr><tr><td><code>javaType</code></td><td>一个 Java 类的完全限定名,或一个类型别名(参考上面内建类型别名的列表)。 如果你映射到一个 JavaBean,MyBatis 通常可以断定类型。然而,如 果你映射到的是 HashMap,那么你应该明确地指定 javaType 来保证所需的 行为。</td></tr><tr><td><code>jdbcType</code></td><td>在这个表格之前的所支持的 JDBC 类型列表中的类型。JDBC 类型是仅仅 需要对插入, 更新和删除操作可能为空的列进行处理。这是 JDBC 的需要, jdbcType 而不是 MyBatis 的。如果你直接使用 JDBC 编程,你需要指定这个类型-但 仅仅对可能为空的值。</td></tr><tr><td><code>typeHandler</code></td><td>我们在前面讨论过默认的类型处理器。使用这个属性,你可以覆盖默认的 类型处理器。 这个属性值是类的完全限定名或者是一个类型处理器的实现, 或者是类型别名。</td></tr><tr><td><code>select</code></td><td>The ID of another mapped statement that will load the complex type required by this property mapping. The values retrieved from columns specified in the column attribute will be passed to the target select statement as parameters. See the Association element for more.</td></tr><tr><td><code>resultMap</code></td><td>This is the ID of a ResultMap that can map the nested results of this argument into an appropriate object graph. This is an alternative to using a call to another select statement. It allows you to join multiple tables together into a single <code>ResultSet</code>. Such a <code>ResultSet</code> will contain duplicated, repeating groups of data that needs to be decomposed and mapped properly to a nested object graph. To facilitate this, MyBatis lets you “chain” result maps together, to deal with the nested results. See the Association element below for more.</td></tr></tbody></table><h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a><code>关联</code></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">column</span>=<span class="string">"blog_author_id"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关联元素处理”有一个”类型的关系。比如,在我们的示例中,一个博客有一个用户。 关联映射就工作于这种结果之上。你指定了目标属性,来获取值的列,属性的 java 类型(很 多情况下 MyBatis 可以自己算出来) ,如果需要的话还有 jdbc 类型,如果你想覆盖或获取的 结果值还需要类型控制器。</p><p>关联中不同的是你需要告诉 MyBatis 如何加载关联。MyBatis 在这方面会有两种不同的 方式:</p><ul><li>嵌套查询:通过执行另外一个 SQL 映射语句来返回预期的复杂类型。</li><li>嵌套结果:使用嵌套结果映射来处理重复的联合结果的子集。首先,然让我们来查看这个元素的属性。所有的你都会看到,它和普通的只由 select 和</li></ul><p>resultMap 属性的结果映射不同。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>property</code></td><td>映射到列结果的字段或属性。如果匹配的是存在的,和给定名称相同的 property JavaBeans 的属性, 那么就会使用。 否则 MyBatis 将会寻找给定名称的字段。 这两种情形你可以使用通常点式的复杂属性导航。比如,你可以这样映射 一 些 东 西 :” username “, 或 者 映 射 到 一 些 复 杂 的 东 西 : “address.street.number” 。</td></tr><tr><td><code>javaType</code></td><td>一个 Java 类的完全限定名,或一个类型别名(参考上面内建类型别名的列 表) 。如果你映射到一个 JavaBean,MyBatis 通常可以断定类型。然而,如 javaType 果你映射到的是 HashMap,那么你应该明确地指定 javaType 来保证所需的 行为。</td></tr><tr><td><code>jdbcType</code></td><td>在这个表格之前的所支持的 JDBC 类型列表中的类型。JDBC 类型是仅仅 需要对插入, 更新和删除操作可能为空的列进行处理。这是 JDBC 的需要, jdbcType 而不是 MyBatis 的。如果你直接使用 JDBC 编程,你需要指定这个类型-但 仅仅对可能为空的值。</td></tr><tr><td><code>typeHandler</code></td><td>我们在前面讨论过默认的类型处理器。使用这个属性,你可以覆盖默认的 typeHandler 类型处理器。 这个属性值是类的完全限定名或者是一个类型处理器的实现, 或者是类型别名。</td></tr></tbody></table><h4 id="关联的嵌套查询"><a href="#关联的嵌套查询" class="headerlink" title="关联的嵌套查询"></a>关联的嵌套查询</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>column</code></td><td>来自数据库的类名,或重命名的列标签。这和通常传递给 resultSet.getString(columnName)方法的字符串是相同的。 column 注 意 : 要 处 理 复 合 主 键 , 你 可 以 指 定 多 个 列 名 通 过 column= “ {prop1=col1,prop2=col2} “ 这种语法来传递给嵌套查询语 句。这会引起 prop1 和 prop2 以参数对象形式来设置给目标嵌套查询语句。</td></tr><tr><td><code>select</code></td><td>另外一个映射语句的 ID,可以加载这个属性映射需要的复杂类型。获取的 在列属性中指定的列的值将被传递给目标 select 语句作为参数。表格后面 有一个详细的示例。 select 注 意 : 要 处 理 复 合 主 键 , 你 可 以 指 定 多 个 列 名 通 过 column= “ {prop1=col1,prop2=col2} “ 这种语法来传递给嵌套查询语 句。这会引起 prop1 和 prop2 以参数对象形式来设置给目标嵌套查询语句。</td></tr><tr><td><code>fetchType</code></td><td>Optional. Valid values are <code>lazy</code> and <code>eager</code>. If present, it supersedes the global configuration parameter <code>lazyLoadingEnabled</code> for this mapping.</td></tr></tbody></table><p>示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">column</span>=<span class="string">"author_id"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span> <span class="attr">select</span>=<span class="string">"selectAuthor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAuthor"</span> <span class="attr">resultType</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">  SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们有两个查询语句:一个来加载博客,另外一个来加载作者,而且博客的结果映射描 述了”selectAuthor”语句应该被用来加载它的 author 属性。</p><p>其他所有的属性将会被自动加载,假设它们的列和属性名相匹配。</p><p>这种方式很简单, 但是对于大型数据集合和列表将不会表现很好。 问题就是我们熟知的 “N+1 查询问题”。概括地讲,N+1 查询问题可以是这样引起的:</p><ul><li>你执行了一个单独的 SQL 语句来获取结果列表(就是”+1”)。</li><li>对返回的每条记录,你执行了一个查询语句来为每个加载细节(就是”N”)。</li></ul><p>这个问题会导致成百上千的 SQL 语句被执行。这通常不是期望的。</p><p>MyBatis 能延迟加载这样的查询就是一个好处,因此你可以分散这些语句同时运行的消 耗。然而,如果你加载一个列表,之后迅速迭代来访问嵌套的数据,你会调用所有的延迟加 载,这样的行为可能是很糟糕的。</p><p>所以还有另外一种方法。</p><h4 id="关联的嵌套结果"><a href="#关联的嵌套结果" class="headerlink" title="关联的嵌套结果"></a>关联的嵌套结果</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>resultMap</code></td><td>这是结果映射的 ID,可以映射关联的嵌套结果到一个合适的对象图中。这 是一种替代方法来调用另外一个查询语句。这允许你联合多个表来合成到 resultMap 一个单独的结果集。这样的结果集可能包含重复,数据的重复组需要被分 解,合理映射到一个嵌套的对象图。为了使它变得容易,MyBatis 让你”链 接”结果映射,来处理嵌套结果。一个例子会很容易来仿照,这个表格后 面也有一个示例。</td></tr><tr><td><code>columnPrefix</code></td><td>When joining multiple tables, you would have to use column alias to avoid duplicated column names in the ResultSet. Specifying columnPrefix allows you to map such columns to an external resultMap. Please see the example explained later in this section.</td></tr><tr><td><code>notNullColumn</code></td><td>By default a child object is created only if at least one of the columns mapped to the child’s properties is non null. With this attribute you can change this behaviour by specifiying which columns must have a value so MyBatis will create a child object only if any of those columns is not null. Multiple column names can be specified using a comma as a separator. Default value: unset.</td></tr><tr><td><code>autoMapping</code></td><td>If present, MyBatis will enable or disable auto-mapping when mapping the result to this property. This attribute overrides the global autoMappingBehavior. Note that it has no effect on an external resultMap, so it is pointless to use it with <code>select</code> or <code>resultMap</code> attribute. Default value: unset.</td></tr></tbody></table><p>在上面你已经看到了一个非常复杂的嵌套关联的示例。 下面这个是一个非常简单的示例 来说明它如何工作。代替了执行一个分离的语句,我们联合博客表和作者表在一起,就像:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    B.id            as blog_id,</span><br><span class="line">    B.title         as blog_title,</span><br><span class="line">    B.author_id     as blog_author_id,</span><br><span class="line">    A.id            as author_id,</span><br><span class="line">    A.username      as author_username,</span><br><span class="line">    A.password      as author_password,</span><br><span class="line">    A.email         as author_email,</span><br><span class="line">    A.bio           as author_bio</span><br><span class="line">  from Blog B left outer join Author A on B.author_id = A.id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这个联合查询, 以及采取保护来确保所有结果被唯一而且清晰的名字来重命名。 这使得映射非常简单。现在我们可以映射这个结果:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">column</span>=<span class="string">"blog_author_id"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span> <span class="attr">resultMap</span>=<span class="string">"authorResult"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"authorResult"</span> <span class="attr">type</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"author_password"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"email"</span> <span class="attr">column</span>=<span class="string">"author_email"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bio"</span> <span class="attr">column</span>=<span class="string">"author_bio"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中你可以看到博客的作者关联代表着”authorResult”结果映射来加载作 者实例。</p><p>非常重要: 在嵌套据诶过映射中 id 元素扮演了非常重要的角色。应应该通常指定一个 或多个属性,它们可以用来唯一标识结果。实际上就是如果你离开她了,但是有一个严重的 性能问题时 MyBatis 仍然可以工作。选择的属性越少越好,它们可以唯一地标识结果。主键 就是一个显而易见的选择(尽管是联合主键)。</p><p>现在,上面的示例用了外部的结果映射元素来映射关联。这使得 Author 结果映射可以 重用。然而,如果你不需要重用它的话,或者你仅仅引用你所有的结果映射合到一个单独描 述的结果映射中。你可以嵌套结果映射。这里给出使用这种方式的相同示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"author_password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"email"</span> <span class="attr">column</span>=<span class="string">"author_email"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bio"</span> <span class="attr">column</span>=<span class="string">"author_bio"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果博客有一个共同作者呢?select语句如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    B.id            as blog_id,</span><br><span class="line">    B.title         as blog_title,</span><br><span class="line">    A.id            as author_id,</span><br><span class="line">    A.username      as author_username,</span><br><span class="line">    A.password      as author_password,</span><br><span class="line">    A.email         as author_email,</span><br><span class="line">    A.bio           as author_bio,</span><br><span class="line">    CA.id           as co_author_id,</span><br><span class="line">    CA.username     as co_author_username,</span><br><span class="line">    CA.password     as co_author_password,</span><br><span class="line">    CA.email        as co_author_email,</span><br><span class="line">    CA.bio          as co_author_bio</span><br><span class="line">  from Blog B</span><br><span class="line">  left outer join Author A on B.author_id = A.id</span><br><span class="line">  left outer join Author CA on B.co_author_id = CA.id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>回想一下，Author的resultMap定义如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"authorResult"</span> <span class="attr">type</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"author_password"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"email"</span> <span class="attr">column</span>=<span class="string">"author_email"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bio"</span> <span class="attr">column</span>=<span class="string">"author_bio"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于结果中的列名与resultMap中定义的列不同，因此您需要指定columnPrefix来重新使用resultMap，以便映射合Author的结果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">resultMap</span>=<span class="string">"authorResult"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"coAuthor"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">resultMap</span>=<span class="string">"authorResult"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">columnPrefix</span>=<span class="string">"co_"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面你已经看到了如何处理”有一个”类型关联。但是”有很多个”是怎样的?下面这 个部分就是来讨论这个主题的。</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"domain.blog.Post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"body"</span> <span class="attr">column</span>=<span class="string">"post_body"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br></pre></td></tr></table></figure><p>集合元素的作用几乎和关联是相同的。实际上,它们也很相似,文档的异同是多余的。 所以我们更多关注于它们的不同。</p><p>我们来继续上面的示例,一个博客只有一个作者。但是博客有很多文章。在博客类中, 这可以由下面这样的写法来表示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private List posts;</span><br></pre></td></tr></table></figure><p>要映射嵌套结果集合到 List 中,我们使用集合元素。就像关联元素一样,我们可以从 连接中使用嵌套查询,或者嵌套结果。</p><h4 id="集合的嵌套查询"><a href="#集合的嵌套查询" class="headerlink" title="集合的嵌套查询"></a>集合的嵌套查询</h4><p>首先,让我们看看使用嵌套查询来为博客加载文章。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">javaType</span>=<span class="string">"ArrayList"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span> <span class="attr">select</span>=<span class="string">"selectPostsForBlog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPostsForBlog"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里你应该注意很多东西,但大部分代码和上面的关联元素是非常相似的。首先,你应 该注意我们使用的是集合元素。然后要注意那个新的”ofType”属性。这个属性用来区分 JavaBean(或字段)属性类型和集合包含的类型来说是很重要的。所以你可以读出下面这个 映射:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">javaType</span>=<span class="string">"ArrayList"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span> <span class="attr">select</span>=<span class="string">"selectPostsForBlog"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>读作: “在 Post 类型的 ArrayList 中的 posts 的集合。”</p><p>javaType 属性是不需要的,因为 MyBatis 在很多情况下会为你算出来。所以你可以缩短 写法:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span> <span class="attr">select</span>=<span class="string">"selectPostsForBlog"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="集合的嵌套结果"><a href="#集合的嵌套结果" class="headerlink" title="集合的嵌套结果"></a>集合的嵌套结果</h4><p>至此,你可以猜测集合的嵌套结果是如何来工作的,因为它和关联完全相同,除了它应 用了一个”ofType”属性</p><p>First, let’s look at the SQL:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">  B.id as blog_id,</span><br><span class="line">  B.title as blog_title,</span><br><span class="line">  B.author_id as blog_author_id,</span><br><span class="line">  P.id as post_id,</span><br><span class="line">  P.subject as post_subject,</span><br><span class="line">  P.body as post_body,</span><br><span class="line">  from Blog B</span><br><span class="line">  left outer join Post P on B.id = P.blog_id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们又一次联合了博客表和文章表,而且关注于保证特性,结果列标签的简单映射。现 在用文章映射集合映射博客,可以简单写为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"body"</span> <span class="attr">column</span>=<span class="string">"post_body"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样,要记得 id 元素的重要性,如果你不记得了,请阅读上面的关联部分。</p><p>同样, 如果你引用更长的形式允许你的结果映射的更多重用, 你可以使用下面这个替代 的映射:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span> <span class="attr">resultMap</span>=<span class="string">"blogPostResult"</span> <span class="attr">columnPrefix</span>=<span class="string">"post_"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogPostResult"</span> <span class="attr">type</span>=<span class="string">"Post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"subject"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"body"</span> <span class="attr">column</span>=<span class="string">"body"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意 这个对你所映射的内容没有深度,广度或关联和集合相联合的限制。当映射它们 时你应该在大脑中保留它们的表现。 你的应用在找到最佳方法前要一直进行的单元测试和性 能测试。好在 myBatis 让你后来可以改变想法,而不对你的代码造成很小(或任何)影响。</p><p>高级关联和集合映射是一个深度的主题。文档只能给你介绍到这了。加上一点联系,你 会很快清楚它们的用法。</p><h4 id="鉴别器"><a href="#鉴别器" class="headerlink" title="鉴别器"></a>鉴别器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">"int"</span> <span class="attr">column</span>=<span class="string">"draft"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">resultType</span>=<span class="string">"DraftPost"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有时一个单独的数据库查询也许返回很多不同 (但是希望有些关联) 数据类型的结果集。 鉴别器元素就是被设计来处理这个情况的, 还有包括类的继承层次结构。 鉴别器非常容易理 解,因为它的表现很像 Java 语言中的 switch 语句。</p><p>定义鉴别器指定了 column 和 javaType 属性。 列是 MyBatis 查找比较值的地方。 JavaType 是需要被用来保证等价测试的合适类型(尽管字符串在很多情形下都会有用)。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"vehicleResult"</span> <span class="attr">type</span>=<span class="string">"Vehicle"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"vin"</span> <span class="attr">column</span>=<span class="string">"vin"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"year"</span> <span class="attr">column</span>=<span class="string">"year"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"make"</span> <span class="attr">column</span>=<span class="string">"make"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"model"</span> <span class="attr">column</span>=<span class="string">"model"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"color"</span> <span class="attr">column</span>=<span class="string">"color"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">"int"</span> <span class="attr">column</span>=<span class="string">"vehicle_type"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">resultMap</span>=<span class="string">"carResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"2"</span> <span class="attr">resultMap</span>=<span class="string">"truckResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"3"</span> <span class="attr">resultMap</span>=<span class="string">"vanResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"4"</span> <span class="attr">resultMap</span>=<span class="string">"suvResult"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个示例中, MyBatis 会从结果集中得到每条记录, 然后比较它的 vehicle 类型的值。 如果它匹配任何一个鉴别器的实例,那么就使用这个实例指定的结果映射。换句话说,这样 做完全是剩余的结果映射被忽略(除非它被扩展,这在第二个示例中讨论) 。如果没有任何 一个实例相匹配,那么 MyBatis 仅仅使用鉴别器块外定义的结果映射。所以,如果 carResult 按如下声明:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"carResult"</span> <span class="attr">type</span>=<span class="string">"Car"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"doorCount"</span> <span class="attr">column</span>=<span class="string">"door_count"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么只有 doorCount 属性会被加载。这步完成后完整地允许鉴别器实例的独立组,尽管 和父结果映射可能没有什么关系。这种情况下,我们当然知道 cars 和 vehicles 之间有关系, 如 Car 是一个 Vehicle 实例。因此,我们想要剩余的属性也被加载。我们设置的结果映射的 简单改变如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"carResult"</span> <span class="attr">type</span>=<span class="string">"Car"</span> <span class="attr">extends</span>=<span class="string">"vehicleResult"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"doorCount"</span> <span class="attr">column</span>=<span class="string">"door_count"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在 vehicleResult 和 carResult 的属性都会被加载了。</p><p>尽管曾经有些人会发现这个外部映射定义会多少有一些令人厌烦之处。 因此还有另外一 种语法来做简洁的映射风格。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"vehicleResult"</span> <span class="attr">type</span>=<span class="string">"Vehicle"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"vin"</span> <span class="attr">column</span>=<span class="string">"vin"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"year"</span> <span class="attr">column</span>=<span class="string">"year"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"make"</span> <span class="attr">column</span>=<span class="string">"make"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"model"</span> <span class="attr">column</span>=<span class="string">"model"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"color"</span> <span class="attr">column</span>=<span class="string">"color"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">"int"</span> <span class="attr">column</span>=<span class="string">"vehicle_type"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">resultType</span>=<span class="string">"carResult"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"doorCount"</span> <span class="attr">column</span>=<span class="string">"door_count"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"2"</span> <span class="attr">resultType</span>=<span class="string">"truckResult"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"boxSize"</span> <span class="attr">column</span>=<span class="string">"box_size"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"extendedCab"</span> <span class="attr">column</span>=<span class="string">"extended_cab"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"3"</span> <span class="attr">resultType</span>=<span class="string">"vanResult"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"powerSlidingDoor"</span> <span class="attr">column</span>=<span class="string">"power_sliding_door"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"4"</span> <span class="attr">resultType</span>=<span class="string">"suvResult"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"allWheelDrive"</span> <span class="attr">column</span>=<span class="string">"all_wheel_drive"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要记得 这些都是结果映射, 如果你不指定任何结果, 那么 MyBatis 将会为你自动匹配列 和属性。所以这些例子中的大部分是很冗长的,而其实是不需要的。也就是说,很多数据库 是很复杂的,我们不太可能对所有示例都能依靠它。</p><h3 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h3><p>正如你在前面一节看到的，在简单的场景下，MyBatis可以替你自动映射查询结果。 如果遇到复杂的场景，你需要构建一个result map。 但是在本节你将看到，你也可以混合使用这两种策略。 让我们到深一点的层面上看看自动映射是怎样工作的。</p><p>当自动映射查询结果时，MyBatis会获取sql返回的列名并在java类中查找相同名字的属性（忽略大小写）。 这意味着如果Mybatis发现了_ID_列和_id_属性，Mybatis会将_ID_的值赋给<em>id</em>。</p><p>通常数据库列使用大写单词命名，单词间用下划线分隔；而java属性一般遵循驼峰命名法。 为了在这两种命名方式之间启用自动映射，需要将 <code>mapUnderscoreToCamelCase</code>设置为true。</p><p>自动映射甚至在特定的result map下也能工作。在这种情况下，对于每一个result map,所有的ResultSet提供的列， 如果没有被手工映射，则将被自动映射。自动映射处理完毕后手工映射才会被处理。 在接下来的例子中， <em>id</em> 和 _userName_列将被自动映射， _hashed<em>password</em> 列将根据配置映射。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultMap</span>=<span class="string">"userResultMap"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    user_id             as "id",</span><br><span class="line">    user_name           as "userName",</span><br><span class="line">    hashed_password</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"hashed_password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有三个自动映射级别:</p><ul><li><code>NONE</code> - 禁用自动映射,只有手动映射属性才会被设置。</li><li><code>PARTIAL</code> - 将自动映射结果，除了那些嵌套结果映射（连接）内的结果。</li><li><code>FULL</code> - 自动映射一切</li></ul><p><code>默认值是 PARTIAL</code>,这是有原因的。 使用FULL时，将在处理连接结果时执行自动映射，并且连接会检索同一行中的多个不同实体的数据，因此可能会导致不需要的映射。 要了解风险，请查看下面的示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    B.id,</span><br><span class="line">    B.title,</span><br><span class="line">    A.username,</span><br><span class="line">  from Blog B left outer join Author A on B.author_id = A.id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">resultMap</span>=<span class="string">"authorResult"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"authorResult"</span> <span class="attr">type</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过这个结果地图，博客和作者将被自动映射。 但请注意，作者有一个id属性，并且ResultSet中有一个名为id的列，因此Author的id将填写Blog’s id，这不是您所期望的。 所以谨慎使用FULL选项。</p><p>无论配置的自动映射级别如何，您都可以通过向其添加属性autoMapping来启用或禁用特定ResultMap的自动映射：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span> <span class="attr">type</span>=<span class="string">"User"</span> <span class="attr">autoMapping</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"hashed_password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。MyBatis 3 中的缓存实现的很多改进都已经实现了,使得它更加强大而且易于配置。</p><p>默认情况下是没有开启缓存的,除了局部的 session 缓存,可以增强变现而且处理循环 依赖也是必须的。要开启二级缓存,你需要在你的 SQL 映射文件中添加一行:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>字面上看就是这样。这个简单语句的效果如下:</p><ul><li>映射语句文件中的所有 select 语句将会被缓存。</li><li>映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。</li><li>缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。</li><li>根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。</li><li>缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。</li><li>缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。</li></ul><p>所有的这些属性都可以通过缓存元素的属性来修改。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。</p><p>可用的收回策略有:</p><ul><li><code>LRU</code> – 最近最少使用的:移除最长时间不被使用的对象。</li><li><code>FIFO</code> – 先进先出:按对象进入缓存的顺序来移除它们。</li><li><code>SOFT</code> – 软引用:移除基于垃圾回收器状态和软引用规则的对象。</li><li><code>WEAK</code> – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li></ul><p>默认的是 LRU。</p><p>flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。</p><p>size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。</p><p>readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。</p><h4 id="使用自定义缓存"><a href="#使用自定义缓存" class="headerlink" title="使用自定义缓存"></a>使用自定义缓存</h4><p>除了这些自定义缓存的方式, 你也可以通过实现你自己的缓存或为其他第三方缓存方案 创建适配器来完全覆盖缓存行为。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"com.domain.something.MyCustomCache"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这个示 例展 示了 如何 使用 一个 自定义 的缓 存实 现。type 属 性指 定的 类必 须实现 org.mybatis.cache.Cache 接口。这个接口是 MyBatis 框架中很多复杂的接口之一,但是简单 给定它做什么就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Cache &#123;</span><br><span class="line">  String getId();</span><br><span class="line">  int getSize();</span><br><span class="line">  void putObject(Object key, Object value);</span><br><span class="line">  Object getObject(Object key);</span><br><span class="line">  boolean hasKey(Object key);</span><br><span class="line">  Object removeObject(Object key);</span><br><span class="line">  void clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要配置你的缓存, 简单和公有的 JavaBeans 属性来配置你的缓存实现, 而且是通过 cache 元素来传递属性, 比如, 下面代码会在你的缓存实现中调用一个称为 “setCacheFile(String file)” 的方法:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"com.domain.something.MyCustomCache"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheFile"</span> <span class="attr">value</span>=<span class="string">"/tmp/my-custom-cache.tmp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可以使用所有简单类型作为 JavaBeans 的属性,MyBatis 会进行转换。</p><p>记得缓存配置和缓存实例是绑定在 SQL 映射文件的命名空间是很重要的。因此,所有 在相同命名空间的语句正如绑定的缓存一样。 语句可以修改和缓存交互的方式, 或在语句的 语句的基础上使用两种简单的属性来完全排除它们。默认情况下,语句可以这样来配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"false"</span> <span class="attr">useCache</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>因为那些是默认的,你明显不能明确地以这种方式来配置一条语句。相反,如果你想改 变默认的行为,只能设置 flushCache 和 useCache 属性。比如,在一些情况下你也许想排除 从缓存中查询特定语句结果,或者你也许想要一个查询语句来刷新缓存。相似地,你也许有 一些更新语句依靠执行而不需要刷新缓存。</p><h3 id="参照缓存"><a href="#参照缓存" class="headerlink" title="参照缓存"></a>参照缓存</h3><p>回想一下上一节内容, 这个特殊命名空间的唯一缓存会被使用或者刷新相同命名空间内 的语句。也许将来的某个时候,你会想在命名空间中共享相同的缓存配置和实例。在这样的 情况下你可以使用 cache-ref 元素来引用另外一个缓存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"com.someone.application.data.SomeMapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>作者:W3Cschool<br>来源:<a href="https://www.w3cschool.cn/mybatis/f4uw1ilx.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.w3cschool.cn/mybatis/f4uw1ilx.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
            <tag> MyBatis基础教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis XML配置</title>
      <link href="/mybatis-xml-configuration/"/>
      <url>/mybatis-xml-configuration/</url>
      
        <content type="html"><![CDATA[<h2 id="XML-映射配置文件"><a href="#XML-映射配置文件" class="headerlink" title="XML 映射配置文件"></a>XML 映射配置文件</h2><p>MyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息。</p><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><p>这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。例如：</p><figure class="highlight plain"><figcaption><span>resource</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;dev_user&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;F2Fa3!33TYyg&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure><p>其中的属性就可以在整个配置文件中使用来替换需要动态配置的属性值。比如:</p><figure class="highlight plain"><figcaption><span>type</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dataSource&gt;</span><br></pre></td></tr></table></figure><p>这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。 driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。</p><p>属性也可以被传递到 SqlSessionBuilder.build()方法中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory factory &#x3D; sqlSessionFactoryBuilder.build(reader, props);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ... or ...</span><br><span class="line"></span><br><span class="line">SqlSessionFactory factory &#x3D; sqlSessionFactoryBuilder.build(reader, environment, props);</span><br></pre></td></tr></table></figure><p>如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载：</p><ul><li>在 properties 元素体内指定的属性首先被读取。</li><li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。</li><li>最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。</li></ul><p>因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。</p><h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。下表描述了设置中各项的意图、默认值等。</p><table><thead><tr><th>设置参数</th><th>描述</th><th>有效值</th><th>默认值</th></tr></thead><tbody><tr><td>cacheEnabled</td><td>该配置影响的所有映射器中配置的缓存的全局开关。</td><td>true,false</td><td>true</td></tr><tr><td>lazyLoadingEnabled</td><td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置<code>fetchType</code>属性来覆盖该项的开关状态。</td><td>true,false</td><td>false</td></tr><tr><td>aggressiveLazyLoading</td><td>当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载。</td><td>true,false,true</td><td></td></tr><tr><td>multipleResultSetsEnabled</td><td>是否允许单一语句返回多结果集（需要兼容驱动）。</td><td>true,false</td><td>true</td></tr><tr><td>useColumnLabel</td><td>使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。</td><td>true,false</td><td>true</td></tr><tr><td>useGeneratedKeys</td><td>允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。</td><td>true,false</td><td>False</td></tr><tr><td>autoMappingBehavior</td><td>指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。</td><td>NONE, PARTIAL, FULL</td><td>PARTIAL</td></tr><tr><td>defaultExecutorType</td><td>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</td><td>SIMPLE REUSE BATCH</td><td>SIMPLE</td></tr><tr><td>defaultStatementTimeout</td><td>设置超时时间，它决定驱动等待数据库响应的秒数。</td><td>Any positive integer</td><td>Not Set (null)</td></tr><tr><td>safeRowBoundsEnabled</td><td>允许在嵌套语句中使用分页（RowBounds）。</td><td>true,false</td><td>False</td></tr><tr><td>mapUnderscoreToCamelCase</td><td>是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。</td><td>true, false</td><td>False</td></tr><tr><td>localCacheScope</td><td>MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。</td><td>SESSION,STATEMENT</td><td>SESSION</td></tr><tr><td>jdbcTypeForNull</td><td>当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。</td><td>JdbcType enumeration. Most common are: NULL, VARCHAR and OTHER</td><td>OTHER</td></tr><tr><td>lazyLoadTriggerMethods</td><td>指定哪个对象的方法触发一次延迟加载。</td><td>A method name list separated by commas</td><td>equals,clone,hashCode,toString</td></tr><tr><td>defaultScriptingLanguage</td><td>指定动态 SQL 生成的默认语言。</td><td>A type alias or fully qualified class name.</td><td>org.apache.ibatis.scripting.<br>xmltags.<br>XMLDynamicLanguageDriver</td></tr><tr><td>callSettersOnNulls</td><td>指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。</td><td>true,false</td><td>false</td></tr><tr><td>logPrefix</td><td>指定 MyBatis 增加到日志名称的前缀。</td><td>Any String</td><td>Not set</td></tr><tr><td>logImpl</td><td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td><td>SLF4J,LOG4J,LOG4J2,<br>JDK_LOGGING,COMMONS_<br>LOGGING,STDOUT_LOGGING,<br>NO_LOGGING</td><td>Not set</td></tr><tr><td>proxyFactory</td><td>指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。</td><td>CGLIB JAVASSIST</td><td>CGLIB</td></tr></tbody></table><p>一个配置完整的 settings 元素的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">  &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">  &lt;setting name&#x3D;&quot;multipleResultSetsEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">  &lt;setting name&#x3D;&quot;useColumnLabel&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">  &lt;setting name&#x3D;&quot;useGeneratedKeys&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">  &lt;setting name&#x3D;&quot;autoMappingBehavior&quot; value&#x3D;&quot;PARTIAL&quot;&#x2F;&gt;</span><br><span class="line">  &lt;setting name&#x3D;&quot;defaultExecutorType&quot; value&#x3D;&quot;SIMPLE&quot;&#x2F;&gt;</span><br><span class="line">  &lt;setting name&#x3D;&quot;defaultStatementTimeout&quot; value&#x3D;&quot;25&quot;&#x2F;&gt;</span><br><span class="line">  &lt;setting name&#x3D;&quot;safeRowBoundsEnabled&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">  &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">  &lt;setting name&#x3D;&quot;localCacheScope&quot; value&#x3D;&quot;SESSION&quot;&#x2F;&gt;</span><br><span class="line">  &lt;setting name&#x3D;&quot;jdbcTypeForNull&quot; value&#x3D;&quot;OTHER&quot;&#x2F;&gt;</span><br><span class="line">  &lt;setting name&#x3D;&quot;lazyLoadTriggerMethods&quot; value&#x3D;&quot;equals,clone,hashCode,toString&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure><h2 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h2><p>类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。例如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Author"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Author"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Blog"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Blog"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Comment"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Comment"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Post"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Post"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Section"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Section"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Tag"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Tag"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当这样配置时，<code>Blog</code>可以用在任何使用<code>domain.blog.Blog</code>的地方。</p><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"domain.blog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Alias(&quot;author&quot;)</span><br><span class="line">public class Author &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经为许多常见的 Java 类型内建了相应的类型别名。它们都是大小写不敏感的，需要注意的是由基本类型名称重复导致的特殊处理。</p><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>object</td><td>Object</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr><tr><td>iterator</td><td>Iterator</td></tr></tbody></table><h2 id="typeHandlers"><a href="#typeHandlers" class="headerlink" title="typeHandlers"></a>typeHandlers</h2><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。</p><table><thead><tr><th>类型处理器</th><th>Java 类型</th><th>JDBC 类型</th></tr></thead><tbody><tr><td><code>BooleanTypeHandler</code></td><td><code>java.lang.Boolean</code>, <code>boolean</code></td><td>数据库兼容的 <code>BOOLEAN</code></td></tr><tr><td><code>ByteTypeHandler</code></td><td><code>java.lang.Byte</code>, <code>byte</code></td><td>数据库兼容的 <code>NUMERIC</code> 或 <code>BYTE</code></td></tr><tr><td><code>ShortTypeHandler</code></td><td><code>java.lang.Short</code>, <code>short</code></td><td>数据库兼容的 <code>NUMERIC</code> 或 <code>SHORT INTEGER</code></td></tr><tr><td><code>IntegerTypeHandler</code></td><td><code>java.lang.Integer</code>, <code>int</code></td><td>数据库兼容的 <code>NUMERIC</code> 或 <code>INTEGER</code></td></tr><tr><td><code>LongTypeHandler</code></td><td><code>java.lang.Long</code>, <code>long</code></td><td>数据库兼容的 <code>NUMERIC</code> 或 <code>LONG INTEGER</code></td></tr><tr><td><code>FloatTypeHandler</code></td><td><code>java.lang.Float</code>, <code>float</code></td><td>数据库兼容的 <code>NUMERIC</code> 或 <code>FLOAT</code></td></tr><tr><td><code>DoubleTypeHandler</code></td><td><code>java.lang.Double</code>, <code>double</code></td><td>数据库兼容的 <code>NUMERIC</code> 或 <code>DOUBLE</code></td></tr><tr><td><code>BigDecimalTypeHandler</code></td><td><code>java.math.BigDecimal</code></td><td>数据库兼容的 <code>NUMERIC</code> 或 <code>DECIMAL</code></td></tr><tr><td><code>StringTypeHandler</code></td><td><code>java.lang.String</code></td><td><code>CHAR</code>, <code>VARCHAR</code></td></tr><tr><td><code>ClobTypeHandler</code></td><td><code>java.lang.String</code></td><td><code>CLOB</code>, <code>LONGVARCHAR</code></td></tr><tr><td><code>NStringTypeHandler</code></td><td><code>java.lang.String</code></td><td><code>NVARCHAR</code>, <code>NCHAR</code></td></tr><tr><td><code>NClobTypeHandler</code></td><td><code>java.lang.String</code></td><td><code>NCLOB</code></td></tr><tr><td><code>ByteArrayTypeHandler</code></td><td><code>byte[]</code></td><td>数据库兼容的字节流类型</td></tr><tr><td><code>BlobTypeHandler</code></td><td><code>byte[]</code></td><td><code>BLOB</code>, <code>LONGVARBINARY</code></td></tr><tr><td><code>DateTypeHandler</code></td><td><code>java.util.Date</code></td><td><code>TIMESTAMP</code></td></tr><tr><td><code>DateOnlyTypeHandler</code></td><td><code>java.util.Date</code></td><td><code>DATE</code></td></tr><tr><td><code>TimeOnlyTypeHandler</code></td><td><code>java.util.Date</code></td><td><code>TIME</code></td></tr><tr><td><code>SqlTimestampTypeHandler</code></td><td><code>java.sql.Timestamp</code></td><td><code>TIMESTAMP</code></td></tr><tr><td><code>SqlDateTypeHandler</code></td><td><code>java.sql.Date</code></td><td><code>DATE</code></td></tr><tr><td><code>SqlTimeTypeHandler</code></td><td><code>java.sql.Time</code></td><td><code>TIME</code></td></tr><tr><td><code>ObjectTypeHandler</code></td><td>Any</td><td><code>OTHER</code> 或未指定类型</td></tr><tr><td><code>EnumTypeHandler</code></td><td>Enumeration Type</td><td>VARCHAR-任何兼容的字符串类型，存储枚举的名称（而不是索引）</td></tr><tr><td><code>EnumOrdinalTypeHandler</code></td><td>Enumeration Type</td><td>任何兼容的 <code>NUMERIC</code> 或 <code>DOUBLE</code> 类型，存储枚举的索引（而不是名称）。</td></tr></tbody></table><p>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 <code>org.apache.ibatis.type.TypeHandler</code> 接口， 或继承一个很便利的类 <code>org.apache.ibatis.type.BaseTypeHandler</code>， 然后可以选择性地将它映射到一个 JDBC 类型。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ExampleTypeHandler.java</span><br><span class="line">@MappedJdbcTypes(JdbcType.VARCHAR)</span><br><span class="line">public class ExampleTypeHandler extends BaseTypeHandler &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException &#123;</span><br><span class="line">    ps.setString(i, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String getNullableResult(ResultSet rs, String columnName) throws SQLException &#123;</span><br><span class="line">    return rs.getString(columnName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123;</span><br><span class="line">    return rs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123;</span><br><span class="line">    return cs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"org.mybatis.example.ExampleTypeHandler"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用这个的类型处理器将会覆盖已经存在的处理 Java 的 String 类型属性和 VARCHAR 参数及结果的类型处理器。 要注意 MyBatis 不会窥探数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指明那是 VARCHAR 类型的字段， 以使其能够绑定到正确的类型处理器上。 这是因为：MyBatis 直到语句被执行才清楚数据类型。</p><p>通过类型处理器的泛型，MyBatis 可以得知该类型处理器处理的 Java 类型，不过这种行为可以通过两种方法改变：</p><ul><li>在类型处理器的配置元素（typeHandler element）上增加一个 <code>javaType</code> 属性（比如：<code>javaType=&quot;String&quot;</code>）；</li><li>在类型处理器的类上（TypeHandler class）增加一个 <code>@MappedTypes</code> 注解来指定与其关联的 Java 类型列表。 如果在 <code>javaType</code> 属性中也同时指定，则注解方式将被忽略。</li></ul><p>可以通过两种方式来指定被关联的 JDBC 类型：</p><ul><li>在类型处理器的配置元素上增加一个 <code>javaType</code> 属性（比如：<code>javaType=&quot;VARCHAR&quot;</code>）；</li><li>在类型处理器的类上（TypeHandler class）增加一个 <code>@MappedJdbcTypes</code> 注解来指定与其关联的 JDBC 类型列表。 如果在 <code>javaType</code> 属性中也同时指定，则注解方式将被忽略。</li></ul><p>最后，可以让 MyBatis 为你查找类型处理器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"org.mybatis.example"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意在使用自动检索（autodiscovery）功能的时候，只能通过注解方式来指定 JDBC 的类型。</p><p>你能创建一个泛型类型处理器，它可以处理多于一个类。为达到此目的， 需要增加一个接收该类作为参数的构造器，这样在构造一个类型处理器的时候 MyBatis 就会传入一个具体的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;GenericTypeHandler.java</span><br><span class="line">public class GenericTypeHandler extends BaseTypeHandler &#123;</span><br><span class="line"></span><br><span class="line">  private Class type;</span><br><span class="line"></span><br><span class="line">  public GenericTypeHandler(Class type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;Type argument cannot be null&quot;);</span><br><span class="line">    this.type &#x3D; type;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><code>EnumTypeHandler</code> 和 <code>EnumOrdinalTypeHandler</code> 都是泛型类型处理器（generic TypeHandlers）， 我们将会在接下来的部分详细探讨。</p><h2 id="处理枚举类型"><a href="#处理枚举类型" class="headerlink" title="处理枚举类型"></a>处理枚举类型</h2><p>若想映射枚举类型 <code>Enum</code>，则需要从 <code>EnumTypeHandler</code> 或者 <code>EnumOrdinalTypeHandler</code> 中选一个来使用。</p><p>比如说我们想存储取近似值时用到的舍入模式。默认情况下，MyBatis 会利用 <code>EnumTypeHandler</code> 来把 <code>Enum</code> 值转换成对应的名字。</p><p><strong>注意 <code>EnumTypeHandler</code> 在某种意义上来说是比较特别的，其他的处理器只针对某个特定的类，而它不同，它会处理任意继承了 <code>Enum</code> 的类。</strong></p><p>不过，我们可能不想存储名字，相反我们的 DBA 会坚持使用整形值代码。那也一样轻而易举： 在配置文件中把 <code>EnumOrdinalTypeHandler</code> 加到 <code>typeHandlers</code> 中即可， 这样每个 <code>RoundingMode</code> 将通过他们的序数值来映射成对应的整形。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"org.apache.ibatis.type.EnumOrdinalTypeHandler"</span> <span class="attr">javaType</span>=<span class="string">"java.math.RoundingMode"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是怎样能将同样的 <code>Enum</code> 既映射成字符串又映射成整形呢？</p><p>自动映射器（auto-mapper）会自动地选用 <code>EnumOrdinalTypeHandler</code> 来处理， 所以如果我们想用普通的 <code>EnumTypeHandler</code>，就非要为那些 SQL 语句显式地设置要用到的类型处理器不可。</p><p>（下一节才开始讲映射器文件，所以如果是首次阅读该文档，你可能需要先越过这一步，过会再来看。）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">    <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.apache.ibatis.submitted.rounding.Mapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"org.apache.ibatis.submitted.rounding.User"</span> <span class="attr">id</span>=<span class="string">"usermap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"funkyNumber"</span> <span class="attr">property</span>=<span class="string">"funkyNumber"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"roundingMode"</span> <span class="attr">property</span>=<span class="string">"roundingMode"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">resultMap</span>=<span class="string">"usermap"</span>&gt;</span></span><br><span class="line">        select * from users</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span>&gt;</span></span><br><span class="line">        insert into users (id, name, funkyNumber, roundingMode) values (</span><br><span class="line">            #&#123;id&#125;, #&#123;name&#125;, #&#123;funkyNumber&#125;, #&#123;roundingMode&#125;</span><br><span class="line">        )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"org.apache.ibatis.submitted.rounding.User"</span> <span class="attr">id</span>=<span class="string">"usermap2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"funkyNumber"</span> <span class="attr">property</span>=<span class="string">"funkyNumber"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"roundingMode"</span> <span class="attr">property</span>=<span class="string">"roundingMode"</span> <span class="attr">typeHandler</span>=<span class="string">"org.apache.ibatis.type.EnumTypeHandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser2"</span> <span class="attr">resultMap</span>=<span class="string">"usermap2"</span>&gt;</span></span><br><span class="line">        select * from users2</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert2"</span>&gt;</span></span><br><span class="line">        insert into users2 (id, name, funkyNumber, roundingMode) values (</span><br><span class="line">            #&#123;id&#125;, #&#123;name&#125;, #&#123;funkyNumber&#125;, #&#123;roundingMode, typeHandler=org.apache.ibatis.type.EnumTypeHandler&#125;</span><br><span class="line">        )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，这里的 select 语句强制使用 <code>resultMap</code> 来代替 <code>resultType</code>。</p><h2 id="对象工厂（objectFactory）"><a href="#对象工厂（objectFactory）" class="headerlink" title="对象工厂（objectFactory）"></a>对象工厂（objectFactory）</h2><p>MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ExampleObjectFactory.java</span><br><span class="line">public class ExampleObjectFactory extends DefaultObjectFactory &#123;</span><br><span class="line">  public Object create(Class type) &#123;</span><br><span class="line">    return super.create(type);</span><br><span class="line">  &#125;</span><br><span class="line">  public Object create(Class type, List constructorArgTypes, List constructorArgs) &#123;</span><br><span class="line">    return super.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">  &#125;</span><br><span class="line">  public void setProperties(Properties properties) &#123;</span><br><span class="line">    super.setProperties(properties);</span><br><span class="line">  &#125;</span><br><span class="line">  public  boolean isCollection(Class type) &#123;</span><br><span class="line">    return Collection.class.isAssignableFrom(type);</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">"org.mybatis.example.ExampleObjectFactory"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someProperty"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ObjectFactory 接口很简单，它包含两个创建用的方法，一个是处理默认构造方法的，另外一个是处理带参数的构造方法的。 最后，setProperties 方法可以被用来配置 ObjectFactory，在初始化你的 ObjectFactory 实例后， objectFactory 元素体中定义的属性会被传递给 setProperties 方法。</p><h2 id="插件（plugins）"><a href="#插件（plugins）" class="headerlink" title="插件（plugins）"></a>插件（plugins）</h2><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li><li>ParameterHandler (getParameterObject, setParameters)</li><li>ResultSetHandler (handleResultSets, handleOutputParameters)</li><li>StatementHandler (prepare, parameterize, batch, update, query)</li></ul><p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 的发行包中的源代码。 假设你想做的不仅仅是监控方法的调用，那么你应该很好的了解正在重写的方法的行为。 因为如果在试图修改或重写已有方法的行为的时候，你很可能在破坏 MyBatis 的核心模块。 这些都是更低层的类和方法，所以使用插件的时候要特别当心。</p><p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定了想要拦截的方法签名即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ExamplePlugin.java</span><br><span class="line">@Intercepts(&#123;@Signature(</span><br><span class="line">  type&#x3D; Executor.class,</span><br><span class="line">  method &#x3D; &quot;update&quot;,</span><br><span class="line">  args &#x3D; &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><br><span class="line">public class ExamplePlugin implements Interceptor &#123;</span><br><span class="line">  public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    return invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line">  public Object plugin(Object target) &#123;</span><br><span class="line">    return Plugin.wrap(target, this);</span><br><span class="line">  &#125;</span><br><span class="line">  public void setProperties(Properties properties) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"org.mybatis.example.ExamplePlugin"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someProperty"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象。</p><p>NOTE <strong>覆盖配置类</strong></p><p>除了用插件来修改 MyBatis 核心行为之外，还可以通过完全覆盖配置类来达到目的。只需继承后覆盖其中的每个方法，再把它传递到 sqlSessionFactoryBuilder.build(myConfig) 方法即可。再次重申，这可能会严重影响 MyBatis 的行为，务请慎之又慎。</p><h2 id="配置环境（environments）"><a href="#配置环境（environments）" class="headerlink" title="配置环境（environments）"></a>配置环境（environments）</h2><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者共享相同 Schema 的多个生产数据库， 想使用相同的 SQL 映射。许多类似的用例。</p><p><strong>不过要记住：尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。</strong></p><p>所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：</p><ul><li><strong>每个数据库对应一个 SqlSessionFactory 实例</strong></li></ul><p>为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory factory &#x3D; sqlSessionFactoryBuilder.build(reader, environment);</span><br><span class="line">SqlSessionFactory factory &#x3D; sqlSessionFactoryBuilder.build(reader, environment,properties);</span><br></pre></td></tr></table></figure><p>如果忽略了环境参数，那么默认环境将会被加载，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory factory &#x3D; sqlSessionFactoryBuilder.build(reader);</span><br><span class="line">SqlSessionFactory factory &#x3D; sqlSessionFactoryBuilder.build(reader,properties);</span><br></pre></td></tr></table></figure><p>环境元素定义了如何配置环境。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">value</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里的关键点:</p><ul><li>默认的环境 ID（比如:default=”development”）。</li><li>每个 environment 元素定义的环境 ID（比如:id=”development”）。</li><li>事务管理器的配置（比如:type=”JDBC”）。</li><li>数据源的配置（比如:type=”POOLED”）。</li></ul><p>默认的环境和环境 ID 是一目了然的。随你怎么命名，只要保证默认环境要匹配其中一个环境ID。</p><p><strong>事务管理器（transactionManager）</strong></p><p>在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）：</p><ul><li>JDBC – 这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务范围。</li><li>MANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。例如:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"MANAGED"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"closeConnection"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br></pre></td></tr></table></figure><p>NOTE如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。</p><p>这两种事务管理器类型都不需要任何属性。它们不过是类型别名，换句话说，你可以使用 TransactionFactory 接口的实现类的完全限定名或类型别名代替它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionFactory &#123;</span><br><span class="line">  void setProperties(Properties props);</span><br><span class="line">  Transaction newTransaction(Connection conn);</span><br><span class="line">  Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何在 XML 中配置的属性在实例化之后将会被传递给 setProperties() 方法。你也需要创建一个 Transaction 接口的实现类，这个接口也很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Transaction &#123;</span><br><span class="line">  Connection getConnection() throws SQLException;</span><br><span class="line">  void commit() throws SQLException;</span><br><span class="line">  void rollback() throws SQLException;</span><br><span class="line">  void close() throws SQLException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这两个接口，你可以完全自定义 MyBatis 对事务的处理。</p><p><strong>数据源（dataSource）</strong></p><p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p><ul><li>许多 MyBatis 的应用程序将会按示例中的例子来配置数据源。然而它并不是必须的。要知道为了方便使用延迟加载，数据源才是必须的。</li></ul><p>有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）：</p><p><strong>UNPOOLED</strong>– 这个数据源的实现只是每次被请求时打开和关闭连接。虽然一点慢，它对在及时可用连接方面没有性能要求的简单应用程序是一个很好的选择。 不同的数据库在这方面表现也是不一样的，所以对某些数据库来说使用连接池并不重要，这个配置也是理想的。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：</p><ul><li><code>driver</code> – 这是 JDBC 驱动的 Java 类的完全限定名（并不是JDBC驱动中可能包含的数据源类）。</li><li><code>url</code> – 这是数据库的 JDBC URL 地址。</li><li><code>username</code> – 登录数据库的用户名。</li><li><code>password</code> – 登录数据库的密码。</li><li><code>defaultTransactionIsolationLevel</code> – 默认的连接事务隔离级别。</li></ul><p>作为可选项，你也可以传递属性给数据库驱动。要这样做，属性的前缀为”driver.”，例如：</p><ul><li><code>driver.encoding=UTF8</code></li></ul><p>这将通过DriverManager.getConnection(url,driverProperties)方法传递值为 <code>UTF8</code> 的 <code>encoding</code> 属性给数据库驱动。</p><p><strong>POOLED</strong>– 这种数据源的实现利用”池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p><p>除了上述提到 UNPOOLED 下的属性外，会有更多属性用来配置 POOLED 的数据源：</p><ul><li><code>poolMaximumActiveConnections</code> – 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10</li><li><code>poolMaximumIdleConnections</code> – 任意时间可能存在的空闲连接数。</li><li><code>poolMaximumCheckoutTime</code> – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）</li><li><code>poolTimeToWait</code> – 这是一个底层设置，如果获取连接花费的相当长的时间，它会给连接池打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。</li><li><code>poolPingQuery</code> – 发送到数据库的侦测查询，用来检验连接是否处在正常工作秩序中并准备接受请求。默认是”NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息。</li><li><code>poolPingEnabled</code> – 是否启用侦测查询。若开启，也必须使用一个可执行的 SQL 语句设置 <code>poolPingQuery</code> 属性（最好是一个非常快的 SQL），默认值：false。</li><li><code>poolPingConnectionsNotUsedFor</code> – 配置 poolPingQuery 的使用频度。这可以被设置成匹配具体的数据库连接超时时间，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。</li></ul><p><strong>JNDI</strong>– 这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这种数据源配置只需要两个属性：</p><ul><li><code>initial_context</code> – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么 data_source 属性将会直接从 InitialContext 中寻找。</li><li><code>data_source</code> – 这是引用数据源实例位置的上下文的路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。</li></ul><p>和其他数据源配置类似，可以通过添加前缀”env.”直接把属性传递给初始上下文。比如：</p><ul><li><code>env.encoding=UTF8</code></li></ul><p>这就会在初始上下文（InitialContext）实例化时往它的构造方法传递值为 <code>UTF8</code> 的 <code>encoding</code> 属性。</p><p>通过需要实现接口 <code>org.apache.ibatis.datasource.DataSourceFactory</code> ， 也可使用任何第三方数据源，：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface DataSourceFactory &#123;</span><br><span class="line">  void setProperties(Properties props);</span><br><span class="line">  DataSource getDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory</code> 可被用作父类来构建新的数据源适配器，比如下面这段插入 C3P0 数据源所必需的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;</span><br><span class="line">import com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line">public class C3P0DataSourceFactory extends UnpooledDataSourceFactory &#123;</span><br><span class="line"></span><br><span class="line">  public C3P0DataSourceFactory() &#123;</span><br><span class="line">    this.dataSource &#x3D; new ComboPooledDataSource();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了令其工作，为每个需要 MyBatis 调用的 setter 方法中增加一个属性。下面是一个可以连接至 PostgreSQL 数据库的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"org.myproject.C3P0DataSourceFactory"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"org.postgresql.Driver"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:postgresql:mydb"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"postgres"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="databaseIdProvider"><a href="#databaseIdProvider" class="headerlink" title="databaseIdProvider"></a>databaseIdProvider</h2><p>MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 <code>databaseId</code> 属性。 MyBatis 会加载不带 <code>databaseId</code> 属性和带有匹配当前数据库 <code>databaseId</code> 属性的所有语句。 如果同时找到带有 <code>databaseId</code> 和不带 <code>databaseId</code> 的相同语句，则后者会被舍弃。 为支持多厂商特性只要像下面这样在 mybatis-config.xml 文件中加入 <code>databaseIdProvider</code> 即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">"DB_VENDOR"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这里的 DB_VENDOR 会通过 <code>DatabaseMetaData#getDatabaseProductName()</code> 返回的字符串进行设置。 由于通常情况下这个字符串都非常长而且相同产品的不同版本会返回不同的值，所以最好通过设置属性别名来使其变短，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">"DB_VENDOR"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"SQL Server"</span> <span class="attr">value</span>=<span class="string">"sqlserver"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"DB2"</span> <span class="attr">value</span>=<span class="string">"db2"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"Oracle"</span> <span class="attr">value</span>=<span class="string">"oracle"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在有 properties 时，DB_VENDOR databaseIdProvider 的将被设置为第一个能匹配数据库产品名称的属性键对应的值，如果没有匹配的属性将会设置为 “null”。 在这个例子中，如果 <code>getDatabaseProductName()</code> 返回”Oracle (DataDirect)”，databaseId 将被设置为”oracle”。</p><p>你可以通过实现接口 <code>org.apache.ibatis.mapping.DatabaseIdProvider</code> 并在 mybatis-config.xml 中注册来构建自己的 DatabaseIdProvider：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DatabaseIdProvider</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties p)</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">getDatabaseId</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h2><p>既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 <code>file:///</code> 的 URL），或类名和包名等。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using classpath relative resources --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/builder/AuthorMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/builder/BlogMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/builder/PostMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using url fully qualified paths --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">"file:///var/mappers/AuthorMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">"file:///var/mappers/BlogMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">"file:///var/mappers/PostMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using mapper interface classes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"org.mybatis.builder.AuthorMapper"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"org.mybatis.builder.BlogMapper"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"org.mybatis.builder.PostMapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Register all interfaces in a package as mappers --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"org.mybatis.builder"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些配置会告诉了 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL 映射文件了，也就是接下来我们要讨论的。</p><blockquote><p>作者:W3Cschool<br>来源:<a href="https://www.w3cschool.cn/mybatis/7zy61ilv.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.w3cschool.cn/mybatis/7zy61ilv.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MyBatis基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
            <tag> MyBatis基础教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC阻塞队列之LinkedBlockingQueue源码分析</title>
      <link href="/juc-linkedBlockingQueue/"/>
      <url>/juc-linkedBlockingQueue/</url>
      
        <content type="html"><![CDATA[<p>LinkedBlockingQueue与ArrayBlockingQueue相对应也是一个有界队列并且同样遵守先进先出规则(FIFO)，它的默认和最大长度为<code>Integer.MAX_VALUE</code>，从名称可以得知，LinkedBlockingQueue底层是用链表实现的。下面我们对LinkedBlockingQueue的源码进行分析。</p><p>在分析LinkedBlockingQueue之前，我们先来了解一下LinkedBlockingQueue中几个重要的成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> &lt; <span class="title">E</span> &gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    Node &lt; E &gt; next;</span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列容量，默认为Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="comment">//队列中元素的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">//队列头结点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="comment">//队列尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="comment">//take或者poll操作持有的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//等待队列条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"><span class="comment">//put或者offer操作持有的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//等待队列条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p>从上面成员变量中我们发现队列中拥有两把锁，一个是<code>take</code>和<code>poll</code>操作用到的锁，一个是<code>put</code>和<code>offer</code>操作用到的锁，它是“双锁队列”算法的变体。而<code>count</code>成员变量维护成了成了一个原子字段，以避免在大多数情况下需要同时获取这两个锁。在看了这些重要的成员变量后，我们在来分析LinkedBlockingQueue的构造函数。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>LinkedBlockingQueue提供了3种构造方法，它们分别如下：</p><ol><li><p>方式一：默认构造函数</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认队列的长度为Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 默认构造函数设置队列长度为Integer.MAX_VALUE</p></li><li><p>方式二：给定初始长度构造</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量capacity</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//检查参数</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">//构建头结点和尾节点都指向一个空节点</span></span><br><span class="line">    last = head = <span class="keyword">new</span> Node &lt; E &gt; (<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 默认初始头结点和尾节点指向一个空节点</p></li><li><p>方式三：给定集合构造一个LinkedBlockingQueue</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection &lt; ? extends E &gt; c)</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认给定长度</span></span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">//获取重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    putLock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//将集合C中的元素添加到队列中</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e: c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">            <span class="comment">//向队列中添加元素  </span></span><br><span class="line">            enqueue(<span class="keyword">new</span> Node &lt; E &gt; (e));</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        count.set(n);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 此构造函数的作用就是将传入的集合c中的元素添加到LinkedBlockingQueue队列中去。添加元素方法<code>enqueue</code>我们在后面进行分析。</p></li></ol><h3 id="LinkedBlockingQueue入列操作"><a href="#LinkedBlockingQueue入列操作" class="headerlink" title="LinkedBlockingQueue入列操作"></a>LinkedBlockingQueue入列操作</h3><p>LinkedBlockingQueue提供了3种入列操作，他们分别是：</p><ul><li><code>put(E e) :</code>阻塞的向队列中插入元素，如果队列已满，则阻塞线程</li><li><code>offer(E e, long timeout, TimeUnit unit):</code>等待超时的向队列中插入元素，如果超时则返回false</li><li><code>offer(E e):</code>不阻塞的向队列中插入元素，如果队列已满，则返回false。插入成功返回true</li></ul><p>下面我们来分析这几个入列操作</p><h5 id="put-E-e-操作"><a href="#put-E-e-操作" class="headerlink" title="put(E e)操作:"></a>put(E e)操作:</h5><p>上面已经分析了put操作会阻塞线程，其元素如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//检查元素是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//构建节点</span></span><br><span class="line">    Node &lt; E &gt; node = <span class="keyword">new</span> Node &lt; E &gt; (e);</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="comment">//获取队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断队列是否已满</span></span><br><span class="line">        <span class="comment">//这里用while不用if是因为线程从await醒来后，需要再次判断队列是否已经满</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">//如果队列已满，则进入等待队列等待</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//队列未满，向队列中添加元素</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">//返回count中没自加之前的值</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">//判断元素是否已满</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            <span class="comment">//唤醒其它等待的线程</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//通知出列操作</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>put</code>操作的逻辑比较简单，首先判断参数是否合法，然后获取锁，获取锁后，判断队列是否已满，如果已满则进入等待队列等待，如果没有满则将元素添加到队列中去。之后再判断队列是否已满，如果未满则唤醒其它put或offer阻塞的线程。最后通知出列操作的线程，有元素可以出列。</p><h5 id="offer-E-e-操作："><a href="#offer-E-e-操作：" class="headerlink" title="offer(E e)操作："></a>offer(E e)操作：</h5><p><code>offer（E e）</code>操作为线程不阻塞的操作，在队列已满的情况下回直接返回false，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//检查元素合法性</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//获取队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">//如果队列满了，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//构建node节点</span></span><br><span class="line">    Node &lt; E &gt; node = <span class="keyword">new</span> Node &lt; E &gt; (e);</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//判断队列是否已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">        <span class="comment">//添加节点</span></span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="comment">//唤醒其它入列操作阻塞的线程</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//通知出列操作的线程</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>offer(E e)</code>操作和<code>put</code>操作非常相似，只是它没有阻塞的环节，其它的一样。</p><h5 id="offer-E-e-long-timeout-TimeUnit-unit-操作："><a href="#offer-E-e-long-timeout-TimeUnit-unit-操作：" class="headerlink" title="offer(E e, long timeout, TimeUnit unit)操作："></a>offer(E e, long timeout, TimeUnit unit)操作：</h5><p>超时等待，即在一定时间内阻塞，超过这个时间后直接返回。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//检查元素的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//获取要等待的时间nanos纳秒</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="comment">//获取队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//如果队列已满</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">        <span class="comment">//如果已经超时，则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//否则进行等待指定时间</span></span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果队列未满，则将元素添加到队列中去</span></span><br><span class="line">        enqueue(<span class="keyword">new</span> Node &lt; E &gt; (e));</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">        <span class="comment">//唤醒其它入列等待的线程</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//唤醒出列阻塞的线程</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>offer(E e, long timeout, TimeUnit unit)</code>方法与<code>put</code>方法也非常相似，只是该方法只阻塞timeout时间，如果时间到了则会返回不会继续阻塞。</p><p>上面3个入列操作的核心方法都是<code>enqueue</code>方法，我们看看该方法源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node &lt; E &gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将node节点指向为last的next</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>enqueue</code>方法非常简单，即将新构建的节点node指向last的next域，然后更新last节点指向为node节点。这里没有用锁的原因是调用该方法时必须获取到了锁。</p><h3 id="LinkedBlockingQueue出列操作"><a href="#LinkedBlockingQueue出列操作" class="headerlink" title="LinkedBlockingQueue出列操作"></a>LinkedBlockingQueue出列操作</h3><p>LinkedBlockingQueue同样提供了3个出列操作，它们分别是：</p><ul><li><code>take():</code>阻塞式的出列，如果队列为空，即线程进入等待队列等待</li><li><code>poll(long timeout, TimeUnit unit):</code>超时等待出列，如果队列为空，那么线程等待指定时长，超过指定时长后立即返回</li><li><code>E poll():</code>简单的处理，如果队列为空，则返回false</li></ul><p>下面我们来对这几个出列操作进行分析。</p><h5 id="take-出列操作"><a href="#take-出列操作" class="headerlink" title="take()出列操作:"></a>take()出列操作:</h5><p><code>take()</code>源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//获取队列中元素总数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">//获取take、poll 操作的锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列为空，则线程进入等待队列阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从队列中获取元素</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="comment">//1、获取取出元素之前队列中元素的个数</span></span><br><span class="line">        <span class="comment">//2、将count的值建一</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">//如果队列中还存在元素，则唤醒其它出列操作阻塞的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果队列中没有元素了，则唤醒入列操作阻塞的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>take()</code>操作的逻辑比较简单，上面注释已经写的比较清楚了。出列操作的核心方法dequeue在看过所有出列操作的方法再来分析。</p><h5 id="poll-long-timeout-TimeUnit-unit-出列操作："><a href="#poll-long-timeout-TimeUnit-unit-出列操作：" class="headerlink" title="poll(long timeout, TimeUnit unit)出列操作："></a>poll(long timeout, TimeUnit unit)出列操作：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//指定等待nanos纳秒</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="comment">//获取队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">//获取出列操作的锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列为空，则阻塞nanos纳秒</span></span><br><span class="line">        <span class="comment">//时间超过nanos纳秒后，直接返回false</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果队列不为空，则出列</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="comment">//1、获取取出元素之前队列中元素的个数</span></span><br><span class="line">        <span class="comment">//2、将count的值建一</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">//如果队列中还存在元素，则唤醒其它出列操作阻塞的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">////如果队列中没有元素了，则唤醒入列操作阻塞的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待超时的处理操作也是比价简单的，看上面注释就能理解。</p><h5 id="poll-处理操作："><a href="#poll-处理操作：" class="headerlink" title="poll()处理操作："></a>poll()处理操作：</h5><p><code>poll()</code>处理相比于上面两种出列操作更简单，因为它不会阻塞，在队列没有元素时，会直接返回null。我们来看看其源码定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">//如果队列中没有元素，则返回null</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//获取出列类型的锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列中有元素则获取元素</span></span><br><span class="line">        <span class="comment">//获取元素后，如果队列中还存在元素，则通知其它阻塞的处理操心线程</span></span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果队列中没有元素，则唤醒入列操作的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出列操作就都分享完成，下面我们来看看其核心方法<code>dequeue</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取头结点</span></span><br><span class="line">    Node &lt; E &gt; h = head;</span><br><span class="line">    <span class="comment">//第一个节点</span></span><br><span class="line">    Node &lt; E &gt; first = h.next;</span><br><span class="line">    <span class="comment">//将h的next指向自己</span></span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">//将head指向第一节点</span></span><br><span class="line">    head = first;</span><br><span class="line">    <span class="comment">//获取第一个节点的值</span></span><br><span class="line">    E x = first.item;</span><br><span class="line">    <span class="comment">//将第一节点的值设置为null</span></span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队列时，先将head节点的next指向自己，然后将head指向第一个节点，获取第一个节点的元素后将其设置为null,最后返回。</p><h3 id="LinkedBlockingQueue查看头结点元素"><a href="#LinkedBlockingQueue查看头结点元素" class="headerlink" title="LinkedBlockingQueue查看头结点元素"></a>LinkedBlockingQueue查看头结点元素</h3><p>LinkedBlockingQueue提供了查看头结点元素的方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果队列中没有元素，则返回null</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//获取出队列操作的锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取第一个节点</span></span><br><span class="line">        Node &lt; E &gt; first = head.next;</span><br><span class="line">        <span class="comment">//如果第一个节点为null,则返回null</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//返回第一个节点的值</span></span><br><span class="line">            <span class="keyword">return</span> first.item;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>peek</code>操作和出列操作的不同在于，出列操作会将节点移除，而<code>peek</code>操作只是查看队列头结点的值，而不会将节点移出队列。</p><h3 id="LinkedBlockingQueue删除操作"><a href="#LinkedBlockingQueue删除操作" class="headerlink" title="LinkedBlockingQueue删除操作"></a>LinkedBlockingQueue删除操作</h3><p>LinkedBlockingQueue提供了删除指定内容的操作，其源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  o [要删除的对象]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   [删除成功返回true，删除失败返回false]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果要删除的对象为null,返回false</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//获取到入列操作的锁同样获取到出列操作的锁</span></span><br><span class="line">    <span class="comment">//在remove操作时，不能进行入列和出列的操作</span></span><br><span class="line">    fullyLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//从头部开始变量节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node &lt; E &gt; trail = head, p = trail.next; p != <span class="keyword">null</span>; trail = p, p = p.next) &#123;</span><br><span class="line">            <span class="comment">//如果在队列中找到了知道删除的对象，则将该节点删除并返回true</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;</span><br><span class="line">                unlink(p, trail);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p     [要删除的节点]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> trail [待删除节点的前驱节点]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(Node &lt; E &gt; p, Node &lt; E &gt; trail)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将待删除节点的item设置成null</span></span><br><span class="line">    p.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//将p的next赋值给trail的next,即断开了p节点</span></span><br><span class="line">    trail.next = p.next;</span><br><span class="line">    <span class="comment">//如要待删除的节点是尾节点，则将p节点的前驱节点设置成新的尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (last == p)</span><br><span class="line">        last = trail;</span><br><span class="line">    <span class="comment">//删除节点后唤醒入列操作的线程</span></span><br><span class="line">    <span class="keyword">if</span> (count.getAndDecrement() == capacity)</span><br><span class="line">        notFull.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remove()</code>方法逻辑比较简单，唯一需要注意的就是该操作需要同时获取入列锁和出列锁。因此删除操作需要阻塞整个队列，在做删除操作时，即不能入列也不能出列。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>LinkedBlockingQueue的入列、出列和删除节点的逻辑都比较简单。它与ArrayBlockingQueue的逻辑几乎一致，这里我们对ArrayBlockingQueue和LinkedBlockingQueue做一个异同总结：</p><ul><li>相同：<ul><li>ArrayBlockingQueue和LinkedBlockingQueue都是有界阻塞队列，并且都是线程安全的。</li><li>ArrayBlockingQueue和LinkedBlockingQueue都遵守先进先出(FIFO)原则。</li><li>ArrayBlockingQueue和LinkedBlockingQueue都实现了BlockingQueue接口。</li><li>ArrayBlockingQueue和LinkedBlockingQueue都是基于ReentrantLock和Condition来保证生产和消费的同步。</li></ul></li><li>不同：<ul><li>ArrayBlockingQueue内部使用数组实现，LinkedBlockingQueue内部使用链表实现。</li><li>ArrayBlockingQueue在构造时需要传递初始容量大小，LinkedBlockingQueue在构造时可以不知道初始容量，当不指定初始容量时，其大小默认为Integer.MAX_VALUE。</li><li>ArrayBlockingQueue中锁是没有分离的，LinkedBlockingQueue中的锁是分离的，即生产用的是putLock，消费是takeLock。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> LinkedBlockingQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC阻塞队列之ArrayBlockingQueue源码分析</title>
      <link href="/juc-array-blocking-queue/"/>
      <url>/juc-array-blocking-queue/</url>
      
        <content type="html"><![CDATA[<p>ArrayBlockingQueue是一个由数组实现的有界阻塞队列。这个队列会按照先进先出（FIFO）的原则对元素进行排序。</p><p>ArrayBlockingQueue提供了公平性和非公平性的选择，默认情况下ArrayBlockingQueue不保证先出先出公平的访问队列，这里公平性的访问队列是指阻塞的线程可以按照阻塞的先后顺序访问队列，即先阻塞的线程先访问队列。反之先阻塞的线程不一定能够先访问队列即为非公平性。为了保证公平性，通常会降低吞吐量。</p><h3 id="ArrayBlockingQueue构造函数"><a href="#ArrayBlockingQueue构造函数" class="headerlink" title="ArrayBlockingQueue构造函数"></a>ArrayBlockingQueue构造函数</h3><p>ArrayBlockingQueue提供了3种构建队列的方式，他们分别如下：</p><ul><li>方式一：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用给定的容量来创建一个非公平性的ArrayBlockingQueue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式默认构建的是一个非公平性的有界阻塞队列。</p><ul><li>方式二：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用给定的容量大小和指定的访问策略来构建一个ArrayBlockingQueeu</span></span><br><span class="line"><span class="comment">// 当fair为false时，ArrayBlockingQueeu是非公平性的，反之，则为公平性的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数检测</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//初始化数组大小</span></span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    <span class="comment">//创建公平/非公平的重入锁</span></span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    <span class="comment">//队列不空的条件</span></span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    <span class="comment">//队列不满的条件</span></span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式三：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用给定的容量大小和指定的访问策略来构建一个ArrayBlockingQueeu并将传入的集合放到队列中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方式二的构建</span></span><br><span class="line">    <span class="keyword">this</span>(capacity, fair);</span><br><span class="line"><span class="comment">//获取构建时得到的重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock(); <span class="comment">// Lock only for visibility, not mutual exclusion</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                <span class="comment">//元素不能为null</span></span><br><span class="line">                checkNotNull(e);</span><br><span class="line">                <span class="comment">//将集合中的元素放入到队列中</span></span><br><span class="line">                items[i++] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        count = i;</span><br><span class="line">        <span class="comment">//put下一个元素的下标</span></span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数主要的逻辑就是初始化数组大小，并初始化公平/非公平的重入锁，并初始化队列满和空的条件。看完了构造函数，下面我们来看看ArrayBlokcingQueue的入列和出列操作。</p><h3 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h3><p>ArrayBlockingQueue提供了4种入列操作，分别如下：</p><ul><li><code>add(E e):</code>当队列满时，调用此方法向队列中插入元素会抛出<em>IllegalStateException(“Queue full”)</em>异常，添加元素成功返回true。</li><li><code>offer(E e):</code>当队列满时，调用此方法向队列中添加元素会返回false，添加元素成功则返回true。</li><li><code>put(E e) throws InterruptedException:</code>当队列满时，调用此方法向队列中添加元素，线程会被阻塞。直到队列不满或者线程被打断则从方法退出。</li><li><code>offer(E e, long timeout, TimeUnit unit) throws InterruptedException:</code> 当队列满时，调用此方法向队列中添加元素，会等待timout时间，当时间超过timeout时返回false。</li></ul><p>分析了这4种入列操作的不同，我们接下来看看在ArrayBlockingQueue中它们是如何实现的。</p><p><strong>add(E e)方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用父类的add方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续看父类的<code>add</code>方法做了什么操作，ArrayBlockingQueue继承了<code>AbstractQueue</code>这个了抽象类，那么调用父类的add方法就是调用<code>AbstractQueue</code>抽象类中的add方法，其方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用offer方法，如果成功则返回true，失败则抛出IllegalStateException异常</span></span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到父类的<code>add</code>方法实际是调用了子类的offer方法，前面我们说的offer方法在队列满时返回false，则队列还未满时，将元素添加到队列中并返回true。所以<code>add</code>方法是借助于<code>offer</code>方法来实现的。</p><p><strong>offer(E e)方法：</strong></p><p>offer(E e)方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查元素是否为null，为null则抛出NullPointerException异常</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断队列中的元素个数和队列的长度是否相等，相等标识队列已经满了，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//添加元素到队列并返回true</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>offer</code>方法利用ReentrantLock实现线程安全，offer方法逻辑比较简单，其主要添加的元素的逻辑在<code>enqueue</code>方法中，我们来看看<code>enqueue</code>方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">// 将元素添加到putIndex的位置</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="comment">// 如果队列满了，则将putIndex重置为0</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//队列中的元素个数自增</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">//唤醒阻塞在notEmpty条件上的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码中我们可以看出，<code>add</code>和<code>offer</code>方法在添加元素的时候并不会阻塞线程，<code>add</code>方法在队列满时抛出异常，<code>offer</code>方法在队列满时直接返回false。</p><p><strong>put(E e)方法：</strong></p><p>在前面我们说过<code>put</code>方法在向队列中添加元素时，如果队列满则会阻塞线程，直到线程被打断或者被其它线程通知，下面我们看看<code>put</code>方法的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//检查元素是否为null,如果为Null，则抛出NullPointerException异常</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//可中断的获取锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列满，则阻塞在notFull条件队列上</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">//如果队列没有满，则将元素添加到队列上</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>put</code>方法的逻辑也比较简单，这里如果看了LZ前面关于<a href>AQS之独占式同步状态的获取和释放</a>的这篇文章，则很好理解<code>lock.lockInterruptibly();</code>的作用，它的目的就是响应中断的获取锁，如果获取锁成功，则执行下面的代码，如果获取锁失败，则进入到同步队列中以自旋式的获取锁，直到线程被中断或者获取锁成功才会退出同步队列。</p><p><strong>offer(E e, long timeout, TimeUnit unit)方法：</strong></p><p>超时等待的向队列中添加元素，如果队列满时，调用该方法则会阻塞timeout时间，如果在此期间有线程取走了元素并且当前线程被唤醒则会将元素添加到队列中去，如果timeout时间后队列仍然是满的，则返回false，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//检查元素是否为null</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//将timeout转化为纳秒</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//可中断的获取锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列满并且已经超时，则返回false</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//阻塞</span></span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出列"><a href="#出列" class="headerlink" title="出列"></a>出列</h3><p>上面分析了ArrayBlockingQueue入列的情况，下面我们来分析ArrayBlockingQueue出列的情况。ArrayBlockingQueue同样提供了4种出列操作，它们分别是：</p><ul><li><code>E poll():</code>从队列的头部取出一个元素，如果队列为空，则返回null。</li><li><code>E take():</code>从队列的头部取出一个元素，如果队列为空，则阻塞。</li><li><code>E poll(long timeout, TimeUnit unit):</code>从队列头部取出一个元素，如果队列为空，则等待timeou时间。</li><li><code>E peek():</code>查看队列第一个非空的元素，并不会将次元素从队列中移除。</li></ul><p>对这些处理操作有了一个了解后我们来看看它们是如何实现的。</p><p><strong>poll()方法：</strong></p><p><code>poll</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列为空，则返回null,否则调用dequeue()方法</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>poll</code>方法逻辑很简单，其重点是<code>dequeue</code>方法，这里我们先不看<code>dequeue</code>方法我们接着看其它的出队操作。</p><p><strong>take()方法：</strong></p><p><code>take</code>方法是阻塞的从队列中获取元素，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列中没有元素，则等待</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>take</code>方法与前面介绍的<code>put</code>方法逻辑非常相似，只不过一个是添加元素一个是获取元素而已。这里我们看到<code>take</code>方法的核心仍然是<code>dequeue</code>方法。</p><p><strong>poll(long timeout, TimeUnit unit)方法：</strong></p><p>从方法参数中我们就可以判断出，该方法是等待超时的方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="comment">//获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//尝试获取锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列为空，则阻塞nanos纳秒</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现<code>poll()</code>、<code>take()</code>和<code>poll（long timeout，TimeUnit unit）</code>方法和核心都是<code>dequeue()</code>方法，那么接下来我们就看看<code>dequeue()</code>方法到底做了些什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// 获取takeIndex位置上的元素，默认情况下takeIndex为0</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    <span class="comment">// 将takeIndex位置上的元素置为null</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 判断takeIndex是不是最后一个位置，如果是则把takeIndex置为0</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//队列中的元素减一</span></span><br><span class="line">    count--;</span><br><span class="line">    <span class="comment">// 迭代器不为空，维护迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">// 唤醒入列的线程</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法逻辑很清晰，即从队列头takeIndex位置处获取元素，并将该位置置为null。如果取得的最后一个元素，则将takeIndex置为0。然后唤醒在入列过程中阻塞的线程。</p><p><strong>peek()方法：</strong></p><p><code>peek()</code>方法的目的是查看队列头元素，但是它并不会将该元素从队列中去掉。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此我们分析完了ArrayBlcokingQueue中入列和出列的全部方法。可以看出ArrayBlockingQueue入列和出列的逻辑还是比较简单的。下一篇LZ将分析右链表结果组成的有界队列LinkedBlockingQueue。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> ArrayBlockingQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发容器之ConcurrentLinkedQueue源码分析</title>
      <link href="/juc-concurrent-linkedqueue/"/>
      <url>/juc-concurrent-linkedqueue/</url>
      
        <content type="html"><![CDATA[<p>在并发编程中，我们有时需要使用到线程安全的队列，而线程安全队列的实现一般有两种方式：一种是使用阻塞算法，一种是使用非阻塞算法。使用阻塞算法的队列可以使用一把锁(入列和出列使用同一把锁)或两把锁(入列和出列使用不同的锁)来实现的。非阻塞算法方式则是利用循环CAS来实现的。这一章我们就来探索一下非阻塞算法实现的线程安全队列ConcurrentLinkedQueue。</p><p>ConcurrentLinkedQueue规定了如下几个不变性：</p><ol><li>如果队列中存在元素，那么最后一个元素的next为null</li><li>队列中所有未删除的节点的item都不能为null且都能从head节点遍历到</li><li>对于要删除的节点，不是直接将其设置为null，而是先将其item域设置为null（迭代器会跳过item为null的节点）</li><li>允许head和tail更新滞后。即head、tail不总是指向第一个元素和最后一个元素。</li></ol><h3 id="ConcurrentLinkedQueue的结构"><a href="#ConcurrentLinkedQueue的结构" class="headerlink" title="ConcurrentLinkedQueue的结构"></a>ConcurrentLinkedQueue的结构</h3><p>通过ConcurrentLinkedQueue的类图我们来分析下它的结构，类图如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/concurrentLinkedQueue%E7%B1%BB%E5%9B%BE.png"  alt></p><p>由上面ConcurrentLinkedQueue的类图，我们可以看出ConcurrentLinkedQueue是由head和tail节点组成，每个节点（Node）又有元素item和指向下一个节点的引用next组成，节点与节点之间就是通过next进行关联的。默认情况下head和tail相等并且都等于空。我们先来看看ConcurrentLinkedQueue的重要组成部分节点的源码定义。</p><h3 id="Node定义"><a href="#Node定义" class="headerlink" title="Node定义"></a>Node定义</h3><p>Node源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//内容</span></span><br><span class="line">    <span class="keyword">volatile</span> E item;</span><br><span class="line">    <span class="comment">//指向下一个节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    Node(E item) &#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//CAS方式更新item的值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//CAS方式更新next的值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="comment">//当前结点的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">    <span class="comment">//下一个结点的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = Node<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"item"</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node的定义比较简单，接下来我们分析ConcurrentLinkedQueue源码</p><h3 id="ConcurrentLinkedQueue初始化"><a href="#ConcurrentLinkedQueue初始化" class="headerlink" title="ConcurrentLinkedQueue初始化"></a>ConcurrentLinkedQueue初始化</h3><p>ConcurrentLinkedQueue定义了两个构造函数，默认的构造函数是构建一个初始为空的ConcurrentLinkedQueue。构造函数定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始一个为空的ConcurrentLinkedQueue,此时head和tail都指向一个item为空的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入一个集合来初始化ConcurrentLinkedQueue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = <span class="keyword">null</span>, t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//遍历传入的结合c</span></span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        <span class="comment">//集合中的每个元素不能为空</span></span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>)</span><br><span class="line">            h = t = newNode;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将t的next值设置为newNode</span></span><br><span class="line">            t.lazySetNext(newNode);</span><br><span class="line">            t = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>)</span><br><span class="line">        h = t = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    head = h;</span><br><span class="line">    tail = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完了ConcurrentLinkedQueue的初始化，接下来我们分析ConcurrentLinkedQueue的入队与出队操作。</p><h3 id="ConcurrentLinkedQueue入队操作"><a href="#ConcurrentLinkedQueue入队操作" class="headerlink" title="ConcurrentLinkedQueue入队操作"></a>ConcurrentLinkedQueue入队操作</h3><p>对于熟悉链表结构的同学来说，入列是一个很简单的事情，即找到队列的尾节点，然后将尾节点的next赋值为新的节点，然后更新尾节点为新的节点即可。对于单线程，这样操作完全没有问题，但是对于多线程呢？如果一个线程要执行入列操作，那么它必须先找到尾节点，然后更新尾节点的next值，但是在更新next的值之前，如果有另一个线程此时正好已经更新尾节点，那么数据是不是会出现丢失的情况？对于多线程下的情况，我们来看看ConcurrentLinkedQueue是如何解决的。我们先看入列操作的offer(E e) 方法，该方法是将指定元素插入到队列尾部，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//检查要插入的节点是否为空，为空则直接抛出NullPointerException异常</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//构建新的节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 死循环，直到新的节点插入为止</span></span><br><span class="line"><span class="comment">    * 1、根据tail节点定位出尾节点（last node）</span></span><br><span class="line"><span class="comment">    * 2、将新节点置为尾节点的下一个节点</span></span><br><span class="line"><span class="comment">    * 3、cas Tail更新尾节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，初始情况下等于tail节点</span></span><br><span class="line">        <span class="comment">// q是p的next节点</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="comment">//q == null 表示 p已经是最后一个节点了，尝试加入到队列尾</span></span><br><span class="line">        <span class="comment">//如果插入失败，则表示其他线程已经修改了p的指向</span></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// casNext：t节点的next指向当前节点</span></span><br><span class="line">            <span class="comment">// casTail：设置tail 尾节点</span></span><br><span class="line">            <span class="comment">// 设置p节点的下一个节点为新节点，设置成功则casNext返回true；否则返回false，说明有其他线程更新过尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// 如果p != t，则将入队节点设置成tail节点，更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点</span></span><br><span class="line">                <span class="comment">//这里p!=t是因为tail并不是每次都指向最后一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p == q 等于自身</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// p == q 代表着该节点已经被删除了</span></span><br><span class="line">            <span class="comment">// 由于多线程的原因，我们offer()的时候也会poll()，如果offer()的时候正好该节点已经poll()了</span></span><br><span class="line">            <span class="comment">// 那么在poll()方法中的updateHead()方法会将head指向当前的q，而把p.next指向自己，即：p.next == p</span></span><br><span class="line">            <span class="comment">// 这样就会导致tail节点滞后head（tail位于head的前面），则需要重新设置p</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="comment">// tail并没有指向尾节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// tail已经不是最后一个节点，将p指向最后一个节点</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码角度来看，整个入队过程主要做了两件事：</p><ol><li>定位出尾节点</li><li>使用CAS算法将新入队节点设置成尾节点的next节点，如不成功则重试</li></ol><p>第一步定位出尾节点，tail节点并不一定是尾节点，所有每次入列都必须通过tail来找到尾节点。尾节点有可能就是tail节点，也有可能是tail节点的next。循环体中的第一个条件判断就是判断tail节点的next是否为空，如果为空，则表示tail节点就是尾节点，否则表示tail的next节点才是尾节点。</p><p>第二步设置入队节点为尾节点。p.casNext(null, newNode)方法用于将入队节点设置为当前队列尾节点的next节点，q如果是null表示p是当前队列的尾节点，如果不为null表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</p><h3 id="tail节点不一定为尾节点的设计意图"><a href="#tail节点不一定为尾节点的设计意图" class="headerlink" title="tail节点不一定为尾节点的设计意图"></a>tail节点不一定为尾节点的设计意图</h3><p>看到这里，我们可以会疑惑，tail为什么不总是最后一个节点，Doug  Lea大神这样设计的好处又是什么？接下来我们先探讨下tail节点不一定为尾节点的设计用意。</p><p>如果我们将tail永远的指向尾节点，那么在入列的时候，每次必定要执行<code>casTail(t, newNode)</code>这条语句，这就增加了一次volatile变量写操作的开销，而我们知道volatile变量的写操作的开销远大于volatile变量读操作的开销，因此Doug Lea大神的设计是通过增加volatile变量的读操作来减少volatile变量的写操作，这样入队的效率会有所提升。我们不得不佩服Doug Lea 大神的天才设计。</p><p>ConcurrentLinkedQueue的入队操作整体逻辑如下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%85%A5%E5%88%97%E8%BF%87%E7%A8%8B.png"  alt></p><h3 id="ConcurrentLinkedQueue出队操作"><a href="#ConcurrentLinkedQueue出队操作" class="headerlink" title="ConcurrentLinkedQueue出队操作"></a>ConcurrentLinkedQueue出队操作</h3><p>出队列就是从队列中返回一个节点元素，并清空这个节点元素的引用。首先我们还是来看看出队列的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//从head节点开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="comment">// 获取p节点的元素</span></span><br><span class="line">            E item = p.item;</span><br><span class="line">    <span class="comment">// 如果p节点的元素为空且CAS更新item成功</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;                             <span class="comment">// 条件①</span></span><br><span class="line">                <span class="comment">// p和h不相等，则更新头结点，否则直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time                               // 条件②  </span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外一个线程修改了。</span></span><br><span class="line">            <span class="comment">// 那么获取p节点的下一个节点，如果p节点的下一节点为null，则表明队列已经空了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;                                         <span class="comment">//条件③</span></span><br><span class="line">                <span class="comment">//更新头结点，预期值h=head,更新p.此时p的item是空，说明已经被出队了</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p == q，则使用新的head重新开始</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)                                                         <span class="comment">//条件④</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法主要逻辑就是首先取出队列的头结点，然后判断头结点元素是否为空，如果为空，则表示有另一个线程已经进行了一次出队操作将该节点取走，如果不为空，则使用CAS方法将头结点的item设置成空，如果CAS设置成功，判断p和q是否相等，如果不相等则更新头结点，否则直接返回。如CAS设置失败，则表示出现了并发，需要重新从头结点遍历。下面我们还是来模拟出队列的操作。首先假设队列初始如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%87%BA%E9%98%9F%E5%88%97_0.png"  alt></p><p><strong>poll 节点A：</strong></p><p>此时p=h=head,而head此时执行的是一个空节点即p.item=null,因此条件①不成立，跳到条件③（(q = p.next) == null），条件③也不成立，最后把执行p = q，然后再次循环。此时各个变量如下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%87%BA%E9%98%9F%E5%88%97_1.png"  alt></p><p>此时p指向节点A，因此p.item ！=null ，进行p.casItem(item, null)，如果这个CAS成功，发现p!=h,因此执行updateHead(h, ((q = p.next) != null) ? q : p)，q=p.next此时指向节点B,不为空，则将head CAS更新成节点B，如下所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%87%BA%E9%98%9F%E5%88%97_2.png"  alt></p><p><strong>poll节点B：</strong></p><p>此时h=head,p=h,因此item = p.item = B,条件①成功，发现条件p=h，因此直接return，结果如下图：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%87%BA%E9%98%9F%E5%88%97_3.png"  alt></p><p><strong>poll节点C：</strong></p><p>此时h = head, p = h，item = p.item=null,因此条件①不成立，跳到条件③（(q = p.next) == null，此时p.next=节点C！=null）,条件③不成立，跳到条件④，发现条件④也不成立，因此直接运行p = q;然后再次运行。此时各个变量如下所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%87%BA%E9%98%9F%E5%88%97_4.png"  alt></p><p>此时条件①成立，条件②也成立，因此执行updateHead(h, ((q = p.next) != null) ? q : p);执行后如下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%87%BA%E9%98%9F%E5%88%97_5.png"  alt></p><p>看完上面poll的流程，我们在回去看offer操作中的这段操作，我们就能明白了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">    <span class="comment">// p == q 代表着该节点已经被删除了</span></span><br><span class="line">    <span class="comment">// 由于多线程的原因，我们offer()的时候也会poll()，如果offer()的时候正好该节点已经poll()了</span></span><br><span class="line">    <span class="comment">// 那么在poll()方法中的updateHead()方法会将head指向当前的q，而把p.next指向自己，即：p.next == p</span></span><br><span class="line">    <span class="comment">// 这样就会导致tail节点滞后head（tail位于head的前面），则需要重新设置p</span></span><br><span class="line">    p = (t != (t = tail)) ? t : head;</span><br></pre></td></tr></table></figure><p>此时我们发现，p==q即表示该节点已经被删除了，而poll()方法中的updateHead()方法会更新head的指向，因此tail会滞后head,如上图所示。如果该节点是被删除了，则判断下tail是否有改动，如果有，则p指向新的tail,如果没有，则把p指向head。</p><p>如果此时，我们再向队列中添加节点D，此时p=q,更新p节点为head节点，重新循环，此时q=p.next为null,直接添加元素到p.next中，并更新tail节点。如下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%85%A5%E5%88%97_6.png"  alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ConcurrentLinkedQueue 的非阻塞算法实现可概括为下面 5 点：</p><ul><li>使用 CAS 原子指令来处理对数据的并发访问，这是非阻塞算法得以实现的基础。</li><li>head/tail 并非总是指向队列的头 / 尾节点，也就是说允许队列处于不一致状态。 这个特性把入队 / 出队时，原本需要一起原子化执行的两个步骤分离开来，从而缩小了入队 / 出队时需要原子化更新值的范围到唯一变量。这是非阻塞算法得以实现的关键。</li><li>由于队列有时会处于不一致状态。为此，ConcurrentLinkedQueue 使用三个不变式来维护非阻塞算法的正确性。</li><li>以批处理方式来更新 head/tail，从整体上减少入队 / 出队操作的开销。</li><li>为了有利于垃圾收集，队列使用特有的 head 更新机制；为了确保从已删除节点向后遍历，可到达所有的非删除节点，队列使用了特有的向后推进策略。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> ConcurrentLinkedQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发容器之ConcurrentHashMap之红黑树源码分析</title>
      <link href="/juc-redblacktree/"/>
      <url>/juc-redblacktree/</url>
      
        <content type="html"><![CDATA[<p>在分析ConcurrentHashMap中有关红黑树的源码之前，我们先要对红黑树进行一定的了解。</p><h2 id="红黑树介绍"><a href="#红黑树介绍" class="headerlink" title="红黑树介绍"></a>红黑树介绍</h2><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构。它是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。</p><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p><ol><li>节点是红色或者黑色</li><li>根节点是黑色</li><li>每个叶子节点（NIL）都是黑色的空节点<strong>[注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</strong></li><li>每个红色节点的两个子节点都是黑色</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li></ol><p>下图就是一颗典型的红黑树</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84.png"  alt="红黑树结构"></p><h2 id="红黑树的旋转"><a href="#红黑树的旋转" class="headerlink" title="红黑树的旋转"></a>红黑树的旋转</h2><p>红黑树在删除或者添加节点后都会用到旋转和着色方法，这是因为在添加或者删除红黑树的节点后，红黑树就发生了变化，这就有可能不满足红黑树的5条基本性质了，也就不再是一颗红黑树了。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。</p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>左旋的定义如下：</p><blockquote><p>以某个节点作为支点（旋转点）进行左旋，那么该支点的右子节点变为旋转点的父节点，右子节点的左子节点变为旋转点的右子节点，训传点的左子节点保持不变</p></blockquote><p>下图即为左旋操作：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B7%A6%E6%97%8B.jpg"  alt="红黑树左旋"></p><p>左旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点x进行左旋”是如何进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LEFT-ROTATE(T, x)  </span><br><span class="line"> y ← right[x]            <span class="comment">// 前提：这里假设x的右孩子为y。下面开始正式操作</span></span><br><span class="line"> right[x] ← left[y]      <span class="comment">// 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子</span></span><br><span class="line"> p[left[y]] ← x          <span class="comment">// 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x</span></span><br><span class="line"> p[y] ← p[x]             <span class="comment">// 将 “x的父亲” 设为 “y的父亲”</span></span><br><span class="line"> <span class="keyword">if</span> p[x] = nil[T]       </span><br><span class="line"> then root[T] ← y                 <span class="comment">// 情况1：如果 “x的父亲” 是空节点，则将y设为根节点</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> x = left[p[x]]  </span><br><span class="line">           then left[p[x]] ← y    <span class="comment">// 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span></span><br><span class="line">           <span class="keyword">else</span> right[p[x]] ← y   <span class="comment">// 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”</span></span><br><span class="line"> left[y] ← x             <span class="comment">// 将 “x” 设为 “y的左孩子”</span></span><br><span class="line"> p[x] ← y                <span class="comment">// 将 “x的父节点” 设为 “y”</span></span><br></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>右旋的定义如下：</p><blockquote><p>以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变</p></blockquote><p>右旋示意图如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8F%B3%E6%97%8B.jpg"  alt="红黑树右旋"></p><p>右旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点y进行右旋”是如何进行的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RIGHT-ROTATE(T, y)  </span><br><span class="line"> x ← left[y]             <span class="comment">// 前提：这里假设y的左孩子为x。下面开始正式操作</span></span><br><span class="line"> left[y] ← right[x]      <span class="comment">// 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子</span></span><br><span class="line"> p[right[x]] ← y         <span class="comment">// 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y</span></span><br><span class="line"> p[x] ← p[y]             <span class="comment">// 将 “y的父亲” 设为 “x的父亲”</span></span><br><span class="line"> <span class="keyword">if</span> p[y] = nil[T]       </span><br><span class="line"> then root[T] ← x                 <span class="comment">// 情况1：如果 “y的父亲” 是空节点，则将x设为根节点</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> y = right[p[y]]  </span><br><span class="line">           then right[p[y]] ← x   <span class="comment">// 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”</span></span><br><span class="line">           <span class="keyword">else</span> left[p[y]] ← x    <span class="comment">// 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”</span></span><br><span class="line"> right[x] ← y            <span class="comment">// 将 “y” 设为 “x的右孩子”</span></span><br><span class="line"> p[y] ← x                <span class="comment">// 将 “y的父节点” 设为 “x”</span></span><br></pre></td></tr></table></figure><h2 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h2><p>在分享红黑树的插入之前，我们先将节点的名称做如下规范：</p><ul><li>I节点：插入节点</li><li>P节点：插入节点的父节点</li><li>PP节点：插入节点的祖父节点</li><li>S节点：插入节点的叔叔节点</li></ul><p>红黑树的插入操作可以简单的分为两个步骤，它们分别是一：找到插入的位置，二：插入和自平衡。插入操作的步骤如下：</p><ol><li>从根节点开始查找；</li><li>如果根节点为空，则将插入的节点作为根节点，然后结束。</li><li>若根结点不为空，那么把根结点作为当前结点；</li><li>若当前结点为null，返回当前结点的父结点，结束。</li><li>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</li></ol><p>插入位置已经找到，把插入结点放到正确的位置就可以啦，但插入结点应该是什么颜色呢？答案是<strong>红色</strong>。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。</p><p>插入情景和处理如下所示</p><ul><li><p><strong>情景1</strong>：红黑树为空树</p><p>  处理：</p><ul><li>把插入的节点作为根节点，并将节点颜色设置为黑色</li></ul></li><li><p><strong>情景2</strong>：插入节点的Key已经存在</p><p>  处理：</p><ul><li>把I设置为当前节点的颜色</li><li>更新当前接的值为插入节点的值</li></ul></li><li><p><strong>情景3</strong>：插入节点的父节点为黑色节点</p><p>  处理：</p><ul><li>直接插入</li></ul></li><li><p><strong>情景4</strong>：插入节点的父节点为红色节点，这种情况又分如下几种情景：</p><ul><li><p><strong>情景4.1</strong>：叔叔节点存在并且为红色节点</p><p>  处理：</p><ul><li>将P(父节点)和S(叔叔节点)设置为黑色</li><li>将PP(祖父节点)设置为红色</li><li>把PP（祖父节点）设置为当前插入节点，即，之后继续对“当前节点”进行操作。</li></ul></li><li><p><strong>情景4.2</strong>：叔叔节点不存在或者为黑色节点，并且插入节点的父节点是祖父节点的左子节点，这种情况又分为以下2中情况：</p><ul><li><p><strong>情景4.2.1</strong>：插入节点是其父节点的左子节点</p><p>  处理：</p><ul><li>将P（父节点）设置为黑色</li><li>将PP（祖父节点）设置为红色</li><li>对PP（祖父节点）进行右旋</li></ul></li><li><p><strong>情景4.2.2</strong>：插入节点是其父节点的右子节点</p><p>  处理：</p><ul><li>对P（父节点）进行左旋</li><li>把P（父节点）设置为当前节点，得到情景4.2.1</li><li>进行情景4.2.1的处理</li></ul></li></ul></li><li><p><strong>情景4.3</strong>：叔叔节点不存在或者为黑色节点，并且插入节点的父节点是祖父节点的右子节点，，这种情况又分为以下2中情况：</p><ul><li><p><strong>情景4.3.1</strong>：插入节点是其父节点的左子节点</p><p>  处理：</p><ul><li>将P（父节点）设置为黑色</li><li>将PP（祖父节点）设置为红色</li><li>对PP（祖父节点）进行左旋</li></ul></li><li><p><strong>情景4.3.2</strong>：插入节点是其父节点的右子节点</p><p>  处理：</p><ul><li>对P（父节点）进行右旋</li><li>把P（父节点）设置为当前节点，得到情景4.3.1</li><li>进行情景4.3.1的处理</li></ul></li></ul></li></ul></li></ul><p>上述插入的情景非常多，有的也比较复杂，接下来我们一一的进行分析。</p><h3 id="情景1：红黑树为空树"><a href="#情景1：红黑树为空树" class="headerlink" title="情景1：红黑树为空树"></a>情景1：红黑树为空树</h3><p>最简单的一种情景，直接把插入结点作为根结点就行，但注意，根据红黑树性质2：根节点是黑色。还需要把插入结点设为黑色。</p><p>处理策略：</p><ul><li>把插入结点作为根结点，并把结点设置为黑色</li></ul><h3 id="插入情景2：插入结点的Key已存在"><a href="#插入情景2：插入结点的Key已存在" class="headerlink" title="插入情景2：插入结点的Key已存在"></a>插入情景2：插入结点的Key已存在</h3><p>插入结点的Key已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。</p><p>处理策略：</p><ul><li>把I设为当前结点的颜色</li><li>更新当前结点的值为插入结点的值</li></ul><h3 id="插入情景3：插入结点的父结点为黑结点"><a href="#插入情景3：插入结点的父结点为黑结点" class="headerlink" title="插入情景3：插入结点的父结点为黑结点"></a>插入情景3：插入结点的父结点为黑结点</h3><p>由于插入的结点是红色的，当插入结点的黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。</p><p>处理策略：</p><ul><li>直接插入。</li></ul><h3 id="插入情景4：插入结点的父结点为红结点"><a href="#插入情景4：插入结点的父结点为红结点" class="headerlink" title="插入情景4：插入结点的父结点为红结点"></a>插入情景4：插入结点的父结点为红结点</h3><p>再次回想下红黑树的性质2：根结点是黑色。<strong>如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点</strong>。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。</p><p>情景4又分为很多子情景，下面将进入重点部分。</p><h4 id="插入情景4-1：叔叔结点存在并且为红结点"><a href="#插入情景4-1：叔叔结点存在并且为红结点" class="headerlink" title="插入情景4.1：叔叔结点存在并且为红结点"></a>插入情景4.1：叔叔结点存在并且为红结点</h4><p>从红黑树性质4可以，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。如下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E6%99%AF4.1.png"  alt="红黑树插入情景4.1"></p><p>从上图可以看到，处理的策略是：</p><ul><li>将P和S设置为黑色</li><li>将PP设置为红色</li><li>把PP设置为当前插入结点</li></ul><p>可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；但如果PP的父结点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。</p><p>试想下PP刚好为根结点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。<strong>这也是唯一一种会增加红黑树黑色结点层数的插入情景</strong>。</p><h4 id="插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点"><a href="#插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点" class="headerlink" title="插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点"></a>插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点</h4><p>叔叔结点非红即为叶子结点(Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。后续情景同样如此，不再多做说明了。</p><p>前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。</p><h5 id="插入情景4-2-1：插入结点是其父结点的左子结点"><a href="#插入情景4-2-1：插入结点是其父结点的左子结点" class="headerlink" title="插入情景4.2.1：插入结点是其父结点的左子结点"></a>插入情景4.2.1：插入结点是其父结点的左子结点</h5><p>处理策略：</p><ul><li>将P节点设置为黑色</li><li>将PP节点设置为红色</li><li>对PP节点进行右旋</li></ul><p>具体处理如下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E6%99%AF4.2.1.png"  alt="红黑树插入情景4.2.1"></p><h5 id="插入情景4-2-2：插入结点是其父结点的右子结点"><a href="#插入情景4-2-2：插入结点是其父结点的右子结点" class="headerlink" title="插入情景4.2.2：插入结点是其父结点的右子结点"></a>插入情景4.2.2：插入结点是其父结点的右子结点</h5><p>这种情景显然可以转换为情景4.2.1，如图所示，不做过多说明了。</p><p>处理策略：</p><ul><li>对P进行左旋</li><li>把P设置为插入结点，得到情景4.2.1</li><li>进行情景4.2.1的处理</li></ul><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E6%99%AF4.2.2.png"  alt="红黑树插入情景4.2.2"></p><h4 id="插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子"><a href="#插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子" class="headerlink" title="插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子"></a>插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子</h4><p>该情景对应情景4.2，只是方向反转，不做过多说明了，直接看图。</p><h5 id="插入情景4-3-1：插入结点是其父结点的右子结点"><a href="#插入情景4-3-1：插入结点是其父结点的右子结点" class="headerlink" title="插入情景4.3.1：插入结点是其父结点的右子结点"></a>插入情景4.3.1：插入结点是其父结点的右子结点</h5><p>处理策略：</p><ul><li>将P设为黑色</li><li>将PP设为红色</li><li>对PP进行左旋</li></ul><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E6%99%AF4.3.1.png"  alt="红黑树插入情景4.3.1"></p><h5 id="插入情景4-3-2：插入结点是其父结点的左子结点"><a href="#插入情景4-3-2：插入结点是其父结点的左子结点" class="headerlink" title="插入情景4.3.2：插入结点是其父结点的左子结点"></a>插入情景4.3.2：插入结点是其父结点的左子结点</h5><p>处理策略：</p><ul><li>对P进行右旋</li><li>把P设置为插入节点，得到情景4.3.1</li><li>进行4.3.1的处理</li></ul><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E6%99%AF4.3.2.png"  alt="红黑树插入情景4.3.2"></p><p>到这里红黑树插入的所有情景都分析完成了，后面分析红黑树的删除操作。</p><h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><p>相比较插入操作，删除操作更为复杂些。首先我们需要确定需要删除节点有几个儿子，如果有两个儿子节点，那么问题需要转化为删除另一个只有一个儿子的节点的问题（这里所指的儿子，为非叶子节点的儿子）。在删除带有两个非叶子儿子节点的时候，我们要么找到它左子树中的最大元素（前驱节点），要么找到右子树中的最小元素（后继节点），并把它的值转移到要删除的节点中。我们接着删除我们从中复制出来值的那个节点（前驱或者后继节点），它必定有少于两个非叶子节点的儿子。因为只复制了值，没有复制颜色，不违反任何限制，这就把问题简化为如何删除最多有一个儿子节点的问题。它不关心这个节点是最初要删除的节点还是我们从中复制出值的那个节点。</p><p>接下来我们只需要讨论删除是有一个儿子的节点（<strong>如果它两个儿子都为空，即均为叶子，我们任意将其中一个看作它的儿子</strong>）。在展开说明之前，我们先做一些假设，方便说明。这里假设最终被删除的节点为<code>X</code>（至多只有一个孩子节点），其孩子节点为<code>N</code>，<code>X</code>的兄弟节点为<code>S</code>，<code>S</code>的左节点为 S<sub>L</sub>，右节点为 S<sub>R</sub>。在这个基础上，我们就来展开红黑树删除节点的几种情况：</p><ol><li><p>X节点为红色节点，那么X的父节点和儿子节点一定是黑色的。所以我们可以简单的用它的黑色儿子节点替换它，并不会破话性质3和性质4。通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质5。如下所示：</p><p> <img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF%E4%B8%80.png"  alt="红黑树删除情景1"></p></li><li><p>X节点是黑色节点，N节点为红色节点，这种情况用它的红色儿子顶替上来的话，会破坏性质5，但是如果我们重绘它的儿子为黑色，则曾经通过它的所有路径将通过它的黑色儿子，这样可以继续保持性质5。如下图所示：</p><p> <img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF%E4%BA%8C.png"  alt="1564646164370"></p></li><li><p>X节点是黑色节点，N节点也是黑色节点，这种情况比较复杂。（这种情况下该结点的两个儿子都是叶子结点，否则若其中一个儿子是黑色非叶子结点，另一个儿子是叶子结点，那么从该结点通过非叶子结点儿子的路径上的黑色结点数最小为2，而从该结点到另一个叶子结点儿子的路径上的黑色结点数为1，违反了性质5）。我们首先把要删除的节点X替换为它的儿子N。N 沿用 X 对于长辈和晚辈的称呼，需要清楚这里实际删除的是 X 结点，并且删除之后通过 N 的路径长度减 1。这种情景下删除分为一下集中情况：</p><ol><li><p>N是新的根</p><p> 这种情况是X根节点的情况，在删除X后，N就变成了新的根了，不在需要做任何处理。</p></li><li><p>S是红色节点，其它为黑色节点。（<strong>这种情况下为什么要做处理，是因为再删除前树是一颗红黑树，但是在删除了X后，那么红黑树就遭到了破坏</strong>）。这种情况下我们是对N的父节点进行左旋操作，把红色兄弟转换成N的祖父，我们接着对调N的父亲和祖父的颜色。。完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），所以我们可以接下去按<strong>情形4</strong>、<strong>情形5</strong>或<strong>情形6</strong>来处理。如下图所示：</p><p> <img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF3.2.png"  alt="1564648858107"></p></li><li><p>N的父亲、S和S的儿子都是黑色的。在这种情形下，我们简单的重绘S为红色。结果是通过S的所有路径，它们就是以前<em>不</em>通过N的那些路径，都少了一个黑色节点。因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，<strong>通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5(P可能是一颗子树)。</strong>要修正这个问题，我们要从<strong>情形1</strong>开始，在P上做重新平衡处理。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF3.3.png"  alt="1564649405273"></p></li><li><p>N 的父节点是红色，S 和 S 孩子为黑色。这种情况比较简单，我们只需交换 P 和 S 颜色即可。这样所有通过 N 的路径上增加了一个黑色节点，所有通过 S 的节点的路径必然也通过 P 节点，由于 P 与 S 只是互换颜色，并不影响这些路径。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%95%B0%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF3.4.png"  alt="1564652315813"></p></li><li><p>S 为黑色，S 的左孩子为红色，右孩子为黑色。N 的父节点颜色可红可黑，且 N 是 P 左孩子。这种情况下对 S 进行右旋操作，并互换 S 和 S<sub>L</sub> 的颜色。此时，所有路径上的黑色数量仍然相等，N 兄弟节点的由 S 变为了 S<sub>L</sub>，而 S<sub>L</sub> 的右孩子变为红色。接下来我们到情况六继续分析。</p><p> <img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF3.5.png"  alt="1564652790772"></p></li><li><p>S是黑色，S的右儿子是红色，而N是它父亲的左儿子。在这种情形下我们在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。我们接着交换N的父亲和S的颜色，并使S的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先：要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。所以，通过N的路径都增加了一个黑色节点。</p><p> 此时，如果一个路径不通过N，则有两种可能性：</p><ul><li><p>它通过N的新兄弟。那么它以前和现在都必定通过S和N的父亲，而它们只是交换了颜色。所以路径保持了同样数目的黑色节点。</p></li><li><p>它通过N的新叔父，S的右儿子。那么它以前通过S、S的父亲和S的右儿子，但是现在只通过S，它被假定为它以前的父亲的颜色，和S的右儿子，它被从红色改变为黑色。合成效果是这个路径通过了同样数目的黑色节点。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF3.6.png"  alt="1564653320611"></p></li></ul></li></ol></li></ol><h3 id="concurrentHashMap中红黑树插入"><a href="#concurrentHashMap中红黑树插入" class="headerlink" title="concurrentHashMap中红黑树插入"></a>concurrentHashMap中红黑树插入</h3><p>前面介绍完了红黑树的插入和删除操作后，我们来看看ConcurrentHashMap中有关红黑树的操作。首先我们来看ConcurrentHashMap中<code>put</code>操作中与红黑树有关的部分，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    binCount = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果p节点不为空，则表示hash和key在此红黑树中已经存在，则使用新的value替换p节点的value</span></span><br><span class="line">        oldVal = p.val;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">            p.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分的逻辑是，如果节点<code>f</code>是<code>TreeBin</code>类型的，则调用<code>putTreeVal</code>将key和value插入到对应的位置。接下来我们看看<code>putTreeVal</code>方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//从红黑树的根节点开始查找，找到合适的插入位置</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="comment">// 如果根节点为空，则表示红黑树未创建，将k,v构建成新的TreeNode，并返回</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = root = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果P节点的hash值大于要插入的hash值,则将dir置为-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果P节点的hash值小于要插入的hash值,则将dir置为1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果P节点的key值等于要插入的key值,则返回节点p</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//这种情况是hash值一致，但是key却不相同，这就产生了hash冲突</span></span><br><span class="line">        <span class="comment">//如果 comparableClassFor方法返回不为null,则调用compareComparables方法</span></span><br><span class="line">        <span class="comment">// comparableClassFor(k)方法是返回k的类型，如果k实现了Comparable接口，则返回k对应的class,否则返回null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果已经遍历一遍红黑树还是没要找的hash和key对应相等的节点，则下次不再遍历</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//先从左边子树查找是否有相同和hash和key,如果存在则返回q节点</span></span><br><span class="line">                <span class="comment">//如果左边子树查找不到，则从右子树开始查找，查找到返回q节点</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; x, f = first;</span><br><span class="line">            <span class="comment">//构建新节点X，x.next = f,x.parent = xp</span></span><br><span class="line">            first = x = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>)</span><br><span class="line">                f.prev = x;</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//将x放到p的左子树</span></span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//将x放到p的右子树</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            <span class="keyword">if</span> (!xp.red)</span><br><span class="line">                <span class="comment">//如果xp不是红色的节点，则将x置位红色的节点</span></span><br><span class="line">                x.red = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                lockRoot();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//调整红黑树结构</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    unlockRoot();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析完上面代码，最后我们来梳理下<code>putTreeVal</code>方法的处理逻辑：</p><ol><li><p>从红黑树的根节点遍历,将根节点作为当前节点p；</p></li><li><p>如果根节点为null,则将当前传入的key和value构建为TreeNode作为新的根节点</p></li><li><p>如果根节点不为null,则比较当前节点p的hash值和传入的hash值</p><ol><li><p>如果传入的hash值小于p节点的hash值，则将dir赋值为-1</p></li><li><p>如果传入的hash值大于p节点的hash值，则将dir赋值为1</p></li><li><p>如果传入的hash值和key与p节点的hash值和key相同，则返回p节点</p></li><li><p>如果传入的hash值与p节点的hash值相等，但是key与p节点的key不相等，则表示hash冲突，此时先从根节点的左子树开始查看，如果找到节点的hash和key与传入的hash和key值相等，则返回，否则从根节点的右子树开始查找，找到则返回，如果找不到，则调用<code>tieBreakOrder</code>方法比较，<code>tieBreakOrder</code>方法的定义如下:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">         compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">             -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 从源码中，我们可以看到，最终使用的是<code>System.identityHashCode</code>方法来比价两个hash的值的大小。</p></li></ol></li><li><p>判断dir的值</p><ol><li>如果dir&lt;=0,则将当前节点p的左子节点作为新的当前节点,即p=p.left</li><li>如果dir&gt;0,则将当前节点p的右子节点作为新的当前节点,即p=p.right</li></ol></li><li><p>如果当前节p<code>不为</code>null，则重复步骤3和步骤4，否则将传入的hash、key 和value构建成新的TreeNode节点x。</p><ol><li>将根节点的前驱节点置位x,即f.prev = x;</li><li>如果dir&lt;=0,则将构建的x节点作为当前节点p的左子节点，即p.left = x;</li><li>否则，将构建的x节点作为当前节点p的右子节点，即p.right = x;</li><li>如果当前节点p不是红色，则将x节点置位红色</li><li>调整红黑树，调用<code>balanceInsertion</code>方法。</li></ol></li></ol><p>接下来，我们来分析下红黑树的重点<code>balanceInsertion</code>方法，此方法的作用就是调整红黑树使其达到自平衡。方法源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将x节点的颜色更新为红色</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="comment">//如果x.parent=null，即表示改红黑树没有任何节点，将x节点的颜色设置成黑色，并将x做为根节点。</span></span><br><span class="line">        <span class="comment">//保证了红黑树的属性一，即红黑树的根节点为黑色节点</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果x的父节点xp为黑色节点，或者x的父节点就是根节点，则不作任何处理，直接返回根节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//x父节点p为红色</span></span><br><span class="line">        <span class="comment">//------------------------</span></span><br><span class="line">        <span class="comment">//x的父节点xp是祖父节点xpp的左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="comment">//xppr为祖父节点的右子节点，且为红色，即x的叔父节点为红色</span></span><br><span class="line">            <span class="comment">//则根据红黑树的特性，我们可以推断出去祖父节点为黑色，父节点为红色，这种情景下直接交换颜色即可</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                <span class="comment">//将叔父节点转为黑色</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//将父节点转为黑色</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//将祖父节点转为红色</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//将祖父节点当做当前节点x，回溯挑战x的父节点的颜色</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果x节点的叔父节点不存在或者为黑色</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如若x为右子节点</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    <span class="comment">//先左旋</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//x为其父节点xp的左子节点</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将x的父节点xp设置成黑色</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//如果祖父节点不为null,则将祖父节点设置为红色，并且以祖父节点作为支点进行右旋</span></span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//右旋</span></span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面的情况入上面正好对应</span></span><br><span class="line">        <span class="comment">//x的父节点xp是祖父节点xpp的右子节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//x节点的叔父节点存在并且为红色,直接变换颜色即可</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果x的叔父节点不存在，或者叔父节点的颜色为黑色</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果x的父节点的左子节点</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    <span class="comment">//以父节点xp为支点，进行右旋</span></span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//以祖父节点xpp为支点进行左旋</span></span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>balanceInsertion</code>方法的逻辑在前面分析红黑树的插入的时候都有见解，如果觉得<code>balanceInsertion</code>方法看的有点晕，请结合红黑树的插入部分的分析一起看。下面我们结合实际数据再次详细的分析下<code>putTreeVal</code>方法的原理。这里我 们以{5,3,4,9,12,10,11,1}这组数据为例。</p><p>第一步：在插入节点5时，发现根节点为空，因此直接将节点5作为根节点</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal%E7%AC%AC%E4%B8%80%E6%AD%A5.png"  alt></p><p>第二步：在插入节点3时，发现节点3的hash值小于根节点的hash值，因此将节点插入到根节点的左侧，并将节点3的颜色调整为红色。其部逻辑和结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; x, f = first;</span><br><span class="line">    first = x = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line">    <span class="keyword">if</span> (f != <span class="keyword">null</span>)</span><br><span class="line">        f.prev = x;</span><br><span class="line">    <span class="comment">//dir &lt;=0,将x节点插入到其父节点的左侧，否则插入其父节点的右侧</span></span><br><span class="line">    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">        xp.left = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        xp.right = x;</span><br><span class="line">    <span class="comment">//插入的节点x的父节点的颜色为黑色，则将x节点的颜色调整为红色</span></span><br><span class="line">    <span class="keyword">if</span> (!xp.red)</span><br><span class="line">        x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        lockRoot();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            root = balanceInsertion(root, x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlockRoot();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal%E7%AC%AC%E4%BA%8C%E6%AD%A5.png"  alt></p><p>第三步：插入节点4，此时发现节点4的hash值小于根节点的hash值，但是发现根节点的左子节点3不为null,则继续比较节点4的hash值和节点3的hash值，发现节点4的hash值大于节点3的hash值，因此节点4插入到节点3的右侧。进行平衡处理时，现将插入节点4的颜色更新为红色，此时插入节点3和父节点4的颜色相同，产生冲突，想左旋然后变换父节点和祖父节点的颜色，最后右旋，源码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">    <span class="comment">//此处x = xp是非常关键的一点，将x的父节点指向x</span></span><br><span class="line">    <span class="comment">//在左旋完成后，原来x节点变成xp的父节点，x变成了了xp节点,即插入节点x转变成原来的xp节点了</span></span><br><span class="line">    root = rotateLeft(root, x = xp);</span><br><span class="line">    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">    xp.red = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">        root = rotateRight(root, xpp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![](<a href="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal" target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal</a> 第三步.png)</p><p>第四步：插入节点9，此时节点9的hash值大于根节点4的hash值，因此在和根节点4的右子节点5进行比较，发现hash值大于节点5的hash值，且节点5没有右子节点，因此将节点9放入到节点5的右子节点上。演变过程如下：</p><p>![](<a href="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal" target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal</a> 第四步.png)</p><p>第五步：插入节点12，根据上面的规则，我们知道节点12插入到节点9的右子节点上，其演变过程如下：</p><p>![](<a href="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal" target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal</a> 第五步.png)</p><p>第六步：插入节点10，根据规则，我们知道节点10会插入到节点12的左子节点处，其演变过程如下：</p><p>![](<a href="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal" target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal</a> 第六步.png)</p><p>第七步：插入节点11，其演变过程如下：</p><p>![](<a href="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal" target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal</a> 第七步.png)</p><p>第八步：插入节点1，其演变过程如下：</p><p>![](<a href="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal" target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/zhangzwd/pic-bed/raw/master/blog/putTreeVal</a> 第八步.png)</p><p>到此，ConcurrentHashMap中关于红黑树插入的操作分析完毕，并且也使用了一个示例来完整的演示了put操作，从上面的分析我们看到红黑树的put操作还是非常麻烦的，但是只要我们熟记了其插入的情景后，分析问题也会变得简单。</p><h3 id="ConcurrentHashMap中红黑树的演变"><a href="#ConcurrentHashMap中红黑树的演变" class="headerlink" title="ConcurrentHashMap中红黑树的演变"></a>ConcurrentHashMap中红黑树的演变</h3><p>ConcurrentHashMap中默认的数据结构是散列，只有当链表的长度大于阈值(默认为8)时，链表会转换为红黑树，链表演变为红黑树的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//链表长度大于阈值，则转换为红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将链表中的每个元素构建成TreeNode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果数组的长度小于红黑树要求的最新容量，则进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//链表存在，并且节点类型是Node</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        <span class="comment">//遍历每个链表中的节点，并将其构建成TreeNode</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//构建红黑树</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">    <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.first = b;</span><br><span class="line">    TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//构建红褐树的根</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            r = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//比较当前节点x的hash值</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    r = balanceInsertion(r, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.root = r;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到<code>TreeBin</code>方法的源码和<code>putTreeVal</code>方法的逻辑是一致的，上面对<code>putTreeVal</code>方法进行了分析，这里就不在赘述了。</p><h3 id="ConcurrentHashMap之红黑树的删除"><a href="#ConcurrentHashMap之红黑树的删除" class="headerlink" title="ConcurrentHashMap之红黑树的删除"></a>ConcurrentHashMap之红黑树的删除</h3><p>concurrentHashMap中红黑树的删除源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//链表节点的删除，前面已经分析了</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                V ev = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树节点的删除</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            <span class="comment">//查找到待需要删除的节点p</span></span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                <span class="comment">//如果不是替换该节点的值，则需要删除节点p</span></span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                <span class="comment">//删除节点p</span></span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除红黑树节点的具体逻辑在<code>removeTreeNode</code>方法中，该方法源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要删除的节点p</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">removeTreeNode</span><span class="params">(TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//p的后继节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; next = (TreeNode&lt;K,V&gt;)p.next;</span><br><span class="line">    <span class="comment">//p的前驱节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; pred = p.prev;  <span class="comment">// unlink traversal pointers</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r, rl;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = next;</span><br><span class="line">    <span class="keyword">if</span> (next != <span class="keyword">null</span>)</span><br><span class="line">        next.prev = pred;</span><br><span class="line">    <span class="comment">//红黑树为空</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//红黑树节点太少，返回true，将红黑树转成链表</span></span><br><span class="line">    <span class="keyword">if</span> ((r = root) == <span class="keyword">null</span> || r.right == <span class="keyword">null</span> || <span class="comment">// too small</span></span><br><span class="line">        (rl = r.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    lockRoot();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; replacement;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left;</span><br><span class="line">        TreeNode&lt;K,V&gt; pr = p.right;</span><br><span class="line">        <span class="comment">//要删除的节点p有2个子节点</span></span><br><span class="line">        <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">            <span class="comment">//找到右子树的最左子节点，即替换删除节点的节点</span></span><br><span class="line">            <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                s = sl;</span><br><span class="line">            <span class="comment">//调整删除节点和替换节点s的颜色</span></span><br><span class="line">            <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">            TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">            TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">            <span class="comment">//删除节点的右子节点下面不存在孩子节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">                p.parent = s;</span><br><span class="line">                s.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//删除节点的右子节点下面存在孩子节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                        sp.left = p;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        sp.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将替代节点的右子节点调整为删除节点的右子节点</span></span><br><span class="line">                <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                    pr.parent = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//断开删除节点p的左子树</span></span><br><span class="line">            p.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                sr.parent = p;</span><br><span class="line">            <span class="comment">//将替代接的的左子节点替换成删除节点的左子节点</span></span><br><span class="line">            <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//将删除节点的左子节点的父记得设置为替代节点</span></span><br><span class="line">                pl.parent = s;</span><br><span class="line">            <span class="comment">//将替代节点s的父节点设置为删除节点的父节点</span></span><br><span class="line">            <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                r = s;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                <span class="comment">//将删除节点父节点pp的左子节点调整为替代节点s</span></span><br><span class="line">                pp.left = s;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.right = s;</span><br><span class="line">            <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = sr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">            replacement = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = pr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">        <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">            <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                r = replacement;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = replacement;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.right = replacement;</span><br><span class="line">            p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root = (p.red) ? r : balanceDeletion(r, replacement);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == replacement) &#123;  <span class="comment">// detach pointers</span></span><br><span class="line">            TreeNode&lt;K,V&gt; pp;</span><br><span class="line">            <span class="keyword">if</span> ((pp = p.parent) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                    pp.right = <span class="keyword">null</span>;</span><br><span class="line">                p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlockRoot();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对上面源码的逻辑进行分析如下：</p><ol><li>在红黑树中查找到要删除的节点p</li><li>如果红黑树为空树或者节点的个数太少，则将红黑树转换为链表，并删除要删除的节点</li><li>如果要删除的节点存在左右连个孩子节点，则找到删除节点p右子树中的最左孩子节点s<ol><li>交换替换节点s和要删除节点p的颜色</li><li>如果待删除节点的右孩子节点pr就是替代的节点s,那么将删除节点p的父节点指向s,并将替代节点s的右孩子节点指向p</li><li>如果待删除节点p的右孩子pr节点上还有孩子节点<ol><li>如果sp节点不为空，将p的parent指向sp,并将p作为sp的左孩子或者右孩子</li><li>将pr指向s的右孩子节点，并将pr的parent指向s</li></ol></li><li>将删除节点的做孩子置位null</li><li>将删除节点p的左子节点pl指向为s的左子节点</li><li>将删除记得p的父节点pp的左自己的指向s</li></ol></li><li>如果删除节点只有一个孩子节点，则用该孩子节点替代自己</li><li>自平衡处理</li></ol><p>上面删除逻辑不是很好理解，下面我们还是用实际的实例来颜色删除的逻辑。还是以上面插入的示例为例，我们要删除节点9,此时步骤如下：</p><p>第一步：查找到要删除的节点p</p><p>![](<a href="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/remove" target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/zhangzwd/pic-bed/raw/master/blog/remove</a> 第一步.png)</p><p>第二步：删除节点p下面有2个孩子节点，找到替代节点s,  并将pr的左孩子节点设置为p, 并将s的右孩子节点设置为删除节点p的右孩子节点,其演变结果如下：</p><p>![](<a href="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/remove" target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/zhangzwd/pic-bed/raw/master/blog/remove</a> 第二步.png)</p><p>第三步：将p节点的左自己的设置为null,然后将s的左子节点设置为pl,将pp的右子节点设置为s</p><p>![](<a href="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/remove" target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/zhangzwd/pic-bed/raw/master/blog/remove</a> 第三步.png)</p><p>第四步：自平衡后将p的父节点的左子节点设置为null</p><p>![](<a href="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/remove" target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/zhangzwd/pic-bed/raw/master/blog/remove</a> 第四步.png)</p><p>到这里，我们看到删除节点p已经完成了。这里只讨论了删除的一种情况，删除还有其它的2中情况是比较简单的这里LZ就不在分析了，大家可以参照LZ的分析自己分析删除节点p只有一个孩子的情况。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> ConcurrentHashMap </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发容器之ConcurrentHashMap</title>
      <link href="/juc-concurrenthashmap/"/>
      <url>/juc-concurrenthashmap/</url>
      
        <content type="html"><![CDATA[<p>我们知道HashMap是线程不安全的，在并发情况下使用HashMap的put操作会导致死循环，因而导致CPU利用率接近100%。导致死循环的原因是HashMap在put操作时，如果put的元素个数已经达到阈值，会对数组进行扩容，把原来的元素移动到新的HashMap上去，也会对链表中的元素进行rehash。就是在复制元素的过程中，如果有并发操作，则会把HashMap的Entry链表形成环形数据结构，一旦形成环形结构，在Entry的next节点永远也不为空，因此在get操作的时候就出现了死循环的情况。既然HashMap是线程不安全的，那么HashTable呢？虽然HashTable能够在并发的情况下保证线程安全，但是在线程竞争激烈的情况下，HashTable的效率是非常低的。HashTable是通过synchronized来实现并发安全的，因此当一个线程访问HashTable的同步方法时，另一个线程将进入阻塞状态不能进行任何操作。因此引入了ConcurrentHashMap，并推荐在并发的情况下使用ConcurrentHashMap。在1.8版本以前，ConcurrentHashMap采用分段锁的概念，使锁更加细化，但是1.8已经改变了这种思路，1.8是利用CAS+Synchronized来保证并发更新的安全，当然底层采用数组+链表+红黑树的存储结构。此篇博客所有源码均来自JDK 1.8。</p><p>在开始研究ConcurrentHashMap源码之前，我们先需要了解一些重要的概念：</p><ol><li><p><strong>table:</strong>table是一个数组，默认为null,在第一次put操作时进行初始化，默认初始化的大小为16。它是用来存放Node节点的容器，扩容时的大小总是2的幂次方。</p></li><li><p><strong>nextTable:</strong>默认为null，扩容时新生成的数组，其大小为原数组的两倍。</p></li><li><p><strong>sizeCtl:</strong>默认为0，用来控制table的初始化和扩容操作。其值代表如下：</p><ul><li><strong>-1：</strong>表示table正在初始化</li><li><strong>-N：</strong>表示N-1个线程正在进行扩容操作</li><li>其余情况：<ul><li>如果table未初始化，表示table需要初始化的大小。</li><li>如果table初始化完成，表示table的容量，默认是table大小的0.75倍。居然用这个公式算0.75（n - (n &gt;&gt;&gt; 2)）。</li></ul></li></ul></li><li><p><strong>Node：</strong>key-value键值对。所有插入ConCurrentHashMap的中数据都将会包装在Node中。其中value和next都用volatile修饰，保证并发的可见性。其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> &lt; <span class="title">K</span>, <span class="title">V</span> &gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span> &lt; <span class="title">K</span>, <span class="title">V</span> &gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node &lt; K, V &gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node &lt; K, V &gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 省略部分代码...</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ForwardingNode：</strong>一个特殊的Node节点，hash值为-1，其中存储nextTable的引用。只有当table发送扩容时ForwardingNode才会发生作用。其源码定义如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span> &lt; <span class="title">K</span>, <span class="title">V</span> &gt; <span class="keyword">extends</span> <span class="title">Node</span> &lt; <span class="title">K</span>, <span class="title">V</span> &gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node &lt; K,V &gt; [] nextTable;</span><br><span class="line">    ForwardingNode(Node &lt; K, V &gt; [] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 省略部分代码...</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>TreeNode：</strong>TreeBins中使用的节点。它自身继承了Node。其部分代码如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent; </span><br><span class="line">    TreeNode&lt;K,V&gt; left;  </span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev; </span><br><span class="line">    <span class="keyword">boolean</span> red;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建节点</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,  TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 省略部分代码...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>TreeBin：</strong>该类并不负责key-value的键值对包装，它用于在链表转换为红黑树时包装TreeNode节点，也就是说ConcurrentHashMap红黑树存放是TreeBin，不是TreeNode。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="comment">// values for lockState</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line"></span><br><span class="line">    TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">        <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.first = b;</span><br><span class="line">        TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">            next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">            x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                x.parent = <span class="keyword">null</span>;</span><br><span class="line">                x.red = <span class="keyword">false</span>;</span><br><span class="line">                r = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                K k = x.key;</span><br><span class="line">                <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                    <span class="keyword">int</span> dir, ph;</span><br><span class="line">                    K pk = p.key;</span><br><span class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        dir = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                        dir = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                              (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                             (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                        dir = tieBreakOrder(k, pk);</span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        x.parent = xp;</span><br><span class="line">                        <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                            xp.left = x;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            xp.right = x;</span><br><span class="line">                        r = balanceInsertion(r, x);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = r;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 省略部分代码...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在了解了这些重要的概念后，我们先来看看ConcurrentHashMap的数据结构，然后再来分析ConcurrentHashMap的初始化。ConcurrentHashMap的数据结构的数据结构如下图所示</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/ConcurrentHashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg"  alt="ConcurrentHashMap的数据结构"></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>ConcurrentHashMap源码提供给了一系列的构造函数来初始化ConcurrentHashMap。在看构造函数之前，我们先看看构造函数中的一些常量，以增加对构造函数的理解。</p><h4 id="构造函数中的常量"><a href="#构造函数中的常量" class="headerlink" title="构造函数中的常量"></a>构造函数中的常量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大可能的表容量，大小为2^30 = 1073741824</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认的初始表容量。 必须是2的幂（即，至少1）并且最多为MAXIMUM_CAPACITY（2^30）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><h4 id="构造函数系列"><a href="#构造函数系列" class="headerlink" title="构造函数系列"></a>构造函数系列</h4><p>构造函数源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认初始化表大小（默认值为16）来初始化一个ConcurrentHashMap对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过指定容量大小来初始化一个ConcurrentHashMap对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始容量必须大于0,如果传入的值小于0，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">        MAXIMUM_CAPACITY : </span><br><span class="line">        tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过一个给定的map集合来创建一个ConcurrentHashMap对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map &lt; ? extends K, ? extends V &gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过一个指定的容量大小和负载因子来初始化一个ConcurrentHashMap对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过一个指定的容量大小、负载因子和并发更新的线程数量来初始化一个ConcurrentHashMap对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0</span> f) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel) <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel; <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>) initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>) MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>) size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tableSizeFor方法的作用是找到大于等于给定容量的最小2的次幂值 ,其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将c-1,赋值给n</span></span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//n向右无符号移动1位后与原来的n进行位或运算</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//n向右无符号移动2位后与原来的n进行位或运算</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//n向右无符号移动4位后与原来的n进行位或运算</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//n向右无符号移动8位后与原来的n进行位或运算</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//n向右无符号移动16位后与原来的n进行位或运算</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一句n=c-1的作用是，当c正好是2的幂的时候，经过后面的运算后，得到的还是原来的值。这里我们举例说明下，如果此时c的值为8，对应的二进制数为00000000 00000000 00000000 00001000,运行第一句后，得到的n的值为00000000 00000000 00000000 00000111（即8-1=7），n向右无符号移动一位后得到的值为00000000 00000000 00000000 00000011（即3），7与3进行位或运算，等到‭00000000 00000000 00000000 00000111‬（即7）,后面所有位移后再进行位或运算得到的值依然是7，最后执行return语句，返回的值就是8了，与原来输入的值一样。</p><p>从上面构造函数中我们发现，ConcurrentHashMap在执行构造函数后，只是对容量大小做了初始化，并不会直接初始化table，而是延缓到第一次put操作。</p><h3 id="table初始化：initTable"><a href="#table初始化：initTable" class="headerlink" title="table初始化：initTable()"></a>table初始化：initTable()</h3><p>前面已经提到过，table初始化操作会延缓到第一次put行为。但是put是可以并发执行的，Doug Lea是如何实现table只初始化一次的？让我们来看看源码的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//sizeCtl &lt; 0 表示有其他线程在初始化，该线程必须挂起</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// 如果该线程获取了初始化的权利，则用CAS将sizeCtl设置为-1，表示本线程正在初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果传入了初始化容量，则使用对初始化容量计算后的数据（这个数据必定是2的幂），否则使用默认容器大小16.</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">//构建Node类型的数组</span></span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//设置下次扩容的大小 n - (n &gt;&gt;&gt; 2) ==  0.75*n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码我们可以看到<code>initTable()</code>方法的关键就在于sizeCtl这个变量。sizeCtl默认值为0，如果ConcurrentHashMap在实例化时有参数传入，则sizeCtl会是一个2的幂次方的值。如果sizeCtl &lt; 0，则表示有其它线程正在初始化，必须暂停当前线程。如果当前线程获取了初始化table的权限，则使用CAS将sizeCtl的值设置为-1，防止其它线程进行初始化。初始化完成后，将sizeCtl的值设置为0.75*n，表示下次扩容的阈值。</p><h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><p>当我们在构造了ConcurrentHashMap对象后，就会向ConcurrentHashMap对象中添加键值对。put操作采用CAS+synchronized实现并发插入或更新操作，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// put和putIfAbsent的实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key 和 value 都不允许为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//对key的hashCode进行hash计算</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node &lt; K, V &gt; [] tab = table;;) &#123;</span><br><span class="line">        Node &lt; K, V &gt; f;</span><br><span class="line">        <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果table为空，则对table进行初始化操作</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//如果table中的i位置没有节点，则直接插入数据,无需加锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,<span class="keyword">new</span> Node &lt; K, V &gt; (hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        <span class="comment">// 节点的hash的值为-1，表示当前节点为ForwardingNode类型。</span></span><br><span class="line">        <span class="comment">// 即表示有线程正在进行扩容操作，则先帮助扩容    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//帮助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">//对该节点进行加锁处理（hash值相同的链表的头节点），对性能有点影响</span></span><br><span class="line">            <span class="keyword">synchronized</span>(f) &#123;</span><br><span class="line">                <span class="comment">//如果table中i位置的节点仍然是f,则进入</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//fh &gt;=0 表示为链表，将节点插入到链表的尾部</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//从头向尾遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node &lt; K, V &gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//如果hash和key与e节点的hash和key相等，则替换到e节点的value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;((ek = e.key) == key ||</span><br><span class="line">                                                  (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//e节点原来的值</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">//如果不是putIfAbsent形式,则替换掉原来的值</span></span><br><span class="line">                                <span class="comment">// putIfAbsent形式则当key存在返回false,否则插入并返回true</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node &lt; K, V &gt; pred = e;</span><br><span class="line">                            <span class="comment">//将节点插入到链表尾部</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node &lt; K, V &gt; (hash, key,value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="comment">//树节点，按照树的插入操作进行插入    </span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node &lt; K, V &gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin &lt; K, V &gt; ) f).putTreeVal(hash, key,value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果链表长度已经达到临界值8 就需要把链表转换为树结构</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//size++</span></span><br><span class="line">    addCount(<span class="number">1</span> L, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面put操作的源码，我 么来整理下put操作的流程：</p><ul><li><p>首先判断key和value的值，保证key和value都不为null;</p></li><li><p>计算key的hash值，方法如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过key确定槽的位置时，如果我们直接使用key.hashCode() &amp;（表长度-1）那么我们实际上只使用了key.hashCode()的低若干位信息，高位不起作用。所以为了key更加的分散，减少冲突，在实际定位槽的位置时，我们会将key.hashCode()再进行spread一下，充分使用key.hashCode()的高16位信息。而spread后的哈希值会存储在结点的hash属性中，便于下一次直接使用。</p></li><li><p>死循环的方式处理节点的插入：</p><ul><li>判断table是否为空，如果为null,则进行初始化的操作，其初始化方法为<code>initTable()</code>；</li><li>根据hash值来确定当前key-value需要插入的位置i,如果i处没有节点，则直接插入到i的位置。这个过程不需要加锁操作。</li><li>如果i处存在节点，并且节点的hash值为-1即（(fh = f.hash) == MOVED）表示当前节点f是ForwardingNode类型的节点。即表示有线程正在进行扩容操作，则先帮助线程做扩容的操作。</li><li>如果f.hash &gt;= 0 表示是链表结构，则遍历链表，如果链表上存在当前key的节点则替换value，否则插入到链表尾部。如果f是TreeBin类型节点，则按照红黑树的方法更新或者增加节点。</li><li>如果链表长度超过TREEIFY_THRESHOLD(默认是8)，则将链表转成红黑树。</li></ul></li><li><p>调用addCount方法，ConcurrentHashMap的size + 1</p></li></ul><p>这里put操作完成</p><h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><p>ConcurrentHashMap的get方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 搜索到的节点key与传入的key相同且不为null,直接返回这个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头节点的 hash 值小于 0，说明正在扩容或者该节点是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//链表遍历</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get操作的整个逻辑非常清楚：</p><ul><li>计算hash值</li><li>判断table是否为空，如果为空，直接返回null</li><li>根据hash值获取table中的Node节点（tabAt(tab, (n – 1) &amp; h)），然后根据链表或者树形方式找到相对应的节点，返回其value值。</li></ul><h3 id="删除操作：remove"><a href="#删除操作：remove" class="headerlink" title="删除操作：remove"></a>删除操作：remove</h3><p>ConcurrentHashMap的remove方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果table为初始化或者通过hash值计算出来的table中i的位置的元素为null,则直接跳出循环返回null</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//如果f节点的hash值为-1，表示有其它线程正在进行扩容，先帮助完成扩容，然后再继续执行for循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//加锁操作，防止其它线程对此桶同时进行put,remove,transfer操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//头节点发生改变，就说明当前链表（或红黑树）的头节点已不是f了</span></span><br><span class="line">                <span class="comment">//可能被前面的线程remove掉了或者迁移到新表上了</span></span><br><span class="line">                <span class="comment">//如果被remove掉了，需要重新对链表新的头节点加锁</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//fh&gt;0,表示该通后面是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//从前往后遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//找到hash和key对应相等的节点</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || </span><br><span class="line">                                                   (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                V ev = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">//将该节点的前驱节点的next直接赋值为该节点的next节点</span></span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">//如果删除的节点就是链表的头结点，则将链表的下一个节点放置到table的i位置</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="comment">//没找到要删除的key,跳出循环直接返回null</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//树结构，删除</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//元素减一</span></span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove操作的逻辑与get操作的逻辑基本相似：</p><ul><li>计算hash值。</li><li>判断table是否为空，为空则直接返回null。</li><li>根据hash值获取table中的Node节点（tabAt(tab, (n – 1) &amp; h)），然后根据链表或者树形方式找到相对应的节点，并将其删除。</li><li>元素个数减一(调用addCount(-1,-1))</li></ul><h3 id="更新元素个数操作：addCount"><a href="#更新元素个数操作：addCount" class="headerlink" title="更新元素个数操作：addCount"></a>更新元素个数操作：addCount</h3><p>分析完上面put、get和remove方法后，我们看在在put和remove方法里面都调用了addCount方法，该方法的作用是更新ConcurrentHashMap中元素的个数，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x) 每次进来都更新baseCount</span></span><br><span class="line">    <span class="comment">//当put时baseCount+1,当remove时,baseCount-1</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果计数盒子不是空 或者 修改 baseCount 失败,则进入执行该if语句</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">//多线程CAS发生失败的时候执行</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 如果map.size() 大于 sizeCtl（达到扩容阈值需要扩容） 且</span></span><br><span class="line">        <span class="comment">// table 不是空；且 table 的长度小于 1 &lt;&lt; 30。（可以扩容）</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 根据 length 得到一个标识</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// 如果正在扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果 sc 的低 16 位不等于 标识符（校验异常 sizeCtl 变化了）</span></span><br><span class="line">   <span class="comment">// 这里 sc == rs + 1 ||  sc == rs + MAX_RESIZERS 这2个条件永远不能为true，因为sc此时是一个负数，但是rs是一个整数。这里可能是作者的一个BUG.</span></span><br><span class="line">                <span class="comment">// 如果 nextTable == null（结束扩容了）</span></span><br><span class="line">                <span class="comment">// 如果 transferIndex &lt;= 0 (已经有足够的线程来完成迁移工作，后面迁移会看到)</span></span><br><span class="line">                <span class="comment">// 结束循环 </span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果sc&gt;0,表示没有线程正在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2.</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 更新 sizeCtl 为负数后，开始扩容。这里这会有一个线程执行transfer(tab, null)方法，其余的线程会执行transfer(tab, nt)方法</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码我 们可以看出，每次操作addCount操作都会对baseCount加1(put操作)或者减1(remove操作)，如果并发较大，则<code>U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)</code>会执行失败。那么为了提高高并发的时候baseCount可见性失败的问题，又避免一直重试，这样性能会有很大的影响，那么在jdk8的时候是有引入一个类Striped64，其中LongAdder和DoubleAdder就是对这个类的实现。这两个方法都是为解决高并发场景而生的，是AtomicLong的加强版，AtomicLong在高并发场景性能会比LongAdder差。但是LongAdder的空间复杂度会高点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See LongAdder version for explanation</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//如果当前线程的probe值为0，则初始化probe的值</span></span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//如果counterCells不为null且存在有效数据</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="comment">//如果当前没有CounterCell就创建一个</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></span><br><span class="line">                    <span class="comment">//将cellsBusy的值置为1，加锁</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;  (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">//释放cellsBusy锁，让其他线程可以进来</span></span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//wasUncontended为false说明已经发生了竞争，重置为true重新执行上面代码</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">//对cell的value值进行累计x（1）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="comment">//表明as已经过时，说明cells已经初始化完成，看下面，重置collide为false表明已经存在竞争</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化counterCells</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                    <span class="comment">//这里长度是2的原因是其长度一定是2的幂次</span></span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果上面都不满足，则直接将x累加到baseCount上</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>fullAddCount</code>方法看着比较复杂，我们来梳理下其逻辑：</p><ul><li><p>如果该线程还没获取过随机数，则初始化<code>ThreadLocalRandom</code>然后获取一个随机数h;</p></li><li><p>开始死循环</p><ul><li><p>如果counterCells不为null，且其长度不为0，则分为如下几种情况：</p><ul><li><p>如果通过h获取的下标j(j=((n - 1) &amp; h),其中n为counterCells长度)对应的元素为空null:</p><ul><li>如果cellsBusy == 0表示未加锁，new一个CounterCell并将其放入到j的位置，并跳出循环</li><li>如果cellsBusy !=0,表示有锁，将collide置位false,表示有有竞争。然后继续循环</li></ul></li><li><p>如果wasUncontended为false,则表示发生了竞争，将wasUncontended设置为true后继续执行</p></li><li><p>使用CAS更新CELLVALUE的值+x,如果成功，则跳出循环，失败则继续循环</p></li><li><p>如果counterCells != as || n &gt;= NCPU，表示发生了竞争，将collide设置为false,继续循环</p></li><li><p>如果 cellsBusy == 0 且加cellsBusy锁成功，则将counterCells扩容，其大小为原来的额2倍，并跳出循环</p></li><li><p>重新生成随机数h</p></li></ul></li><li><p>如果counterCells==null,且CAS成功，则初始化counterCells，默认大小为2，这设置2的原因是counterCells的长度一定要是2的幂次</p></li><li><p>如果上面都失败了，则尝试CAS更新baseCount的值,失败继续循环</p></li></ul></li></ul><p>这里看了<code>addCount</code>和<code>fullAddCount</code>方法后，我们可以预测下ConcurrentHashMap中size方法返回的值应该是baseCount的值加上所有counterCells中CounterCell元素的value的值。我们来看看<code>size</code>方法是否和我们预测的一致,size方法源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> : (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">    sum += a.value;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里和我们预测的想法是一致的。在分析了ConcurrentHashMap的常用方法后，我们在来看看其中的一个非常关键的操作，那就是扩容。</p><h3 id="扩容操作：transfer"><a href="#扩容操作：transfer" class="headerlink" title="扩容操作：transfer"></a>扩容操作：transfer</h3><p>扩容是ConcurrentHashMap中一个非常关键的部分，在上面我们分析<code>addCount</code>的源码时已经有过接触，首先我们还是先看看扩容方法的源码定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)/NCPU，最小值是 16</span></span><br><span class="line">    <span class="comment">// stride 可以理解为 步长，有 n 个位置是需要进行迁移的，</span></span><br><span class="line">    <span class="comment">// 将这 n 个任务分为多个任务组，每个任务组有 stride 个任务</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">// 如果 nextTab 为 null，先进行初始化，初始化的大小为原来长度的2倍</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//transferIndex 指向原来tab最后一个桶，方便从后向前遍历 </span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">// 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED,MOVED的值为-1</span></span><br><span class="line">    <span class="comment">// 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span></span><br><span class="line">    <span class="comment">// 它其实相当于是一个标识</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">//i是位置下标，bound是每个线程处理桶的边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 将 transferIndex 值赋给 nextIndex</span></span><br><span class="line">            <span class="comment">// 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//分配线程的处理边界</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// nextBound 是这次迁移任务的边界，是从后往前</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i&lt;0说明已经遍历完旧的数组tab；i&gt;=n什么时候有可能呢？在下面看到i=n,所以目前i最大应该是n吧。</span></span><br><span class="line">        <span class="comment">//i+n&gt;=nextn,nextn=nextTab.length，所以如果满足i+n&gt;=nextn说明已经扩容完成</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">//扩容完成后，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 第一个扩容的线程，执行transfer方法之前，会设置 sizeCtl = (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line"><span class="comment">                 后续帮其扩容的线程，执行transfer方法之前，会设置 sizeCtl = sizeCtl+1</span></span><br><span class="line"><span class="comment">                 每一个退出transfer的方法的线程，即该线程已经完了自己的扩容工作，退出之前，会设置 sizeCtl = sizeCtl-1</span></span><br><span class="line"><span class="comment">                 那么最后一个线程退出时：</span></span><br><span class="line"><span class="comment">                 必然有sc == (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，即 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//不相等，说明不到最后一个线程，直接退出transfer方法</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果tab的i位置没有节点，则将此处的的节点设置成一个ForwardingNode节点，仅仅起到站位的左右</span></span><br><span class="line">        <span class="comment">//这样做的目的是当其他线程在put操作的时候，正好要放置节点的位置就是当前位置时，需要告诉线程正在进行扩容操作，需要先帮助扩容才能正常添加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//CAS设置成功，则继续去做该线程其它位置设定的扩容操作</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">// 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="comment">//开始迁移</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">//迁移链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//将链表拆分为2个链表，分别为ln和hn</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//将ln链表放到新table的i位置</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//将hn链表放置到新table的i+n的位置</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//将原table的i位置标记为ForwardingNode节点</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//继续迁移上一个位置的节点</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树迁移，后面再讲</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，迁移中关于链表的部分已经个介绍完成了，下面我们先来整体总结下迁移的逻辑：</p><ul><li>首先在<code>put</code>方法调用<code>addCount</code>方法后，如果需要扩容，则第一个线程会执行<code>transfer(tab, null)</code>，并且将sizeCtl的值设置为rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2。</li><li>如果有线程并发put操作，如果需要put的元素在table位置的i上存在节点，且节点的hash值为-1，则帮助扩容，则是线程需要执行<code>transfer(tab, nextTab)</code>，并将sizeCtl的值设置为U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)，否则直接put操作，则进行帮助扩容。</li><li>先计算每个线程处理的步长，多核模式下为 (n&gt;&gt;&gt;3)/NCPU，单核模式下为n,但是其最小值是 16。</li><li>如果是第一个线程执行扩容，则需要创建nextTable，并且其长度为原来table的2倍。</li><li>分配每个线程执行迁移的区间。</li><li>如果table数组上i位置没有元素，则将i位置设置为ForwardingNode类型的节点，占据位置。然后再开启迁移（i-1）的位置。</li><li>如果table数组上i位置存在元素，并且其节点类型为ForwardingNode，则迁移(i-1)的位置。</li><li>开始迁移i位置的数据：<ul><li>如果i位置上的节点是链表类型，将链表拆分了2个链表，(node.hash &amp; n) == 0 组成的链表放置在新table（后面就用nextTable代替）的i的位置，(node.hash &amp; n) != 0 组成的链表放置在nextTable的（i+n)的位置上。</li><li>如果i位置上的节点是红黑树类型，其迁移操作下一节在讨论。</li></ul></li><li>迁移完成后，执行U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)，表示有一个线程完成了迁移，如果不是最后一个线程，则直接返回。最后一个线程在执行上面代码后，还要在检查一遍才能退出。</li></ul><p>到这里我们分析了ConcurrentHashMap的一些常用方法，其中关于红黑树的部分还未涉及，下一篇将分析ConcurrentHashMap中有关于红黑树的有关部分。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发工具之Exchanger源码解析</title>
      <link href="/juc-exchanger/"/>
      <url>/juc-exchanger/</url>
      
        <content type="html"><![CDATA[<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>Exchanger(交换者)是用于线程协作的工具类。Exchanger用于进行两个线程之间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange()方法交换数据，当一个线程先执行exchange()方法后，它会一直等待第二个线程也执行exchange()方法，当这两个线程到达同步点时，这两个线程就可以交换数据了。</p><p>Exchanger的算法核心是通过一个可以交换数据的slot和一个可以带有数据item的参与者，在源码中的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (slot is empty) &#123; <span class="comment">// offer</span></span><br><span class="line">        <span class="comment">// slot为空时，将item 设置到Node 中        </span></span><br><span class="line">        place item in a Node;</span><br><span class="line">        <span class="keyword">if</span> (can CAS slot from empty to node) &#123;</span><br><span class="line">            <span class="comment">// 当将node通过CAS交换到slot中时，挂起线程等待被唤醒</span></span><br><span class="line">            wait <span class="keyword">for</span> release;</span><br><span class="line">            <span class="comment">// 被唤醒后返回node中匹配到的item</span></span><br><span class="line">            <span class="keyword">return</span> matching item in node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (can CAS slot from node to empty) &#123; <span class="comment">// release</span></span><br><span class="line">         <span class="comment">// 将slot设置为空</span></span><br><span class="line">        <span class="comment">// 获取node中的item，将需要交换的数据设置到匹配的item</span></span><br><span class="line">        get the item in node;</span><br><span class="line">        set matching item in node;</span><br><span class="line">        <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">        release waiting thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else retry on CAS failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如有2条线程A和B，A线程交换数据时，发现slot为空，则将需要交换的数据放在slot中等待其它线程进来交换数据，等线程B进来，读取A设置的数据，然后设置线程B需要交换的数据，然后唤醒A线程，原理就是这么简单。但是当多个线程之间进行交换数据时就会出现问题，所以Exchanger加入了slot数组。</p><p>Exchanger中定义了几个重要的成员变量,它们分别是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Participant participant;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node[] arena;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node slot;</span><br></pre></td></tr></table></figure><p>participant的作用是为每个线程保留唯一的一个Node节点。slot为单个槽，arena为数组槽。他们都是Node类型。这里arena存在的意义是当有多个参与者使用同一个交换场所时，会存在严重伸缩性问题。既然单个交换场所存在问题，那么我们就安排多个，也就是数组arena。通过数组arena来安排不同的线程使用不同的slot来降低竞争问题，并且可以保证最终一定会成对交换数据。但是Exchanger不是一来就会生成arena数组来降低竞争，只有当产生竞争时才会生成arena数组。那么怎么将Node与当前线程绑定呢？这里就要用到Participant ，Participant 的作用就是为每个线程保留唯一的一个Node节点，它继承ThreadLocal，同时在Node节点中还记录了其在arena中的下标index的值。</p><p>Node的数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     <span class="comment">// arena的下标，多个槽位的时候利用</span></span><br><span class="line">    <span class="keyword">int</span> index; </span><br><span class="line">    <span class="comment">// 上一次记录的Exchanger.bound</span></span><br><span class="line">    <span class="keyword">int</span> bound; </span><br><span class="line">    <span class="comment">// 在当前bound下CAS失败的次数；</span></span><br><span class="line">    <span class="keyword">int</span> collides;</span><br><span class="line">    <span class="comment">// 用于自旋；</span></span><br><span class="line">    <span class="keyword">int</span> hash; </span><br><span class="line">    <span class="comment">// 这个线程的当前项，也就是需要交换的数据；</span></span><br><span class="line">    Object item; </span><br><span class="line">    <span class="comment">//做releasing操作的线程传递的项；</span></span><br><span class="line">    <span class="keyword">volatile</span> Object match; </span><br><span class="line">    <span class="comment">//挂起时设置线程值，其他情况下为null；</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exchanger的核心方法为<code>exchange(V x)</code>，下面我们就来分析下<code>exchange(V x)</code>方法。</p><h3 id="exchange-V-x-方法"><a href="#exchange-V-x-方法" class="headerlink" title="exchange(V x)方法"></a>exchange(V x)方法</h3><p><strong>exchange(V x)</strong>：等待另一个线程到达此交换点（除非当前线程被中断），然后将给定的对象传送给该线程，并接收该线程的对象。方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="comment">// 当参数为null时需要将item设置为空</span></span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x; <span class="comment">// translate null args</span></span><br><span class="line">    <span class="comment">// 注意到这里的这个表达式是整个方法的核心</span></span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> ||</span><br><span class="line">            (v = slotExchange(item, <span class="keyword">false</span>, <span class="number">0</span> L)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        ((Thread.interrupted() || <span class="comment">// disambiguates null return</span></span><br><span class="line">            (v = arenaExchange(item, <span class="keyword">false</span>, <span class="number">0</span> L)) == <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V) v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细分析上述方法中的if语句，可以得知：</p><ul><li>只有当arena 为空时，才执行slotExchange(item, false, 0 L)方法。</li><li>当arena不为空时，或者(arena为null且slotExchange方法返回null)时，此时线程未中断，才会执行arenaExchange方法;</li><li>线程中断时，就直接抛出线程中断异常。</li></ul><p>下面我们再看看slotExchange方法，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">slotExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程node对象</span></span><br><span class="line">    Node p = participant.get();</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 如果线程被中断，就直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (t.isInterrupted()) <span class="comment">// preserve interrupt status so caller can recheck</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node q;;) &#123;</span><br><span class="line">        <span class="comment">// 将slot值赋给q</span></span><br><span class="line">        <span class="keyword">if</span> ((q = slot) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// slot 不为null，即表示已有线程已经把需要交换的数据设置在slot中了</span></span><br><span class="line"><span class="comment">// 通过CAS将slot设置成null</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// CAS操作成功后，将slot中的item赋值给对象v，以便返回。</span></span><br><span class="line">                <span class="comment">// 这里也是就读取之前线程要交换的数据</span></span><br><span class="line">                Object v = q.item;</span><br><span class="line">                <span class="comment">// 将当前线程需要交给的数据设置在q中的match</span></span><br><span class="line">                q.match = item;</span><br><span class="line">                 <span class="comment">// 获取被挂起的线程</span></span><br><span class="line">                Thread w = q.parked;</span><br><span class="line">                <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 如果线程不为null，唤醒它</span></span><br><span class="line">                    U.unpark(w);</span><br><span class="line">                <span class="comment">// 返回其他线程给的V</span></span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// create arena on contention, but continue until slot null</span></span><br><span class="line">            <span class="comment">// CAS 操作失败，表示有其它线程竞争，在此线程之前将数据已取走</span></span><br><span class="line">            <span class="comment">// NCPU:CPU的核数</span></span><br><span class="line">            <span class="comment">// bound == 0 表示arena数组未初始化过，CAS操作bound将其增加SEQ</span></span><br><span class="line">            <span class="keyword">if</span> (NCPU &gt; <span class="number">1</span> &amp;&amp; bound == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, <span class="number">0</span>, SEQ))</span><br><span class="line">                <span class="comment">// 初始化arena数组</span></span><br><span class="line">                arena = <span class="keyword">new</span> Node[(FULL + <span class="number">2</span>) &lt;&lt; ASHIFT];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面分析过，只有当arena不为空才会执行slotExchange方法</span></span><br><span class="line"><span class="comment">// 所以表示刚好已有其它线程加入进来将arena初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arena != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 这里就需要去执行arenaExchange</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// caller must reroute to arenaExchange</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里表示当前线程是以第一个线程进来交换数据</span></span><br><span class="line">            <span class="comment">// 或者表示之前的数据交换已进行完毕，这里可以看作是第一个线程</span></span><br><span class="line">            <span class="comment">// 将需要交换的数据先存放在当前线程变量p中</span></span><br><span class="line">            p.item = item;</span><br><span class="line">            <span class="comment">// 将需要交换的数据通过CAS设置到交换区slot</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, <span class="keyword">null</span>, p))</span><br><span class="line">                <span class="comment">// 交换成功后跳出自旋</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// CAS操作失败，表示有其它线程刚好先于当前线程将数据设置到交换区slot</span></span><br><span class="line">            <span class="comment">// 将当前线程变量中的item设置为null，然后自旋获取其它线程存放在交换区slot的数据</span></span><br><span class="line">            p.item = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// await release</span></span><br><span class="line">    <span class="comment">// 执行到这里表示当前线程已将需要的交换的数据放置于交换区slot中了，</span></span><br><span class="line">    <span class="comment">// 等待其它线程交换数据然后唤醒当前线程</span></span><br><span class="line">    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">    <span class="keyword">long</span> end = timed ? System.nanoTime() + ns : <span class="number">0</span> L;</span><br><span class="line">    <span class="comment">// 自旋次数</span></span><br><span class="line">    <span class="keyword">int</span> spins = (NCPU &gt; <span class="number">1</span>) ? SPINS : <span class="number">1</span>;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="comment">// 自旋等待直到p.match不为null，也就是说等待其它线程将需要交换的数据放置于交换区slot</span></span><br><span class="line">    <span class="keyword">while</span> ((v = p.match) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 下面的逻辑主要是自旋等待，直到spins递减到0为止</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            h ^= h &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            h ^= h &gt;&gt;&gt; <span class="number">3</span>;</span><br><span class="line">            h ^= h &lt;&lt; <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="number">0</span>)</span><br><span class="line">                h = SPINS | (<span class="keyword">int</span>) t.getId();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp; (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                Thread.yield();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slot != p)</span><br><span class="line">            spins = SPINS;</span><br><span class="line">        <span class="comment">// 此处表示未设置超时或者时间未超时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; arena == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (!timed || (ns = end - System.nanoTime()) &gt; <span class="number">0</span> L)) &#123;</span><br><span class="line">            <span class="comment">// 设置线程t被当前对象阻塞</span></span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 给p挂机线程的值赋值</span></span><br><span class="line">            p.parked = t;</span><br><span class="line">            <span class="keyword">if</span> (slot == p)</span><br><span class="line">                <span class="comment">// 如果slot还没有被置为null，也就表示暂未有线程过来交换数据，需要将当前线程挂起</span></span><br><span class="line">                U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">            <span class="comment">// 线程被唤醒，将被挂起的线程设置为null</span></span><br><span class="line">            p.parked = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 设置线程t未被任何对象阻塞</span></span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 不是以上条件时（可能是arena已不为null或者超时）    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">             <span class="comment">// arena不为null则v为null,其它为超时则v为超市对象TIMED_OUT，并且跳出循环</span></span><br><span class="line">            v = timed &amp;&amp; ns &lt;= <span class="number">0</span> L &amp;&amp; !t.isInterrupted() ? TIMED_OUT : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取走match值，并将p中的match置为null</span></span><br><span class="line">    U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 设置item为null</span></span><br><span class="line">    p.item = <span class="keyword">null</span>;</span><br><span class="line">    p.hash = h;</span><br><span class="line">    <span class="comment">// 返回交换值</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看arenaExchange方法，此方法被执行时表示多个线程进入交换区交换数据，arena数组已被初始化，此方法中的一些处理方式和slotExchange比较类似，它是通过遍历arena数组找到需要交换的数据。arenaExchange方法源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timed 为true表示设置了超时时间，ns为&gt;0的值，反之没有设置超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">arenaExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">    Node[] a = arena;</span><br><span class="line">    <span class="comment">// 获取当前线程中的存放的node</span></span><br><span class="line">    Node p = participant.get();</span><br><span class="line">    <span class="comment">//index初始值0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.index;;) &#123; <span class="comment">// access slot at i</span></span><br><span class="line">        <span class="comment">// 遍历，如果在数组中找到数据则直接交换并唤醒线程，如未找到则将需要交换给其它线程的数据放置于数组中</span></span><br><span class="line">        <span class="keyword">int</span> b, m, c;</span><br><span class="line">        <span class="keyword">long</span> j; <span class="comment">// j is raw array offset</span></span><br><span class="line">        <span class="comment">// 其实这里就是向右遍历数组，只是用到了元素在内存偏移的偏移量</span></span><br><span class="line">        <span class="comment">// q实际为arena数组偏移(i + 1) *  128个地址位上的node</span></span><br><span class="line">        Node q = (Node) U.getObjectVolatile(a, j = (i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">        <span class="comment">// 如果q不为null，并且CAS操作成功，将下标j的元素置为null</span></span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; U.compareAndSwapObject(a, j, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 表示当前线程已发现有交换的数据，然后获取数据，唤醒等待的线程</span></span><br><span class="line">            Object v = q.item; <span class="comment">// release</span></span><br><span class="line">            q.match = item;</span><br><span class="line">            Thread w = q.parked;</span><br><span class="line">            <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                U.unpark(w);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        <span class="comment">// q 为null 并且 i 未超过数组边界    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= (m = (b = bound) &amp; MMASK) &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 将需要给其它线程的item赋予给p中的item</span></span><br><span class="line">            p.item = item; <span class="comment">// offer</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(a, j, <span class="keyword">null</span>, p)) &#123;</span><br><span class="line">                <span class="comment">// 交换成功</span></span><br><span class="line">                <span class="keyword">long</span> end = (timed &amp;&amp; m == <span class="number">0</span>) ? System.nanoTime() + ns : <span class="number">0</span> L;</span><br><span class="line">                Thread t = Thread.currentThread(); <span class="comment">// wait</span></span><br><span class="line">                <span class="comment">// 自旋直到有其它线程进入，遍历到该元素并与其交换，同时当前线程被唤醒</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> h = p.hash, spins = SPINS;;) &#123;</span><br><span class="line">                    Object v = p.match;</span><br><span class="line">                    <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 其它线程设置的需要交换的数据match不为null</span></span><br><span class="line">                        <span class="comment">// 将match设置null,item设置为null</span></span><br><span class="line">                        U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">                        p.item = <span class="keyword">null</span>; <span class="comment">// clear for next use</span></span><br><span class="line">                        p.hash = h;</span><br><span class="line">                        <span class="keyword">return</span> v;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        h ^= h &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                        h ^= h &gt;&gt;&gt; <span class="number">3</span>;</span><br><span class="line">                        h ^= h &lt;&lt; <span class="number">10</span>; <span class="comment">// xorshift</span></span><br><span class="line">                        <span class="keyword">if</span> (h == <span class="number">0</span>) <span class="comment">// initialize hash</span></span><br><span class="line">                            h = SPINS | (<span class="keyword">int</span>) t.getId();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// approx 50% true</span></span><br><span class="line">                            (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                            Thread.yield(); <span class="comment">// two yields per wait</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.getObjectVolatile(a, j) != p)</span><br><span class="line">                        <span class="comment">// 和slotExchange方法中的类似，arena数组中的数据已被CAS设置</span></span><br><span class="line">                       <span class="comment">// match值还未设置，让其再自旋等待match被设置</span></span><br><span class="line">                        spins = SPINS; <span class="comment">// releaser hasn't set match yet</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; m == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (!timed ||</span><br><span class="line">                            (ns = end - System.nanoTime()) &gt; <span class="number">0</span> L)) &#123;</span><br><span class="line">                        <span class="comment">// 设置线程t被当前对象阻塞</span></span><br><span class="line">                        U.putObject(t, BLOCKER, <span class="keyword">this</span>); <span class="comment">// emulate LockSupport</span></span><br><span class="line">                         <span class="comment">// 线程t赋值</span></span><br><span class="line">                        p.parked = t; <span class="comment">// minimize window</span></span><br><span class="line">                        <span class="keyword">if</span> (U.getObjectVolatile(a, j) == p)</span><br><span class="line">                            <span class="comment">// 数组中对象还相等，表示线程还未被唤醒，唤醒线程</span></span><br><span class="line">                            U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">                        p.parked = <span class="keyword">null</span>;</span><br><span class="line">                         <span class="comment">// 设置线程t未被任何对象阻塞</span></span><br><span class="line">                        U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.getObjectVolatile(a, j) == p &amp;&amp;</span><br><span class="line">                        U.compareAndSwapObject(a, j, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 这里给bound增加加一个SEQ</span></span><br><span class="line">                        <span class="keyword">if</span> (m != <span class="number">0</span>) <span class="comment">// try to shrink</span></span><br><span class="line">                            U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, b, b + SEQ - <span class="number">1</span>);</span><br><span class="line">                        p.item = <span class="keyword">null</span>;</span><br><span class="line">                        p.hash = h;</span><br><span class="line">                        i = p.index &gt;&gt;&gt;= <span class="number">1</span>; <span class="comment">// descend</span></span><br><span class="line">                        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (timed &amp;&amp; m == <span class="number">0</span> &amp;&amp; ns &lt;= <span class="number">0</span> L)</span><br><span class="line">                            <span class="keyword">return</span> TIMED_OUT;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// expired; restart</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 交换失败，表示有其它线程更改了arena数组中下标i的元素</span></span><br><span class="line">                p.item = <span class="keyword">null</span>; <span class="comment">// clear offer</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此时表示下标不在bound &amp; MMASK或q不为null但CAS操作失败</span></span><br><span class="line">           <span class="comment">// 需要更新bound变化后的值</span></span><br><span class="line">            <span class="keyword">if</span> (p.bound != b) &#123; <span class="comment">// stale; reset</span></span><br><span class="line">                p.bound = b;</span><br><span class="line">                p.collides = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 反向遍历</span></span><br><span class="line">                i = (i != m || m == <span class="number">0</span>) ? m : m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c = p.collides) &lt; m || m == FULL ||</span><br><span class="line">                !U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, b, b + SEQ + <span class="number">1</span>)) &#123;</span><br><span class="line">                 <span class="comment">// 记录CAS失败的次数</span></span><br><span class="line">                p.collides = c + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 循环遍历</span></span><br><span class="line">                i = (i == <span class="number">0</span>) ? m : i - <span class="number">1</span>; <span class="comment">// cyclically traverse</span></span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 此时表示bound值增加了SEQ+1</span></span><br><span class="line">                i = m + <span class="number">1</span>; <span class="comment">// grow</span></span><br><span class="line">            <span class="comment">// 设置下标</span></span><br><span class="line">            p.index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完上面<code>slotExchange</code>方法和<code>arenaExchange</code>方法定义，我们可以看出Exchanger工具类的实现还是很复杂的，虽然Exchanger的使用比较简单。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> Exchanger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发工具之Semaphore源码解析</title>
      <link href="/juc-semaphore/"/>
      <url>/juc-semaphore/</url>
      
        <content type="html"><![CDATA[<p>Semaphore（信号量）是用来控制同时访问特定资源线程数量的工具。它通过协调各个线程，以保证合理的使用公共资源。以一个停车场的运作为例。为了简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆不受阻碍的进入，然后放下车拦，剩下的车则必须在入口等待，后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开两辆，则又可以放入两辆，如此往复。这个停车系统中，每辆车就好比一个线程，看门人就好比一个信号量，看门人限制了可以活动的线程。假如里面依然是三个车位，但是看门人改变了规则，要求每次只能停两辆车，那么一开始进入两辆车，后面得等到有车离开才能有车进入，但是得保证最多停两辆车。对于Semaphore类而言，就如同一个看门人，限制了可活动的线程数。</p><h3 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h3><p>semaphore结构如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/semaphore%E7%BB%93%E6%9E%84%E5%9B%BE.png"  alt="semaphore结构"></p><p>从上图我们可以看出，Semaphore包含了公平锁(FairSync)和非公平锁(NonfairSync)，而这两个内部类又都继承自内部类Sync，Sync又继承AQS(AbstractQueuedSynchronizer)。</p><p>Semaphore提供了两个构造方法，分别是：</p><ul><li>public Semaphore(int permits)：使用给定的许可数量和非公平模式创建Semaphore。</li><li>public Semaphore(int permits, boolean fair)：使用给定的许可数量和公平性模式创建Semaphore。</li></ul><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认创建一个非公平锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  permits [许可数量]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>         [创建Semaphore]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据fair创建公平或者非公平锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  permits [许可数量]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  fair    [公平性,true：公平；false：非公平]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>         [创建Semaphore]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Semaphore默认提供非公平锁，当permits的值设置为1时，Semaphore可以当排他锁使用。其中0和1就相当于它的状态，当等于1时表示其他线程可以获取，当等于0时，排他，即其他线程必须要等待。</p><h3 id="信号量获取"><a href="#信号量获取" class="headerlink" title="信号量获取"></a>信号量获取</h3><p>Semaphore提供了<code>acquire()</code>方法来获取一个许可，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从信号量(semaphore)中获取一个许可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用了AQS的<code>acquireSharedInterruptibly(int arg)</code>方法,该方法以共享模式获取同步状态。其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//判断线程是否被中断，如果中断，则抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//尝试获取锁，如果获取失败即返回的结果为-1，则执行doAcquireSharedInterruptibly方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在acquireSharedInterruptibly(int arg) 方法中，tryAcquireShared(arg)是由子类实现，对于Semaphore而言，如果我们选择了公平模式，则调用FairSync的tryAcquireShared(int acquires)，如果我们选择了非公平模式，则调用NonfairSync的tryAcquireShared(int acquires)方法。</p><h3 id="公平"><a href="#公平" class="headerlink" title="公平"></a>公平</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//判断等待队列中的头结点是否是当前线程，即是否有线程等待获取锁的时间比当前线程更长，如果有则返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获取当前信号量许可(获取AQS中state的值)</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="comment">//许可数减去acquires后，剩余的信号量许可</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="comment">//当剩余许可量小于0或者CAS设置剩余许可量成功,则返回剩余许可量</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非公平"><a href="#非公平" class="headerlink" title="非公平"></a>非公平</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取当前信号量许可</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">         <span class="comment">//许可数减去acquires后，剩余的信号量许可</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="comment">//当剩余许可量小于0或者CAS设置剩余许可量成功,则返回剩余许可量</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比公平和非公平获取信号量的源码，我们可以放心，公平获取信号量许可仅仅是多了检查是否有线程等待的时间比当前线程更长。其它的没有任何区别。</p><h3 id="信号量释放"><a href="#信号量释放" class="headerlink" title="信号量释放"></a>信号量释放</h3><p>当获取了信号量许可，使用完毕后，需要释放。Semaphore提供了<code>release()</code>方法来释放许可，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法内部调用了AQS的releaseShared(int arg)方法，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法实际调用了Semaphore内部类Sync的tryReleaseShared(arg)方法，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取当前许可</span></span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="comment">//当前许可数加上要释放的许可数量</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="comment">//CAS设置许可量为next   </span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信号量的获取和释放的详细过程，请看作者前面的AQS系列文章。</p><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>我们以最开始停车场的例子，来看看Semaphore的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parking</span> </span>&#123;</span><br><span class="line">        <span class="comment">//信号量</span></span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        Parking(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            semaphore = <span class="keyword">new</span> Semaphore(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取信号量</span></span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                Random random = <span class="keyword">new</span> Random();</span><br><span class="line">                <span class="keyword">int</span> time = random.nextInt(<span class="number">10</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"进入停车场，停车"</span> + time + <span class="string">"秒..."</span>);</span><br><span class="line">                Thread.sleep(time);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"离开停车场..."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        Parking parking;</span><br><span class="line"></span><br><span class="line">        Car(Parking parking) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parking = parking;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            parking.park(); <span class="comment">//进入停车场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parking parking = <span class="keyword">new</span> Parking(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Car(parking).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Semaphore的分析到此结束，是不是非常的简单呢？</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> Semaphore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发工具之CyclicBarrier源码解析</title>
      <link href="/juc-cyclicbarrier/"/>
      <url>/juc-cyclicbarrier/</url>
      
        <content type="html"><![CDATA[<p>CyclicBarrier顾名思义就是可循环使用的屏障。它主要实现的功能是让一组线程到达一个屏障(也可以叫同步点)时阻塞，直到最后一个线程到达屏障时，屏障才会放行，所有被屏障拦截的线程才可以继续运行。</p><h3 id="CyclicBarrier结构"><a href="#CyclicBarrier结构" class="headerlink" title="CyclicBarrier结构"></a>CyclicBarrier结构</h3><p>CyclicBarrier结构如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/CyclicBarrier%E7%BB%93%E6%9E%84.png"  alt="CyclicBarrier结构"></p><p>通过上图我们可以看到，CyclicBarrier是通过ReentrantLock和Condition来实现的。它有两个构造方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//拦截线程数量</span></span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="comment">//屏障放开前，执行的操作</span></span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier没有无参构造函数，它最少需要传递一个int变量来初始化拦截线程数量的个数。barrierAction它是一个实现了Runnable接口的参数，该参数不是必须的，它的作用是当屏障开发前，执行barrierAction参数中的run方法。</p><h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><p>await方法是CyclicBarrier中的关键方法，每个线程在调用await方法告诉CyclicBarrier该线程已经到达屏障了，然后线程被阻塞，直到最后一个线程到达屏障后，屏障才会放行，线程开始执行。await方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0</span> L);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await实际调用的是dowait方法，该方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">TimeoutException </span>&#123;</span><br><span class="line">    <span class="comment">//获取ReentrantLock锁对象</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//分代</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">    <span class="comment">//如果当前generation已经被损坏，则抛出BrokenBarrierException异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"><span class="comment">//当前线程被打断,抛出中断异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//将损坏状态设置为true</span></span><br><span class="line">            <span class="comment">//并通知其他等待在此栅栏上的线程</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">//如果当前是最后一个线程</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123; <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="comment">//执行栅栏任务</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//更新下一代，将count重置，generation重置</span></span><br><span class="line">                <span class="comment">//唤醒之前等待的线程</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有时间限制，则直接进入等待状态，直到被唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="comment">//如果有时间限制，则等待指定时间</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0</span> L)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">//当前代没有被损坏</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; !g.broken) &#123;</span><br><span class="line">                    <span class="comment">//让栅栏失效</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    <span class="comment">// 上面条件不满足，说明这个线程不是这代的</span></span><br><span class="line">                    <span class="comment">// 就不会影响当前这代栅栏的执行，所以，就打个中断标记</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">// 当有任何一个线程中断了，就会调用breakBarrier方法</span></span><br><span class="line">            <span class="comment">// 就会唤醒其他的线程，其他线程醒来后，也要抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"><span class="comment">// g != generation表示正常换代了，返回当前线程所在栅栏的下标</span></span><br><span class="line">            <span class="comment">// 如果 g == generation，说明还没有换代，那为什么会醒了？</span></span><br><span class="line">            <span class="comment">// 因为一个线程可以使用多个栅栏，当别的栅栏唤醒了这个线程，就会走到这里，所以需要判断是否是当前代。</span></span><br><span class="line">            <span class="comment">// 正是因为这个原因，才需要generation来保证正确。</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"><span class="comment">// 如果有时间限制，且时间小于等于0，销毁栅栏并抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span> L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的<code>dowait()</code>方法的源码中我们可以看出，<code>dowait()</code>方法的逻辑处理还是比较简单的，如果当前线程不是最后一个到达栅栏，则阻塞当前线程，除非遇到以下几种情况：</p><ol><li>最后一个线程到达，即index==0；</li><li>当前线程被其它线程中断；</li><li>当前线程超出指定等待时间；</li><li>其它线程中断另一个等待的线程；</li><li>其它的线程等待在栅栏处超时；</li><li>其它线程调用了cyclicBarrier的reset()方法。reset()方法将cyclicBarrier重置为初始化状态。</li></ol><h3 id="Generation对象"><a href="#Generation对象" class="headerlink" title="Generation对象"></a>Generation对象</h3><p>在上面<code>dowait()</code>方法里面，我们可以看到其方法的实现是借助了Generation对象，那么Generation是什么呢？他究竟起到了什么作用了？下面我们就来看看Generation。</p><p>Generation在CyclicBarrier源码中给出的定义如下：</p><blockquote><p>barrier每使用一次就代表创建了一个generation的实例。当barrier被tripped或者reset时，对应的generation会发生改变。由于非确定性，锁可能会分配给等待的线程，因此可能会存在许多和使用barrier相关的generation，但是这些线程同一时间只能有一个处于活动状态，其余的要么broken，要么tripped。如果出现了中断，但是没有后续的reset，则不需要一个激活的generation。</p></blockquote><p>上面Generation的定义可能不太好理解，简单的来说就是，同一批线程属于同一代，拥有相同的Generation对象；当有parties 个线程到达barrier后，Generation会被更新换代。Generation是线程是否属于同一代的标识。Generation定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="comment">//broken表示当前barrier是否处于中断状态，默认为false</span></span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当barrier被损坏或者有一个线程被中断时，则通过breakBarrier()方法来终止所有线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在breakBarrier()中除了将broken设置为true，还会调用signalAll将在CyclicBarrier处于等待状态的线程全部唤醒。</p><p>当所有线程都已经到达barrier处（index == 0），则会通过nextGeneration()进行更新换的操作，在这个步骤中，做了三件事：唤醒所有线程、重置count和换代generation。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">trip.signalAll();</span><br><span class="line">count = parties;</span><br><span class="line">generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><p>CountDownLatch的计数器只能使用一次，并且它是一个线程等待N个线程执行完后开始执行，而CyclicBarrier的计数器可以重复使用，且N个线程之间相互等待，任何一个线程完成之前，所有的线程都必须等待。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>CyclicBarrier 的用途是让一组线程互相等待，直到全部到达某个公共屏障点才开始继续工作。</li><li>CyclicBarrier 是可以重复利用的。</li><li>在等待的线程中只要有一个线程发生中断或者超时，则其它线程就会被唤醒继续并抛出BrokenBarrierException异常。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> cyclicBarrier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发容器之CountDownLatch源码分析</title>
      <link href="/juc-countdownlatch/"/>
      <url>/juc-countdownlatch/</url>
      
        <content type="html"><![CDATA[<p>CountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。它是通过一个计数器来实现的，当我们在new 一个CountDownLatch对象的时候需要带入该计数器值，该值就表示了线程的数量。每当一个线程完成自己的任务后，计数器的值就会减1。当计数器的值变为0时，就表示所有的线程均已经完成了任务，然后就可以恢复等待的线程继续执行了。</p><p>我们先用一个简单的实例来了解下CountDownLatch的使用，实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> LATCH_SIZE = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch doneSignal;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">doneSignal = <span class="keyword">new</span> CountDownLatch(LATCH_SIZE);</span><br><span class="line"><span class="comment">// 新建5个任务</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;LATCH_SIZE; i++)</span><br><span class="line"><span class="keyword">new</span> Task().start();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"main await begin."</span>);</span><br><span class="line"><span class="comment">// "主线程"等待线程池中5个任务的完成</span></span><br><span class="line">doneSignal.await();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"main await finished."</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" sleep 1000ms."</span>);</span><br><span class="line"><span class="comment">// 将CountDownLatch的数值减1</span></span><br><span class="line">doneSignal.countDown();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：创建等待线程数为5，当主线程Main运行到doneSignal.wait()时会阻塞当前线程，直到另外5个线程执行完成之后主线程才会继续执行。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数设置锁标识state的值，CountDownLatch countDownLatch = new  CountDownLatch(5) 实现的操作是设置锁标识state的值为5,其构建函数的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync为CountDownLatch的一个内部类，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个内部类Sync我们可以清楚地看到CountDownLatch是采用共享锁来实现的。</p><h3 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h3><p>CountDownLatch中await的逻辑是如果state的值不等于0，表示还有其他线程没有执行完（其他线程执行完之后会将state减一操作），此时主线程处于阻塞状态,其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里acquireSharedInterruptibly会进行state状态判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">//tryAcquireShared函数用来判断state的值是否等于0</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tryAcquireShared</code>中的操作是判断锁标识位state是否等于0，如果不等于0，则调用doAcquireSharedInterruptibly函数，阻塞线程。内部类Sync重写了<code>tryAcquireShared(int args)</code>方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;  <span class="comment">//判断锁标识位state是否等于0，在构造函数时会给state赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doAcquireSharedInterruptibly(arg)</code>操作的判断是将当前线程放到FIFO队列中，并将线程阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//将线程添加到FIFO队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//parkAndCheckInterrupt完成线程的阻塞操作</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="countDown"><a href="#countDown" class="headerlink" title="countDown()"></a>countDown()</h3><p> CountDownLatch中countDown()操作是将锁标识位state进行减一操作，如果state此时减一之后为0时则唤起被阻塞线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>); <span class="comment">//将state值进行减一操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//releaseShared中完成的操作是将锁标识位state进行减一操作，如果state此时减一之后为0时则唤起被阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//将锁标识位state进行减arg操作</span></span><br><span class="line">        doReleaseShared();<span class="comment">//唤起阻塞线程操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在tryReleaseShared中会完成state的减值操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取state值</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//进行减一操作</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//cas操作完成state值的修改</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">//如果nextc等于0则返回</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doReleaseShared完成阻塞线程的唤起操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//完成阻塞线程的唤起操作</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CountDownLatch内部通过共享锁实现。在创建CountDownLatch实例时，需要传递一个int型的参数：count，该参数为计数器的初始值，也可以理解为该共享锁可以获取的总次数。当某个线程调用await()方法，程序首先判断count的值是否为0，如果不会0的话则会一直等待直到为0为止。当其他线程调用countDown()方法时，则执行释放共享锁状态，使count值 – 1。当在创建CountDownLatch时初始化的count参数，必须要有count线程调用countDown方法才会使计数器count等于0，锁才会释放，前面等待的线程才会继续运行。注意CountDownLatch不能回滚重置。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC之Condition源码分析</title>
      <link href="/juc-condition-source/"/>
      <url>/juc-condition-source/</url>
      
        <content type="html"><![CDATA[<p>Condition接口定义了类似Object的监视器方法，它与Lock配合能够实现等待/通知模式，我们知道Object类中的wait()和notify()方法与synchronized关键字配合也能实现等待/通知模式,但是这两者在使用方式和功能上是有差别的，下面是Condition和Object监视方法的对比：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/Condition%E6%8E%A5%E5%8F%A3%E4%B8%8EObject%E7%9B%91%E8%A7%86%E5%99%A8%E6%96%B9%E6%B3%95%E6%AF%94%E5%AF%B9.png"  alt="Condition接口与Object监视器方法比对"></p><p>Condition接口提供的方法列表如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/Condition%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95.png"  alt="Condition接口方法"></p><p>Condition的实例必须通过Lock.newCondition()方法来获取，下面通过一个简单的示例来看一下Condition的使用方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] items;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count,addIndex,removeIndex;</span><br><span class="line">    <span class="keyword">private</span> Condition empty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition full = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionDemo</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"size 参数异常!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        items = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)&#123;</span><br><span class="line">                full.await();</span><br><span class="line">            &#125;</span><br><span class="line">            items[addIndex] = t;</span><br><span class="line">            <span class="keyword">if</span>(++ addIndex ==  items.length)&#123;</span><br><span class="line">                addIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            empty.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">                empty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            Object x = items[removeIndex];</span><br><span class="line">            <span class="keyword">if</span>(++removeIndex == items.length)&#123;</span><br><span class="line">                removeIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --count;</span><br><span class="line">            full.signalAll();</span><br><span class="line">            <span class="keyword">return</span> (T) x;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，ConditionDemo通过add(T t)添加一个元素，通过remove()删除一个元素。我们从上面代码中可以看到，Condition必须和Lock配合使用才能达到等待/通知的效果。在<code>add(T t)</code>方法中，首先获取锁确保items数组的可见性和排他性。当数组的数量等于数组长度时，表示数组已满，调用<code>full.await()</code>,当前线程随之释放锁进入等待状态。如果数组数量不等于数组长度，则表示数组未满，向数组中添加一个元素，同时通知等待在empty上的线程，数组中已经存在元素可以获取。<code>remove()</code>方法的流程大致与<code>add(T t)</code>一样，这里就不在赘述了。</p><h3 id="Condition的实现"><a href="#Condition的实现" class="headerlink" title="Condition的实现"></a>Condition的实现</h3><p>Condition作为一个接口，其下仅有一个实现类ConditionObject，由于Condition的操作需要获取相关的锁，而AQS则是同步锁的实现基础，所以ConditionObject则定义为AQS的内部类。定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>每个Condition对象都包含着一个等待队列，该队列是Condition对象实现等待/通知功能的关键。等待队列是一个FIFO的队列，在队列中每个节点都包含了一个线程，该线程就是等待在Condition对象上的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁，构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了AQS中节点的定义，也就是说同步队列和等待队列中的节点类型都是AQS中的静态内部类AbstractQueuedSynchronizer.Node。下面代码是ConditionObject在AQS中的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">/** 等待队列中的第一个节点 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">/** 等待队列中的最后一个节点 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a new &#123;<span class="doctag">@code</span> ConditionObject&#125; instance.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...... 省略方法</span></span><br></pre></td></tr></table></figure><p>从上面代码中，我们可以看到Condition中包含了一个首节点（firstWaiter）和一个尾节点（lastWaiter）。当前线程调用await()方法，当前线程将会构造成节点，并添加到等待队列的尾部。等待队列的基本结构如下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"  alt="等待队列的基本结构"></p><p>如图所示，Condition拥有首节点的引用，而新增节点只需要将原尾节点的nextWaiter指向它，并更新尾节点即可。Object监视器的模型上，一个对象拥有一个同步队列和一个等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列。</p><h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>在当前线程调用Condition中的await()方法时，会使当前线程进入到等待队列并释放锁，同时线程状态变更为等待状态。当线程中await()方法返回时，当前线程一定获取了Condition相关联的锁。从同步队列的角度来看，当调用await()方法时，相当于同步队列的首节点移动到等待队列的队尾。ConditionObject中await()方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果线程被中断，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 当前线程加入到等待队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步状态，也就是释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断节点是否在同步队列中，如果不在同步队列中则将线程挂起，进入阻塞状态</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 挂起当前线程，调用次方法后线程会阻塞在这个地方，直到被唤醒或者中断</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 当线程被唤醒后，判断线程是否已经被中断，如果中断则直接跳转while循环，否则进入再次进入while判断</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自旋的方式获取同步状态（即获取锁），如果返回true则表示当前线程已经被中断</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 处理被中断的情况</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要逻辑是首先判断当前线程是否被中断，如果中断了则直接抛出中断异常。如果线程没有被中断，则将当前线程构建成节点添加到等待队列尾部，然后释放当前线程获取的锁（同步状态）并唤醒同步队列中的后续节点，然后当前线程进入等待状态。当等待队列中的节点被唤醒，则唤醒的节点的线程以自旋的方式获取锁（同步状态，这也说明了从await方法中退出必须获取到与Condition相关联的锁）。如果获取同步状态成功，则清理等待队列中不是等待状态的节点并处理中断情况。<code>await()</code>方法的逻辑理清了，但是我们还有几个疑问：1、线程是如何加入到等待队列中的？；2、锁释放的过程？；3、怎样才能从await()方法中退出？下面我们来对这3个疑问进行解答。</p><h5 id="线程是如何加入到等待队列中的？"><a href="#线程是如何加入到等待队列中的？" class="headerlink" title="线程是如何加入到等待队列中的？"></a>线程是如何加入到等待队列中的？</h5><p>从 <code>await()</code> 方法的源码中我们看到线程被加入到等待队列中是通过调用<code>addConditionWaiter()</code>方法来处理的，我们来看看<code>addConditionWaiter()</code>方法的源码定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前线程包装成Node节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="comment">// 如果等待队列为空，则将当前node节点赋值给firstWaiter，否则将当前节点指向 t.nextWaiter</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    <span class="comment">// 当当前节点更新为lastWaiter</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码逻辑比较简单，首先清理掉了等待队列中已经关闭的节点，然后将当前线程构建成一个waiteState为Node.CONDITION的Node节点。然后判断等待队列中是否为空，如果等待队列为空，则将当前构造的Node节点指向firstWaiter，如果等待队列不为空，则将当前构造的Node节点指向lastWaiter.nextWaiter，最后更新lastWaiter为当前构造的Node节点。弄清楚了将当前线程添加到等待队列中去后，我们在来看看当前线程是如何释放锁的。</p><h5 id="锁释放的过程"><a href="#锁释放的过程" class="headerlink" title="锁释放的过程"></a>锁释放的过程</h5><p>从 <code>await()</code> 方法的源码中我们看到线程线程释放锁通过调用<code>fullyRelease(node)</code>方法来处理的，该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前同步状态</span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 如果释放同步状态成功，则返回之前保存的同步状态的值</span></span><br><span class="line">        <span class="comment">// （以独占模式释放同步状态）</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果释放失败，则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 如果抛出异常，则将当前节点的等待状态的值更新为Node.CANCELLED</span></span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中我们开的释放锁的主要实现是调用<code>release(savedState)</code>方法，而<code>release(savedState)</code>方法在前面AQS系列文章中已将讲到过，这里就不在赘述。我们知道release方法在释放同步状态后会唤醒同步队列中的后续节点来获取锁进行处理。</p><h5 id="怎样才能从await-方法中退出"><a href="#怎样才能从await-方法中退出" class="headerlink" title="怎样才能从await()方法中退出"></a>怎样才能从await()方法中退出</h5><p>从<code>await()</code>方法中我们看到，退出await()方法的条件定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 挂起当前线程，调用此方法后线程会阻塞在这个地方，直到被唤醒或者中断</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 当线程被唤醒后，判断线程是否已经被中断，如果中断则直接跳转while循环，否则进入再次进入while判断</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，退出await()方法的条件要么是执行到break,要么是while条件为false。第一种情况的条件是当前线程被中断后代码会走break退出，第二种情况是当前节点被移动到同步队列中去了（即另外的线程调用了Condition中的signal()方法或signalAll()方法）。</p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>当线程调用Condition中的signal()方法时，将会唤醒等待队列中的等待时间最长的节点（即等待队列中的第一个节点），在唤醒之前，会将节点移到同步队列中去。signal()方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查当前线程是否获取了锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中我们可以看到，调用该方法的前置条件是当前线程必须获取了锁。signal()方法实际调用的是doSignal()方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">        (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将节点从条件队列传输到同步队列。</span></span><br><span class="line"><span class="comment"> * 如果成功则返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果无法更改waitStatus，则该节点已被取消</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将节点添加到同步队列尾部,并返回当前节点的前驱节点</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="comment">//获取前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">//如果该结点的状态为cancel 或者修改waitStatus失败，则直接唤醒。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，正常情况 ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL) 这个判断是不会为true的，所以，不会在这个时候唤醒该线程。只有到发送signal信号的线程调用reentrantLock.unlock()后因为它已经被加到AQS的等待队列中，所以才会被唤醒。被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。 </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后我们来总结下await()方法和signal()方法的流程，其流程图如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/await%E6%96%B9%E6%B3%95%E5%92%8Csignal%E6%96%B9%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B.png"  alt="await方法和signal方法的流程"></p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC之读写锁：ReentrantReadWriteLock源码解析</title>
      <link href="/juc-write-lock/"/>
      <url>/juc-write-lock/</url>
      
        <content type="html"><![CDATA[<h4 id="ReentrantReadWriteLock介绍"><a href="#ReentrantReadWriteLock介绍" class="headerlink" title="ReentrantReadWriteLock介绍"></a>ReentrantReadWriteLock介绍</h4><h3 id="ReentrantReadWriteLock介绍-1"><a href="#ReentrantReadWriteLock介绍-1" class="headerlink" title="ReentrantReadWriteLock介绍"></a>ReentrantReadWriteLock介绍</h3><p>读写锁的特性是在同一时刻，可以允许多个读线程访问，但是在写线程访问时，所有读线程和其它写线程都会被阻塞。读写锁内部维护了一对锁，它们分别是一个读锁和一个写锁。通过读锁和写锁的分离，使得并发性相比于一般的排他锁有了很大的提升。读写锁简化了读写交互场景的编程方式，在读写锁出现之前，如果要实现读写锁的功能，就要使用Java的等待通知机制，即当写操作时，所有晚于写操作的读操作均会进入等待状态，当写操作完成并通知之后，所有等待的读操作才能继续执行，这样做的目的是使得所有的读操作都能够获取正确的值，不会出现脏读。</p><p>一般情况下，读写锁的性能都会比排他锁好，因为在大多数场景中，读操作要多于写操作，在读操作多于写操作的情况下，读写锁能够提供比排它锁更好的并发和吞吐量。Java并发包提供的读写锁的实现是ReentrantReadWriteLock类，它的特性如下：</p><ul><li>公平选择性：ReentrantReadWriteLock提供了公平锁和非公平锁的获取。默认是非公平锁。</li><li>重进入：ReentrantReadWriteLock支持重进入，读锁能够再次获取读锁，写锁也能够再次获取写锁。</li><li>锁降级：遵循获取写锁、获取读锁再释放写锁的顺序，写锁能够降级为读锁。</li></ul><h3 id="ReentrantReadWriteLock结构"><a href="#ReentrantReadWriteLock结构" class="headerlink" title="ReentrantReadWriteLock结构"></a>ReentrantReadWriteLock结构</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/ReentrantReadWriteLock%E7%BB%93%E6%9E%84.png"  alt="ReentrantReadWriteLock结构"></p><p>从上图我们可以大概了解ReentrantReadWriteLock类的内部构成。</p><ul><li>ReentrantReadWriteLock类实现了ReadWriteLock和Serializable接口。</li><li>ReentrantReadWriteLock类中维护了ReadLock，WriteLock，Sync,NonfairSync和FairSync这个几个静态内部类。</li><li>NonfairSync和FairSync又是继承Sync这个静态内部类。</li><li>Sync这个类中又维护了HoldCounter和ThreadLocalHoldCounter这2个内部类，并且继承了AbstractQueuedSynchronizer</li></ul><h3 id="读写锁Sync对于AQS的使用"><a href="#读写锁Sync对于AQS的使用" class="headerlink" title="读写锁Sync对于AQS的使用"></a>读写锁Sync对于AQS的使用</h3><p>读写锁中<code>Sync</code>类是继承于<code>AQS</code>，并且主要使用上文介绍的数据结构中的<code>state</code>及<code>waitStatus</code>变量进行实现。<br>实现读写锁与实现普通互斥锁的主要区别在于需要分别记录读锁状态及写锁状态，并且等待队列中需要区别处理两种加锁操作。<br><code>Sync</code>使用<code>state</code>变量同时记录读锁与写锁状态，将<code>int</code>类型的<code>state</code>变量分为高16位与低16位，高16位记录读锁状态，低16位记录写锁状态，如下图所示：<img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E8%AF%BB%E5%86%99%E9%94%81%E7%8A%B6%E6%80%81.png"  alt="读写锁状态"></p><h3 id="ReentrantReadWriteLock源码分析"><a href="#ReentrantReadWriteLock源码分析" class="headerlink" title="ReentrantReadWriteLock源码分析"></a>ReentrantReadWriteLock源码分析</h3><h4 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h4><p>写锁是一个支持重进入的排他锁，如果线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取到写锁的线程，则当前线程进入等待状态。获取写锁的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先调用readLock的lock()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync是继承了AbstractQueuedSynchronizer类的实例，因此调用acquire(1)方法实际是调用AbstractQueuedSynchronizer类中的acquire(int arg) 方法。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AQS系列文章中，分析了acquire(int arg)方法的实现，这里就不再赘述了。我们知道了tryAcquire(arg)方法是自定义同步器自己实现的方法。因此tryAcquire(arg) 方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 获取写状态值</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">// 判是否有线程持有同步状态，即线程获取了读锁或者写锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        * 如果写状态为0，则表示写锁未被持有,但是c!=0,表示读锁已经被持有  </span></span><br><span class="line"><span class="comment">        * 或者 当前线程不是持有锁的线程，则返回获取锁失败</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 当w != 0 或者 当前线程是持有锁的线程，进行下面操作</span></span><br><span class="line">        <span class="comment">// 如果重入读锁的次数超过限制，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 设置同步状态为写锁的重入次数</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="comment">// 获取写锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当同步状态为0时，表示读锁或者写锁都未被持有</span></span><br><span class="line">   <span class="comment">// 如果写线程应该被阻塞 或者 CAS设置同步状态失败，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 获取写锁成功，设置当前线程未独占线程</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法中，我们看到写锁的同状态是通过exclusiveCount(c)方法来获取的，我们来看看exclusiveCount(c)的定义，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 获取独占锁状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 相当于 c &amp; 0XFFFF</span></span><br><span class="line">    <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码我们可以看到，读写锁中写状态就是同步状态state的低16位。这也可以解释为什么<code>w + exclusiveCount(acquires) &gt; MAX_COUNT</code>条件会抛出异常的原因。</p><p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时，表示写锁已经被释放，从而等待的读写线程能够继续访问读写锁。同步前一次写线程的修改的值对后续的读写线程可见。</p><h4 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h4><p>读锁是一个支持重进入的共享锁，同一时刻它能被多个线程同时获取，在没有其它写线程访问时，读锁总会被获取成功。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已经被其它线程获取，则进入等待状态。读锁获取源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果写状态不为0，则表示存在写锁。且当前线程不是持有写锁的线程，则获取读锁失败</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取读状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1. 判断读线程是否应该被阻塞</span></span><br><span class="line"><span class="comment">    * 2. 判断读状态释放超过最大值</span></span><br><span class="line"><span class="comment">    * 3. CAS设置同步状态释放成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">// 上面已经判断过写状态为0，此时如果读状态为0，表示可以直接获取读锁</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// firstReader：获取读锁的第一个线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            <span class="comment">// firstReaderHoldCount：第一个读线程持有读锁的重入次数</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//下面一段代码的作用是 记录每一个读线程获取读锁的重入次数</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取读锁失败，放到循环里重试。即在并发获取读锁的情况下，CAS失败的线程进入这里</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// rh:当前线程持有锁计数的变量</span></span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取同步状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 判断写状态是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果写状态不为0，且当前线程不是持有写锁的线程，则获取读锁失败</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 否则，当前线程持有写锁，在这里阻塞将会导致死锁</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 判断读线程是否被阻塞 </span></span><br><span class="line"><span class="comment">        * 这里readerShouldBlock()返回true的条件分为2种：</span></span><br><span class="line"><span class="comment">        * 1.当是公平锁时，readerShouldBlock()返回true的条件是当前线程所在的节点有前驱节点</span></span><br><span class="line"><span class="comment">        * 2.当是非公平锁时，readerShouldBlock()返回true的条件是等待队列中，头结点的下一个节点是独占节点，即为写锁等待。</span></span><br><span class="line"><span class="comment">        * 下面的一段代码，在读线程需要被阻塞的情况下，需要考虑读写锁的重入性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">           <span class="comment">// 当前显示是第一个获取读锁的线程时，锁重入不需要等待</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        <span class="comment">// 获取当前线程持有读锁情况</span></span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="comment">// 如果当前线程持有读锁的重入数量为0，即当前线程没有获取过读锁，也就是当前线程没有锁重进入特性</span></span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前读线程没有读锁的重进入，则获取读锁失败，需要进入等待队列</span></span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里，写锁状态为0，或者当前线程还有写锁，且线程也不需要被阻塞，说明可以获取读锁</span></span><br><span class="line">        <span class="comment">// 如果当前读锁状态值已经改为最大值，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// CAS方式设置读锁状态值，设置成功，读锁获取成功，设置失败自旋，重新从方法头开始</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">// 下面一段代码的主要作用就是 设置 线程获取读锁的重入次数</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到读锁的获取是比较复杂的，这里LZ再用一张图来表明读锁获取的整个流程。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E8%AF%BB%E9%94%81%E8%8E%B7%E5%8F%96%E6%B5%81%E7%A8%8B.png"  alt="读锁获取流程"></p><h4 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h4><p>在ReadLock中调用unlock()方法即释放读锁，unlock()方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，unlock()方法中调用的是<code>Sync</code>中的<code>releaseShared(int arg)</code>方法，这个方法在AQS类中，实际上真正调用的是<code>Sync</code>中的<code>tryReleaseShared(arg)</code>方法，该方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 判断当前线程是否是一个获取读锁的线程</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程是第一个获取读锁的线程</span></span><br><span class="line">        <span class="comment">// 如果第一个获取读锁线程的获取读锁的计数为1，则设置第一个获取读锁的线程为null</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则 第一个获取读锁的线程的获取读锁的次数减一</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程不是第一个获取读锁的线程</span></span><br><span class="line">        <span class="comment">// 获取线程计数的缓存</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="comment">// 如果rh == null 获取 rh 不是当前线程的HoldCounter，则获取当前线程的HoldCounter</span></span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="comment">// 获取当前线程获取读锁的次数</span></span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程获取读锁的重入次数 &lt;= 1，则将当前线程的HoldCounter从readHolds中移除</span></span><br><span class="line">            <span class="comment">// readHolds是ThreadLocalHoldCounter的实例，它继承ThreadLocal</span></span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前线程读锁的重入次数减一</span></span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里使用死循环的方式，确保当前线程的读锁能够释放</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 读状态每次减一，相当于AQS中state的值每次减少的值是 1&lt;&lt; 16 </span></span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="comment">// CAS方式更新state的值</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// 这里讲state == 0 作为释放成功的条件</span></span><br><span class="line">            <span class="comment">// 这里大家可能会有疑问，如果读锁是否完成，但是state 不为0呢，</span></span><br><span class="line">            <span class="comment">// 这很好理解，当读锁释放完毕但是state不为0时，表示写锁还未被释放</span></span><br><span class="line">            <span class="comment">// 既然写锁还存在，那么读锁释放完了，也不应该通知阻塞在CHL队列中的读线程来竞争锁</span></span><br><span class="line">            <span class="comment">// 因为读锁时排它锁，通知了读线程也会继续阻塞</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p>锁降级指的是写锁降级为读锁。锁降级需要遵循先获取写锁，然后获取读锁，在释放写锁的次序。需要注意的是，如果线程先获取写锁，然后释放写锁，再获取读锁，这种分段完成的过程不能称为锁降级。</p><p>锁降级在 tryAcquireShared 方法和 fullTryAcquireShared 中都有体现，例如下面的判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面的代码的意思是：当写锁被持有时，如果持有该锁的线程不是当前线程，就返回 “获取锁失败”，反之就会继续获取读锁。称之为锁降级。</p><p>锁降级中读锁的获取是否是必须要的呢？答案是<strong>必要的</strong>。主要是为了保证数据的可见性，试想一下，假如当前线程（A）直接释放写锁而不获取读锁，此时另一个线程（B）获取了写锁并且修改了数据，那么线程B修改后的数据是不会对线程A可见的。如果获取了读锁，那么线程B将会因为写锁的存在而被阻塞，直到当前线程A使用数据并释放读锁之后，线程B才能够获取写锁对数据进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC之重入锁：ReentrantLock源码解析</title>
      <link href="/reentrantlock-parsing/"/>
      <url>/reentrantlock-parsing/</url>
      
        <content type="html"><![CDATA[<h3 id="ReentrantLock简介"><a href="#ReentrantLock简介" class="headerlink" title="ReentrantLock简介"></a>ReentrantLock简介</h3><p>ReentrantLock可重入锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外还支持获取锁时的公平和非公平性的选择，也就是说ReentrantLock可以构建成一个公平锁，也可以构建成一个非公平锁。在java中与ReentrantLock一样可重入的锁就是synchronized关键字，synchronized关键字的隐式支持重进入，比如在一个递归的方法前面使用synchronized修饰，在方法执行时，线程在获取到了锁后然后可以继续获取锁执行代码。ReentrantLock虽然不像synchronized关键字一样支持隐式的重进入，但是ReentrantLokc在调用lock()方法时，已经获取到锁的线程能够再次调用lock()方法获取锁而不被阻塞。</p><p>这里提到了一个获取锁的公平性问题，如果在绝对的时间上，先等待的线程一定会优先获取到锁，那么这锁就是公平的，反之就是非公平的。从这里我们可以看出，公平性的锁效率是没有非公平性锁高的，但是为什么会有公平性的锁呢？那是因为公平性的锁能够减少”饥饿”发生的概率，等待越久的请求越是能够得到优先的满足。</p><h3 id="2ReentrantLock-结构"><a href="#2ReentrantLock-结构" class="headerlink" title="2ReentrantLock 结构"></a>2ReentrantLock 结构</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/ReentrantLock%E7%BB%93%E6%9E%84.png"  alt="ReentrantLock结构"></p><p>从上面的UML图中，我们可以看到ReentrantLock实现了Lock和Serializable接口，含有3个静态内部类，Sync、NonfairSync和FairSync。其中Sync是一个抽象内部类且继承了AbstractQueuedSynchronizer，NonfairSync（非公平锁）和FairSync（公平锁）都继承了Sync这个抽象类。</p><h3 id="ReentrantLock方法列表"><a href="#ReentrantLock方法列表" class="headerlink" title="ReentrantLock方法列表"></a>ReentrantLock方法列表</h3><ul><li><code>public ReentrantLock()</code>：无参构造函数，创建一个非公平性的ReentrantLock实例 </li><li><code>public ReentrantLock(boolean fair)</code>：创建一个ReentrantLock实例 fair参数如果为true,则ReentrantLock实例为公平锁，否则为非公平锁</li><li><code>public void lock()</code>：获取锁</li><li><code>public void lockInterruptibly() throws InterruptedException</code>：获取锁，对中断敏感</li><li><code>public boolean tryLock()</code>：尝试获取锁，获取成功返回true,反正返回false.</li><li><code>public void unlock()</code>：释放锁</li><li><code>public Condition newCondition()</code>：创建一个Condition实例。</li><li><code>public int getHoldCount()</code>：查询当前线程对该锁的持有数量。</li><li><code>public boolean isHeldByCurrentThread()</code>：查询此锁是否被当前线程持有</li><li><code>public boolean isLocked()</code>：查询此锁是否有线程持有</li><li><code>public final boolean isFair()</code>：查询此锁是否是公平锁，如果是公平锁则返回true,反之返回false.</li><li><code>protected Thread getOwner()</code>：获取当前持有该锁的线程，如果返回null,则表示该锁没有被任何线程持有</li><li><code>public final boolean hasQueuedThreads()</code>：查询是否有线程在等待获取该锁</li><li><code>public final boolean hasQueuedThread(Thread thread)</code>：查询给定的线程是否在等待获取该锁</li><li><code>public final int getQueueLength()</code>：获取等待获取该锁的线程个数的预估值，该值是一个预估值，因为在遍历内部数据结构时，线程的数量可能动态的改变</li><li><code>protected Collection&lt;Thread&gt; getQueuedThreads()</code>：获取等待获取该锁的线程集合</li><li><code>public boolean hasWaiters(Condition condition)</code>：查询是否有线程正在等待在该锁给定的等待条件下</li><li><code>public int getWaitQueueLength(Condition condition)</code>：获取等待在该线程给定的等待条件下的线程预估量</li><li><code>protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition)</code>：获取等待在该锁给定的等待条件下的线程集合</li></ul><h3 id="ReentrantLock-锁的获取"><a href="#ReentrantLock-锁的获取" class="headerlink" title="ReentrantLock 锁的获取"></a>ReentrantLock 锁的获取</h3><p>一般我们在使用ReentrantLock获取锁的时候是这样实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br></pre></td></tr></table></figure><p>lock方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面lock方法的实现非常的简单，就是调用了sync的lock方法，而sync是ReentrantLock类中的一个属性，该属性的类型是Sync类，Sync类是ReentrantLock类的一个抽象内部类，它继承了AbstractQueuedSynchronizer（AQS）同步器从而获取了锁。我们再来看看sync这个属性是在什么时候赋值的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中我们可以看到，sync 属性是在ReentrantLock的构造方法中赋值的，并且赋值的类型是NonfairSync或者FairSync。我们在ReentrantLock的UML图中已经知道了NonfairSync和FairSync类都是Sync的子类，这里又应用了Java的多态技术，即父类的引用指向子类对象。既然利用的是多态，那么就知道sync.lock()实际调用到的是NonfairSync类中的lock()方法或者FairSync类中的lock()方法。</p><h4 id="非公平锁的获取"><a href="#非公平锁的获取" class="headerlink" title="非公平锁的获取"></a>非公平锁的获取</h4><p>非公平锁lock方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="comment">// 获取锁失败，调用AQS中的acquire(int arg)方法</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先或尝试获取锁，如果获取锁失败，则调用AQS中的acquire(int arg)方法，该方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先调用tryAcquire(arg) 方法，而在前面的文章中LZ提到过tryAcquire(arg) 方法是需要同步器组件自己实现的方法，我们来看看这个方法在非公平锁中的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync中默认实现非公平尝试获取锁的方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程、</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果同步状态等于0 表示锁处于空闲状态 </span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取锁成功，设置为当前线程所有</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 锁重入</span></span><br><span class="line">    <span class="comment">// 判断持有锁的线程是否是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 计算获取锁的次数</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要实现的逻辑：首先判断同步状态state是否等于0，如果等于0表示该锁还未被任何线程锁持有，直接利用CAS获取同步状态，如果获取同步状态成功，则设置该锁为当前线程拥有并返回true。如果同步状态state不等于0，则判断持有该锁的线程是否为当前线程，如果是则获取锁，并计算该线程获取锁的次数，然后赋值给state。</p><h4 id="公平锁的获取"><a href="#公平锁的获取" class="headerlink" title="公平锁的获取"></a>公平锁的获取</h4><p>公平锁lock方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用AQS中的acquire(int arg)方法</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到公平锁做lock方法的实现是直接调用AQS中的acquire(int arg)方法。上面我们已经分析过acquire(int arg)方法中会调用tryAcquire(int arg)方法，而这个方法需要同步器自己实现，我们来看看公平锁中tryAcquire(int arg)方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果同步状态等于0，表示该锁空闲</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// hasQueuedPredecessors() 查询是否有线程等待的时间比当前线程更长，如果有true,没有返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 重入 和非公平锁一样</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法中，唯一和非公平锁不一样的地方在于，当state == 0时，不是用CAS获取同步状态，而是先判断是否有比当前线程等待更长时间的线程，如果存在，则当前线程不获取锁。</p><h3 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h3><p>锁的释放不存在公性和非公平性的问题，因此锁释放的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同步器Sync实现的tryRelease(int arg)方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前同步状态减去releases</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 释放的锁是否是当前持有锁的线程，不是抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果state == 0,表示已经释放完全，其它线程可以获取锁了</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以看出，如果一个锁被释放了n次，那么前（n-1）次tryRelease(int releases) 方法必须返回false，而只有同步状态完全释放了，才返回true。可以看到，该方法将同步状态是否为0作为最终是否释放锁的条件，当同步状态为0时，锁释放成功，设置锁占有的线程为null。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS之阻塞和唤醒线程</title>
      <link href="/threadblocking-wakeup/"/>
      <url>/threadblocking-wakeup/</url>
      
        <content type="html"><![CDATA[<p>在前面的文章中介绍了独占式同步状态的获取和释放以及共享式同步状态的获取和释放，在前面的文章中并没有介绍线程的阻塞和唤醒，在这篇文章中LZ将介绍在AQS中线程的阻塞和唤醒。<br>在线程获取同步状态失败后，会加入到CHL队列中去，并且该节点会自旋式的不断的获取同步状态，在获取同步状态的过程中，需要判断当前线程是否需要被阻塞。其主要方法在<code>acquireQueued(final Node node, int arg)</code>方法的定义里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>通过这段代码可以看出，线程在获取同步状态失败后，并不是立马进入等待状态，而是需要判断当前线程是否需要被阻塞。检查是否需要阻塞的方法<code>shouldParkAfterFailedAcquire(p, node)</code>，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果等待状态的值为SIGNAL,则返回true 表示当前线程需要等待</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 前驱节点的状态&gt;0，为CANCLE状态，表示该节点被中断或者超时，需要</span></span><br><span class="line"><span class="comment">         * 从CHL中移除。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 前驱节点为 PROPAGATE或者CONDITION 将前驱节点的等待状态以CAS的方式</span></span><br><span class="line"><span class="comment">         * 更新为SIGNAL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码主要的功能就是判断当前线程是否需要阻塞，当该方法的返回值为true时，表示当前线程需要等待，反之返回false.其规则如下：</p><ol><li>如果当前节点的前驱节点的等待状态为SIGNAL，则返回true</li><li>如果当前节点的前驱节点的等待状态为CALCLE，则表示该线程的前驱节点已经被中断或者超时，需要从CHL中删除，直到回溯到ws &lt;= 0,返回false</li><li>如果当前节点的前驱节点的等待状态为非SIGNAL,非CANCLE，则以CAS的方式设置其前驱节点为的状态为SIGNAL，返回false.</li></ol><p>当 shouldParkAfterFailedAcquire(Node pred, Node node)方法返回true时，会执行 parkAndCheckInterrupt()方法。该方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法就实现了将线程挂起，从而阻塞住线程的调用栈，已达到阻塞线程的目的。其内部则是调用了LockSupport工具类的park()方法来实现的。</p><p>当同步状态被释放后，需要唤醒后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unparkSuccessor()方法的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点的等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 当前节点状态 &lt; 0，则CAS方法设置当前状态为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//  如果后继节点为空或者后继节点的等待状态为CANCLE</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里很多人大概会有疑问为什么是从尾部回溯找到一个可用的节点，我们不妨先来回顾下添加节点的方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中我们可以看到，将节点添加到尾部是一个CAS操作，但是t.next = node 这个操作不是线程安全的，如果一个线程在执行CAS添加尾部之后正好有线程释放了同步状态，这个时候如果是从head到tail的遍历，则会出现中间断裂的情况，而从尾部回溯是一定可以遍历到所有节点的。<br>上面线程的唤醒和等待都是通过LockSupport工具类中的方法来实现的，我们来看看LockSupport这个工具类的。</p><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><h4 id="LockSupport介绍"><a href="#LockSupport介绍" class="headerlink" title="LockSupport介绍"></a>LockSupport介绍</h4><p>LockSupport是用于创建锁和其他同步类的基本线程阻塞原语。<br>LockSupport定义了一组以park开头的方法用来阻塞线程，以及以unpark(Thread thread)方法来唤醒一个线程。park方法和unpark方法提供了阻止和解除阻塞线程的有效手段，该方法不会遇到Threaad.suspend和Thread.resum方法导致的死锁问题。</p><h4 id="LockSupport方法列表"><a href="#LockSupport方法列表" class="headerlink" title="LockSupport方法列表"></a>LockSupport方法列表</h4><ul><li>getBlocker(Thread t) ：返回提供给最近调用尚未解除阻塞的park 方法调用的 blocker 对象，如果调用不阻止，则返回null</li><li>park() : 禁止当前线程进行线程调度，除非许可证可用。</li><li>park(Object blocker) ：禁止当前线程进行线程调度，除非许可证可用。</li><li>parkNanos(long nanos) ：禁止当前线程进行线程调度，直到指定的等待时间，除非许可证可用。</li><li>parkNanos(Object blocker, long nanos) ：禁止当前线程进行线程调度，直到指定的等待时间，除非许可证可用。</li><li>parkUntil(long deadline) ：禁止当前线程进行线程调度，直到指定的截止时间，除非许可证可用。</li><li>parkUntil(Object blocker, long deadline) ：禁止当前线程进行线程调度，直到指定的截止时间，除非许可证可用。</li><li>unpark(Thread thread) ：为给定的线程提供许可证（如果尚未提供）。</li></ul><p>上述方法中参数 blocker 是用来标识当前线程在等待的对象，该对象主要用于问题的排查和系统给的监控。</p><p>接下来我们在看看park和unpark方法的定义：</p><h4 id="park："><a href="#park：" class="headerlink" title="park："></a>park：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0</span> L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unpark："><a href="#unpark：" class="headerlink" title="unpark："></a>unpark：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面方法的定义中我们可以看出park和unpark方法都是通过UNSAFE类中的park和unpark方法来实现的。其UNSAFE中park和unpark的方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br></pre></td></tr></table></figure><p>可以看出这2个方法都是本地方法。Unsafe是一个不安全的类，主要用于执行低级别、不安全的方法集合。尽管Unsafe类中的方法都是public的，但是我们还是不能在自己的java代码中调用这个类中的方法，因为只有授信的代码才能获取到该类的实例。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS之共享式同步状态的获取和释放</title>
      <link href="/acquisition-and-release-of-shared-synchronization-status-aqs/"/>
      <url>/acquisition-and-release-of-shared-synchronization-status-aqs/</url>
      
        <content type="html"><![CDATA[<p>前面LZ介绍了独占式同步状态的获取和释放，这一章LZ将介绍共享式同步状态的获取和释放。相比于独占式同一时刻只能有一个线程获取到同步状态，共享式在同一时刻可以有多个线程获取到同步状态。例如读写文件，读文件的时候可以多个线程同时访问，但是写文件的时候，同一时刻只能有一个线程进行写操作，其它线程将被阻塞。</p><h3 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h3><p>   AQS提供了<code>acquireShared(int arg)</code>模板方法来共享的获取同步状态，方法定义如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 获取同步状态失败，执行下面方法。</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从上面方法的定义中可以看出，方法首先调用了<code>tryAcquireShared(arg)</code>方法尝试去获取同步状态，<code>tryAcquireShared(arg)</code>方法的返回值是一个int值，当返回值大于等于0时，表示获取同步状态成功，否则获取同步状态失败。如果尝试获取同步状态失败，则调用<code>doAcquireShared(arg)</code>自旋方法。自旋式获取同步状态方法的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 共享式节点,并添加到CHL尾部</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 判断前驱节点是否是头节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取同步状态</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 获取同步状态成功</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面自旋式获取同步状态的定义中，可以看到只有是当前节点的前驱节点是头节点时，才尝试获取同步状态，当返回值大于等于0时，表示获取到了同步状态并从自旋的过程中退出。<code>acquireShared(int arg)</code>方法对中断不敏感，与独占式相似AQS也提供了响应中断的共享式获取同步状态方法<code>acquireSharedInterruptibly(int arg)</code>和超时等待共享获取同步状态方法<code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>。这些方法的逻辑实现和独占式差不多，在这里就不在赘述了。</p><h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h3><p>与独占式一样，共享式也需要释放获取的同步状态。共享式释放同步状态的方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法在释放同步状态后，将会唤醒后续处于等待状态的节点。因为存在多个线程同时释放同步状态，因此<code>tryReleaseShared(arg)</code>方法必须保证线程安全，一般是通过循环和CAS来完成的。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS之独占式同步状态的获取和释放</title>
      <link href="/acquisition-and-release-of-exclusive-synchronization-status-aqs/"/>
      <url>/acquisition-and-release-of-exclusive-synchronization-status-aqs/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章LZ分析了AQS中的同步队列，这一章LZ将分析AQS中独占式获取同步状态和独占使释放同步状态。AQS提供提供的独占式获取同步状态和独占使释放同步状态的模板方法有：</p><ol><li>acquire(int arg);</li><li>acquireInterruptibly(int arg)</li><li>tryAcquireNanos(int arg, long nanosTimeout)</li><li>release(int arg)</li><li>tryRelease(int arg)</li></ol><p>今天LZ将详细的介绍这几个模板方法的使用。</p><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p><code>acquire(int args)</code>方法的作用是独占式的获取同步状态，该方法对中断不敏感，也就是说当线程获取同步状态失败后进入到CHL中，后续对线程进行中断时，线程不会从CHL中移除。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">         selfInterrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述代码中主要完成了同步状态的获取、节点构建、加入到CHL和自旋等待的工作，源码分析如下：</p><ul><li><code>tryAcquire(arg)</code>：尝试去获取同步状态，如果获取成功返回true,否则返回false。该方法是自定义同步器自己实现的方法，并且一定要保证线程安全。</li><li><code>addWaiter(Node.EXCLUSIVE)</code>：以独占的模式创建节点，并将节点添加到CHL的尾部。</li><li><code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>：以死循环的方式获取同步状态。</li></ul><p>因为tryAcquire(arg)方法需要自定义同步器自己实现，因此我们先来分享下addWaiter(Node.EXCLUSIVE)方法和acquireQueued(final Node node, int arg)方法，addWaiter方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 尝试快速在尾部添加节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 当CHL队列为空的时候，构建一个空节点作为头结点</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将node 节点添加到CHL尾部</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 死循环获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 只有当节点的前驱节点是同步器中的head时,才有机会获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的方法通过使用<code>compareAndSetTail(pred, node)</code>方法来确保节点能够被线程安全的添加到CHL尾部。在这里线程安全的添加到CHL是很重要的，如果不是线程安全的向CHL中添加节点，那么在一个线程获取到同步状态后，其它线程因为获取同步状态失败而并发的向CHL中添加节点时，CHL就不能保证数据的正确性了。<br><code>acquireQueued(final Node node, int arg)</code>方法可以看出当前线程是“死循环”的尝试获取同步状态，并且只有首节点才能获取同步状态。如果当前线程不是首节点则调用<code>shouldParkAfterFailedAcquire(p, node)</code>方法，如果该方法返回true,则线程进入阻塞状态，直到线程被唤醒才会继续运行。我们来看下<code>shouldParkAfterFailedAcquire(p, node)</code>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前节点前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果前驱节点的状态值为-1，则返回true。表示当前node节点中的线程直接进入等待状态</span></span><br><span class="line"><span class="comment">     * 前面提到过 Node.SIGNAL的意思是当前驱节点释放同步状态后需要唤醒当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ws ==  Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ws &gt; 0 时，为Node.CANCLE，这个值表示当前节点因为中断或者取消，需要从CHL队列</span></span><br><span class="line"><span class="comment">    * 中移除，即将node的前面所有被标记为CANCLE状态的节点从CHL中移除</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// CAS方式更新前驱节点的状态值为SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，<code>acquire(arg)</code>方法执行完毕，之后我们来看下acquire(arg)方法的整个流程：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/acquire%E6%96%B9%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B.png"  alt="acquire方法的流程"></p><h3 id="acquireInterruptibly"><a href="#acquireInterruptibly" class="headerlink" title="acquireInterruptibly"></a>acquireInterruptibly</h3><p><code>acquireInterruptibly(int arg)</code>从命名是可以看出相比于<code>acquire(ing arg)</code>方法，该方法是响应中断的。也就是说当线程在CHL中自旋的获取同步状态时，如果线程被中断了，会立刻响应中断并抛出InterruptedException异常。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，当调用<code>acquireInterruptibly(int arg)</code>方法时，会先判断线程是否被中断，如果中断了则抛出InterruptedException异常，否则调用<code>tryAcquire(arg)</code>方法来获取同步状态，如果获取同步状态失败，则调用<code>doAcquireInterruptibly(arg)</code>方法。我们来看下<code>doAcquireInterruptibly(arg)</code>方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 以独占模式构建节点并添加到CHL尾部</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 判断前驱节点是否为头结点,如果是，则尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//将node节点设置为head</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现<code>doAcquireInterruptibly(ing arg)</code>方法和<code>acquire(int arg)</code>方法实现的功能完全一致，它们差别在于：</p><ul><li><code>doAcquireInterruptibly(ing arg)</code>方法在声明时抛出了异常；</li><li>在是否需要中断时直接抛出中断异常，而不是返回中断标志。</li></ul><h3 id="tryAcquireNanos"><a href="#tryAcquireNanos" class="headerlink" title="tryAcquireNanos"></a>tryAcquireNanos</h3><p><code>tryAcquireNanos</code>超时的获取同步状态，其方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，首先判断线程是否被中断，如果中断了就抛出InterruptedException异常，否则获取同步状态，如果获取同步状态失败则调用 <code>doAcquireNanos(arg, nanosTimeout)</code>方法。我们来看下 <code>doAcquireNanos(arg, nanosTimeout)</code>方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span> L)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 独占式构建节点并添加到CHL尾部</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 自旋获取同步状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 当前节点的前驱节点是头结点并且获取同步状态成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点设置为头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算需要睡眠的时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 如果已经超时则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span> L)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果没有超时，则等待nanosTimeout纳秒</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 判断线程是否被中断    </span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到在<code>doAcquireNanos(int arg, long nanosTimeout)</code>方法中，首先判断超时时间是否小于等于0，如果小于等于0则返回false。如果超时时间大于0则计算出截止时间<code>（final long deadline = System.nanoTime() + nanosTimeout;）</code>如果当前节点不是头结点获取获取同步状态失败，则需要计算出睡眠时间<code>（nanosTimeout = deadline - System.nanoTime();）</code>，如果睡眠时间小于等于0，则返回false，否则如果超时时间大于spinForTimeoutThreshold（1000L），则睡眠nanosTimeout纳秒，否则进入自旋。这里spinForTimeoutThreshold是AQS定义的一个常量，这里为什么要定义一个超时阈值呢？这是因为在线程从睡眠（TIME_WAITINT）状态切换到RUNNING状态会导致上下文的切换，如果超时时间太短，会导致频繁的上下文切换而浪费资源。整个超时控制的流程如下：<br><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6%E7%9A%84%E6%B5%81%E7%A8%8B.png"  alt="超时控制的流程"></p><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>当前线程在获取到同步状态并且执行完相关逻辑后，需要释放同步状态，并唤醒后继节点获取同步状态。<code>release(int arg)</code>方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryRelease(arg)方法是自定义同步器实现的方法，如果释放同步状态成功，则通过unparkSuccessor(h)方法来唤醒后续。具体unparkSuccessor方法的使用和定义LZ在后面再介绍。</p><p>最后总结下独占式获取同步状态和释放的流程：</p><p>在多线程同时获取同步状态时，同步器会维护一个同步队列。线程在访问acquire(int arg)方法时会调用tryAcquire(int arg)方法，tryAcquire(int arg)方法是自定义同步器自己实现的一个<strong>线程安全的方法</strong> ，所有只能有一个线程能够获取到同步状态，其余获取同步状态失败的线程将被包装成节点加入到同步队列中。并且同步队列中的所有节点全部是自旋的方式判断当前节点的前驱节点是否是首节点，如果是首节点则不停的获取同步状态，如果获取同步状态成功，则退出同步队列，当线程执行完相应逻辑后，会释放同步状态，释放后会唤醒其后继节点。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS之CHL同步队列分析</title>
      <link href="/aqs-chl-synchronization-queue-analysis/"/>
      <url>/aqs-chl-synchronization-queue-analysis/</url>
      
        <content type="html"><![CDATA[<h3 id="AQS之CHL同步队列分析"><a href="#AQS之CHL同步队列分析" class="headerlink" title="AQS之CHL同步队列分析"></a>AQS之CHL同步队列分析</h3><p>上一章LZ在分析AQS的工作原理时，使用了一张图来解释了AQS独占模式的工作原理，在图中LZ画了一个CHL同步队列，这个CHL同步队列就是AQS内部维护的一个FIFO双向队列。AQS依赖这个双向队列来完成同步状态的管理。如果当前线程获取同步状态失败，AQS将会将当前线程以及等待状态信息构建成一个节点（Node）并将其加入到同步队列中，同时会阻塞当前线程。当同步状态释放时，会把首节点中的线程唤醒，使其再次获取同步状态。<br>在CHL中节点（Node）用来保存获取同步状态失败的线程（thread）、等待状态（waitStatus）、前驱节点（prev）和后继节点（next）。<br>AQS中内部维护的Node节点源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 表示节点正在共享模式中等待 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** 表示节点正在独占模式下等待 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 表示线程已经被取消 </span></span><br><span class="line"><span class="comment">    * 同步队列中的线程因为超时或中断，需要从同步队列中取消。被取消的节点将不会有任何改变</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后</span></span><br><span class="line"><span class="comment">    * 继节点，使后继节点的线程得以运行 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">      * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()方法 </span></span><br><span class="line"><span class="comment">     *  后，该节点将会将等待队列中转移到同步队列中，加入到对同步状态的获取 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一次共享模式同步状态获取将会无条件的被传播下去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   等待状态，仅接受如下状态中的一个值：</span></span><br><span class="line"><span class="comment">     *   SIGNAL:  -1</span></span><br><span class="line"><span class="comment">     *   CANCELLED:   1</span></span><br><span class="line"><span class="comment">     *   CONDITION:   -2</span></span><br><span class="line"><span class="comment">     *   PROPAGATE:   -3</span></span><br><span class="line"><span class="comment">     *   0:  初始化的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 对于正常的同步节点，它的初始化值为0，对于条件节点它的初始化的值是CONDITION。它使用</span></span><br><span class="line"><span class="comment">     * CAS进行修改。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  前驱节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取同步状态的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待队列中的后继节点。如果当前节点是共享的，那么这个字段是一个SHARED常量，也就是说</span></span><br><span class="line"><span class="comment">     * 节点类型（独占和共享）和等待队列中的后继节点公用同一个字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果节点在共享模式下等待则返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取前驱节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123; </span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; </span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点（Node）是构成CHL的基础，同步器拥有首节点（head）和尾节点（tail）,没有成功获取同步状态的线程会构建成一个节点并加入到同步器的尾部。CHL的基本结构如下：<br><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/CHL%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"  alt="CHL基本结构"></p><p>图中：<strong>compareAndSetTail(Node expect,Node update)</strong> 方法是同步器为了保证线程安全的加入到CHL的尾部提供的一个基于CAS算法的方法。</p><h3 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h3><p>从数据结构上出发，入列是比较简单的，无非就是当前队列中的尾节点指向新节点，新节点的prev指向队列中的尾节点，然后将同步器的tail节点指向新节点。在AQS中入列的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为当前线程和给定的模式创建节点并计入到同步队列中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 快速尝试添加尾节点，如果失败则调用enq(Node node)方法设置尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 判断tail节点是否为空，不为空则添加节点到队列中</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS设置尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入节点到队列中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node's predecessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 死循环 直到将节点插入到队列中为止</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 如果队列为空，则首先添加一个空节点到队列中</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// tail 不为空，则CAS设置尾节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码中我们可以看到，在将节点添加到CHL尾部的时候，使用了一个CAS方法（<code>compareAndSetTail(pred, node)</code>）,这里使用CAS的原因是防止在并发添加尾节点的时候出现线程不安全的问题（即有可能出现遗漏节点的情况）。</p><p>CHL入列的过程如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/CHL%E5%85%A5%E5%88%97%E7%9A%84%E8%BF%87%E7%A8%8B.png"  alt="CHL入列的过程"></p><h3 id="出列"><a href="#出列" class="headerlink" title="出列"></a>出列</h3><p>同步队列遵循FIFO规范，首节点的线程在释放同步状态后，将会唤醒后继节点的线程，并且后继节点的线程在获取到同步状态后将会将自己设置为首节点。因为设置首节点是通过获取同步状态成功的线程来完成的，因此设置头结点的方法并不需要使用CAS来保证，因为只有一个线程能获取到同步状态。CHL出列的过程如下：<br><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/CHL%E5%87%BA%E5%88%97%E7%9A%84%E8%BF%87%E7%A8%8B.png"  alt="CHL出列的过程"></p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS之工作原理</title>
      <link href="/how-aqs-works/"/>
      <url>/how-aqs-works/</url>
      
        <content type="html"><![CDATA[<h3 id="AQS之工作原理"><a href="#AQS之工作原理" class="headerlink" title="AQS之工作原理"></a>AQS之工作原理</h3><p>前面一章LZ简单的介绍了下AbstractQueuedSynchronizer（AQS）以及AQS中提供的一些模板方法的功能和作用，这一章LZ将用一个简单的实例来介绍下AQS中独占锁的工作原理。独占锁顾名思义就是在同一时刻只能有一个线程能获取到锁，而其它需要获取这把锁的线程将进入到同步队列中等待获取到了锁的线程释放这把锁，只有获取锁的线程释放了锁，同步队列中的线程才能获取锁。LZ可能描述的有些绕，画图来解释下这段话的意思：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/AQS%E5%8E%9F%E7%90%86.png"  alt="AQS原理"></p><p>这个图则清晰的说明了AQS中独占锁的的基本原理，下面LZ将用一段简单的代码来看看AQS中独占锁的工作原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExclusiveDemo</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// 静态内部类，自定义同步器    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;        </span><br><span class="line">        <span class="comment">// 是否处于独占状态        </span></span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getState() == <span class="number">1</span>;        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 当状态为0时，获取锁        </span></span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;           </span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;                </span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());                </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;            </span><br><span class="line">            &#125;           </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;      </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 释放锁，将状态设置为0        </span></span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;           </span><br><span class="line">            <span class="keyword">if</span>(getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();                       </span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);            </span><br><span class="line">            setState(<span class="number">0</span>);            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 返回一个Condition,没给Condition都包含了一个Condition队列        </span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        sync.acquire(<span class="number">1</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        </span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);    </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>,unit.toNanos(time));   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        sync.release(<span class="number">0</span>);   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，独占锁ExclusiveDemo是一个自定义的同步组件，它在同一时刻只允许一个线程占有锁。ExclusiveDemo定义了一个静态内部类，该内部类继承了同步器并实现了独占式获取和释放同步状态。在tryAcquire方法中，通过CAS方式设置同步器状态，如果设置成功，返回true，设置失败返回false。tryRelease(int arg)方法是将同步器状态设置为0。通过上面的示例，我么可以看到，当我们在使用ExclusiveDemo的时候，我们并没有直接和同步器打交道，而是通过调用ExclusiveDemo提供的方法。这一章LZ只是简单的介绍了下AQS是如何工作的，下一章LZ分析下AQS中CHL的工作原理。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS之简介</title>
      <link href="/introduction-to-aqs/"/>
      <url>/introduction-to-aqs/</url>
      
        <content type="html"><![CDATA[<p>队列同步器AbstractQueuedSynchronizer（以下简称AQS）是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量state来表示同步状态，通过内置一个FIFO队列来完成资源获取线程的排队工作。并发包的作者（Doug Lea）期望它能够实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。</p><p>同步器AbstractQueuedSynchronizer是一个抽象类，因此同步器的主要使用方式是继承。子类通过继承同步器并实现它的抽象方法来管理同步状态。在抽象方法的实现过程中，免不了对同步器的状态进行更新，因此同步器中提供了3个设置和修改同步状态的方法，它们分别是：</p><ol><li><code>getState()：</code> 获取当前同步器的状态。</li><li><code>setState(int newState)：</code> 设置当前同步器的状态</li><li><code>compareAndSetState(int expect, int update)：</code> 原子性的更新当前同步器的状态。如果当前同步器的状态值和期望值（expect）相等，则将同步器的状态值更新为update的值，否则不更新当前同步器状态值。</li></ol><p>子类推荐被定义为自定义同步器的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态的获取和释放的方法来供自定义同步组件的使用。同步器即可以支持独占模式获取同步器状态，也支持共享模式获取同步器状态，这样就可以实现不同类型的同步器组件。例如ReentrantLock、ReentrantReadWriteLock、Semaphore和CountDownLatch等等。同步器隐藏了大量的实现细节，简化了锁的实现方法，屏蔽了同步状态的管理，线程的排队、等待与唤醒等底层操作。</p><p>同步器主要提供了以下方法：</p><ul><li><code>getState()</code>：获取当前同步器状态</li><li><code>setState(int newState)</code>：设置当前同步器状态</li><li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置当前同步器状态，该方法能够保证设置状态的原子性。</li><li><code>tryAcquire(int arg)</code>：独占式获取同步状态，实现该方法需要查询当前同步器状态并判断同步器状态是否符合预期值，然后在进行CAS设置同步状态。</li><li><code>tryRelease(int arg)</code>：独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态。</li><li><code>tryAcquireShared(int arg)</code>：共享式获取同步状态，返回的值大于等于0，则表示获取成功，反之获取失败。</li><li><code>tryReleaseShared(int arg)</code>：共享式释放同步状态。</li><li><code>isHeldExclusively()</code>：同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程独占。</li><li><code>acquire(int arg)</code>：独占模式获取同步状态，忽略中断。如果当前线程获取同步状态成功，则由该方法返回，否则将进入同步队列等待，该方法将会调用重写的的tryAcquire(int arg)方法。</li><li><code>acquireInterruptibly(int arg)</code>：独占式获取同步状态，但是该方法响应中断。当前线程未获取到同步状态则进入同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException并返回。</li><li><code>tryAcquireNanos(int arg, long nanosTimeout)</code>：超时获取同步状态，如果当前线程在超时时间nanos内没有获取到同步状态，则返回false，反之返回true.</li><li><code>acquireShared(int arg)</code>：共享式获取同步状态，忽略响应中断。如果当前线程未获取到同步状态，将会进入同步队列中等待，与独占模式获取同步状态的主要区别在于同一时刻可以有多个线程获取到同步状态。</li><li><code>acquireSharedInterruptibly(int arg)</code>：与acquireShared(int arg)相同，区别在于该方法响应中断。</li><li><code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>：共享获取同步状态，增加超时限制。</li><li><code>release(int arg)</code>：独占式的释放同步状态，该方法会在释放同步状态之后将同步队列中第一个节点包含的线程唤醒。</li><li><code>releaseShared(int arg)</code>：共享式的释放同步状态。</li></ul><p>同步器提供的模板方法基本上分为3类：<strong>独占式</strong>获取与释放同步状态、<strong>共享式</strong>获取与释放状态以及查询同步队列中等待线程的情况。</p><p>只有掌握了同步器的工作原理才能更深入的理解JUC（并发包）中的其它组件，下一章LZ将用一个简单的例子来了解下同步器的工作原理。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DCL缺陷和优化</title>
      <link href="/dcl-defects-and-optimization/"/>
      <url>/dcl-defects-and-optimization/</url>
      
        <content type="html"><![CDATA[<h3 id="DCL的问题"><a href="#DCL的问题" class="headerlink" title="DCL的问题"></a>DCL的问题</h3><p>单例模式是我们经常用到的一种模式，但是要正确的书写和理解一个单例模式却没有那么简单，首先我们看看下面的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SignalTest instance  = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SignalTest</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SignalTest <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SignalTest();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码看似没有问题，但是有一个致命的缺陷，那就是这段代码是线程不安全的。在多线程中，如果多个线程同时执行<code>if(instance == null)</code>，那么将会得到多个不同的<code>instance</code>。我们将上面代码加锁优化，得到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SignalTest instance  = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SignalTest</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SignalTest <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SignalTest();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用synchronized修饰getInstance()方法，这样在多线程中虽然能够实现单例，但是synchronized会导致性能开销，如果多个线程频繁的调用getInstance()方法，将会导致程序的性能下降。为了解决性能问题，我们继续优化上述代码，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SignalTest instance  = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SignalTest</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SignalTest <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SignalTest<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SignalTest();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面代码所示，如果第一次检查instance不为null,则不需要执行下面的加锁和初始化操作，因此可以大幅度降低synchronized带来的性能开销。上面的代码看似很完美，但是也有一个致命的缺陷，那就是初始化对象并不是一个原子操作，<code>instance = new SignalTest();</code>可以分为以下3步完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">// 1:分配对象的内存空间</span></span><br><span class="line">ctorInstance(memory); <span class="comment">// 2:初始化对象</span></span><br><span class="line">instance = memory; <span class="comment">// 3: 设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure><p>上面3行代码中，2和3可能被重排序，如果2和3被重排序，那么上述DCL代码在多线程中执行的时序如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/DCL%E4%BB%A3%E7%A0%81%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E7%9A%84%E6%97%B6%E5%BA%8F.png"  alt="DCL代码在多线程中执行的时序"></p><p>从上图我们可以看到，当线程A执行到操作3之后，操作2之前时，这时候线程B首次判断instance是否为null,这个时候我们知道instance是不为空的，但是instance却根本不能使用，因为对象还没有被初始化。这就是DCL缺陷的所在。</p><h3 id="DCL解决方案"><a href="#DCL解决方案" class="headerlink" title="DCL解决方案"></a>DCL解决方案</h3><p>在知道了上面DCL的缺陷的根源之后，那我们就知道了应该如何来解决DCL的问题，我们有2种方案来解决。</p><ol><li>禁止2和3重排序</li><li>允许2和3进行重排序，但是不允许其它线程看到这个重排序</li></ol><p>下面，我们分别来介绍上面2种解决方案</p><h4 id="volatile解决方案"><a href="#volatile解决方案" class="headerlink" title="volatile解决方案"></a>volatile解决方案</h4><p>根据LZ前面的文章，我们知道想要禁止2和3重排序，只需要在instance变量前加volatile关键词修饰即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SignalTest instance  = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SignalTest</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SignalTest <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SignalTest<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SignalTest();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当声明对象的引用为volatile后，初始化对象的3行代码中2和3的重排序将会在多线程环境中被禁止。</p><h4 id="类初始化解决方案"><a href="#类初始化解决方案" class="headerlink" title="类初始化解决方案"></a>类初始化解决方案</h4><p>JVM在类初始化阶段，会执行类的初始化。在类初始化阶段，JVM会获取一个锁。这个锁可以同步多个线程对同一个类的初始化。基于这个特性，我们可以用静态方法的模式来正确的使用单例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactoryHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> InstanceFactory instanceFactory = <span class="keyword">new</span> InstanceFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InstanceFactory <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceFactoryHolder.instanceFactory; <span class="comment">// 这里导致InstanceFactoryHolder类初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这时候有多个线程同时访问getInstance()方法，这是某一个线程会导致InstanceFactoryHolder类的初始化，因此最终只会有一个线程执行new InstanceFactory()，因此无论new InstanceFactory()中是否存在排序，它对其它的线程不可见。其执行流程如下图所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/DCL%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"  alt="DCL类初始化解决方案"></p><h3 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h3><p>根据Java虚拟机规范，我们知道在以下几种情况下，类会被立即初始化。</p><ol><li>遇到new、getstatic、putstatic或者invokestatic这4条字节指令时，如果类没有被初始化过，则需要先触发其初始化。生成这4条指令的常用场景有：使用new关键词实例化对象的时候、设置或读取一个静态的时候以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有被初始化过，则需要先触发其初始化。</li><li>当初始化一个类时，如果发现其父类还没有被初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定执行一个主类，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、RER_invokeStatic的方法句柄时，并且这个方法句柄所对应的类没有被实例化，则需要先触发其初始化。</li></ol><p>Java语言规范规定，对于每个类或者接口C，都有唯一的初始化锁LC与之对应。从C到LC的映射，由JVM具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来保证这类已经被初始化过了。初始化C的过程如下：</p><ol><li>同步C的初始化锁LC。这个操作会导致当前线程一直等待，直到可以获取LC锁。</li><li>如果C的Class对象显示当前C的初始化是由其它线程正在进行的，那么当前线程就释放LC并进入阻塞状态，直到它知道初始化工作已经由其它线程完成，此时当前线程需要重试这一过程。</li><li>如果C的Class对象显示C的初始化正由当前线程进行，那么表明这是对初始化的递归操作。释放LC并正常返回。</li><li>如果C的Class对象显示Class已经初始化完成，那么就不需要做什么了，释放LC并正常返回。</li><li>如果C的Class对象显示它处于一个错误的状态，那就不可能再被初始化了。释放LC并抛出NoClassDefFoundError异常。</li><li>否则，记录下当先线程正在初始化C的Class对象，随后释放LC。根据属性出现在ClassField的顺序，利用ConstantValue属性来初始化C中的每个final static字段。</li><li>接下来，如果C是类而不是接口，并且它的父类SC还没有初始化，那么就在SC上面也递归的进行完整的初始化过程。</li><li>之后，通过查询C的定义加载器来判定C是否开启了断言机制。</li><li>执行C的类或接口的初始化。</li><li>如果正常执行了类或接口的初始化方法，那就获取LC，并把C的Class对象标记成已完成完全初始化，通知所有正在等待的线程，接着释放LC，正常的退出整个过程。</li><li>否则，类或接口的初始化方法就必定因为抛出了一个异常而中断退出。如果E不是Error或它的某个子类，那就以E为参数来创建一个新的ExceptionInInitializerError实例，并在之后的步骤中，用该实例来代替E。</li><li>获取LC，标记下C的Class对象有错误发生，通知所有正在等待的线程，释放LC，将E或上一步中具体错误对象作为此次意外中断的原因。</li></ol><p>结合上述C的初始化过程，我们可以看到InstanceFactory示例的执行时序图如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E5%BA%8F.png"  alt="类初始化时序"></p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMM之happens-before</title>
      <link href="/jmms-happensbefore/"/>
      <url>/jmms-happensbefore/</url>
      
        <content type="html"><![CDATA[<p>在JMM中有一个很重要的概念对于我们了解JMM有很大的帮助，那就是happens-before规则。happens-before规则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据。JSR-133S使用happens-before概念阐述了两个操作之间的内存可见性。在JMM中，如果一个操作的结果需要对另一个操作可见，那么这两个操作则存在happens-before关系。</p><p> 那什么是happens-before呢？在JSR-133中，happens-before关系定义如下：</p><ol><li>如果一个操作happens-before另一个操作，那么意味着第一个操作的结果对第二个操作可见，而且第一个操作的执行顺序将排在第二个操作的前面。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须按照happens-before关系指定的顺序来执行。如果重排序之后的结果，与按照happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）</li></ol><p>happens-before规则如下：</p><ol><li>程序顺序规则：一个线程中的每一个操作，happens-before于该线程中的任意后续操作。</li><li>监视器规则：对一个锁的解锁，happens-before与随后对这个锁的加锁。</li><li>volatile规则：对一个volatile变量的写，happens-before于任意后续对一个volatile变量的读。</li><li>传递性：如果A happens-before B，B happens-before C，那么A happens-before C。</li><li>线程启动规则：Thread对象的start()方法，happens-before于这个线程的任意后续操作。</li><li>线程终止规则：线程中的任意操作，happens-before于该线程的终止监测。我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li><li>线程中断操作：对线程interrupt()方法的调用，happens-before于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到线程是否有中断发生。</li><li>对象终结规则：一个对象的初始化完成，happens-before于这个对象的finalize()方法的开始。</li></ol><p>以上8条happens-before规则都比较简单，这里LZ只分析第3条volatile变量规则，分析如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/happens-before%E4%B9%8Bvolatile%E8%A7%84%E5%88%99.png"  alt="happens-before之volatile规则"></p><p>从上图中，我们看到存在4条happens-before关系，它们分别如下：</p><ul><li>1 happens-before 2 和 3 happens-before 4 是有由程序顺序性规则产生的。</li><li>2 happens-before 3 是由volatile规则产生的。上面提到过，一个volatile变量的读，总能看到之前对这个volatile变量的写入。</li><li>1 happens-before 4 是由传递性规则产生的。</li></ul><p>读到这里，可能很多同学会把happens-before理解为“时间上的先后顺序”，在这里LZ特别强调<strong>happens-hefore不能理解为“时间上的先后顺序”</strong>，下面LZ用一段代码解释写happens-before和“时间上的先后顺序”的不同，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是一组简单的setter/getter方法，现在假设现在有两个线程A和B，线程A先(这里指时间上的先执行)执行setA(10)，然后线程B访问同一个对象的getA()方法，那么此时线程B收到的返回值是多少呢？</p><p>答案是：<strong>不确定</strong></p><p>我们来一次分析下happens-before的各项原则：</p><ol><li>这里两个方法分别是在两个线程中被调用，不在一个线程中，这里程序顺序性就不适用了</li><li>代码中没有同步块，所有监视器规则也不适用</li><li>代码中变量a是一个普通变量，所以volatile规则也不适用</li><li>后面的线程启动、中断、终止和对象的终结和这里完全没有关系，因此这些规则也是不适用的</li><li>没有一条happens-before适用，因此传递性规则也不适用</li></ol><p>在这里，虽然线程A在时间上先于线程B执行，但是由于代码完全不适用happens-before规则，因此我们无法确定先B收到的值是多少。也就是说上面代码是线程不安全的。</p><p>对于上面代码，那我们如何修复线程不安全这个问题呢？这里，我们只要满足happens-before规则中2、3的任意一种规则就可以了。即要么把setter/getter方法定义为synchronized方法，要么在变量a上加volatile修饰符。</p><p>通过上面的例子，我们可以得出结论：一个操作“时间上的先发生”不代表这个操作会happens-before其它操作。那一个操作happens-before其它操作，是否就表示这个操作是“时间上先发生”的呢？答案也是<strong>否定的</strong>，我们来看看下面一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上面两个赋值操作在同一个线程中，根据程序顺序性规则，“int i = 1;”这个操作happens-before ”int m = 2;“这个操作，但是”int m = 2;“这个操作完全有可能被处理器先执行，这并不影响happens-before原则的正确性。因为这种重排序在JMM中是允许的。</p><p>最后我们得出的结论是：时间先后顺序与happens-before原则之间基本没有太大的关系，所以我们在衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以happens-before原则为准。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> happends-before </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入分析volatile实现原理</title>
      <link href="/volatile-implementation/"/>
      <url>/volatile-implementation/</url>
      
        <content type="html"><![CDATA[<p>在前面一文中我们深入的分享了synchronized的实现原理，也知道了synchronized是一把重量级的锁。在Java中还有一个关键词，那就是volatile。volatile是轻量级的synchronized，它在多线程中保证了变量的“可见性”。可见性的意思是当一个线程修改了一个变量的值后，另外的线程能够读取到这个变量修改后的值。volatile在Java语言规范中的定义如下：</p><blockquote><p>Java编程语言允许线程访问共享变量，为了确保共享变量能够被准确和一致性的更新，线程应该确保通过排他锁单独获取这个变量。</p></blockquote><p>这句话可能说的比较绕，我们先来看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程结束运行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        VolatileTest v = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(v);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        v.setFlag(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的运行结果：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/volatile%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"  alt="volatile测试结果"></p><p>可以看到尽管在代码中调用了v.setFlag(false)方法，线程也没有结束运行。这是因为在上面的代码中，实际上是有2个线程在运行，一个是main线程，一个是在main线程中创建的t1线程。因此我们可以看到在线程中的变量是互不可见的。  要理解线程中变量的可见性，我们需要先理解Java的内存模型。</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>在Java中，所有的实例域、静态变量和数组元素都存储在堆内存中，堆内存在线程之间是共享的。局部变量，方法定义参数和异常数量参数是存放在Java虚拟机栈上面的。Java虚拟机栈是线程私有的因此不会在线程之间共享，它们不存在内存可见性的问题，也不受内存模型的影响。</p><p>Java内存模型（Java Memory Model 简称 JMM），决定一个一个线程对共享变量的写入何时对其它线程可见。JMM定义了线程和主内存之间的抽象关系：</p><blockquote><p>线程之间共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程共享变量的副本。本地内存是JMM的一个抽象概念，并不真实的存在。它涵盖了缓存、寄存器以及其他的硬件和编译优化。</p></blockquote><p>Java内存模型的抽象概念图如下所示：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"  alt="Java内存模型"></p><p>看完了Java内存模型的概念，我们再来看看内存模型中主内存是如何和线程本地内存之间交互的。</p><h3 id="主内存和本地内存间的交互"><a href="#主内存和本地内存间的交互" class="headerlink" title="主内存和本地内存间的交互"></a>主内存和本地内存间的交互</h3><p>主内存和本地内存的交互即一个变量是如何从主内存中拷贝到本地内存又是如何从本地内存中回写到主内存中的实现，Java内存模型提供了8种操作来完成主内存和本地内存之间的交互。它们分别如下：</p><ul><li><code>lock（锁定）</code>：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li><code>unlock（解锁）</code>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才能被其它线程锁定。</li><li><code>read（读取）</code>：作用于主内存的变量，它把一个变量从主内存传输到线程的本地内存中，以便随后的load动作使用。</li><li><code>load（载入）</code>：作用于本地内存的变量，它把read操作从主内存中得到的变量值放入本地内存的变量副本中。</li><li><code>use（使用）</code>：作用于本地内存的变量，它把本地内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作。</li><li><code>assign（赋值）</code>：作用于本地内存的变量，它把一个从执行引擎接收到的变量赋予给本地内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。</li><li><code>store（存储）</code>：作用于本地内存的变量，它把本地内存中的变量的值传递给主内存中，以便后面的write操作使用。</li><li><code>write（写入）</code>：作用于主内存的变量，它把store操作从本地内存中得到的变量的值放入主内存的变量中。</li></ul><p>从上面8种操作中，我们可以看出，当一个变量从主内存复制到线程的本地内存中时，需要顺序的执行read和load操作，当一个变量从本地内存同步到主内存中时，需要顺序的执行store和write操作。Java内存模型只要求上述的2组操作是顺序的执行的，但并不要求连续执行。比如对主内存中的变量a 和 b 进行访问时，有可能出现的顺序是read a read b load b load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足以下规则：</p><ul><li><p>不允许read和load，store和write操作单独出现，这2组操作必须是成对的。</p></li><li><p>不允许一个线程丢弃它最近的assign操作。即变量在线程的本地内存中改变后必须同步到主内存中。</p></li><li><p>不允许一个线程无原因的把数据从线程的本地内存同步到主内存中。</p></li><li><p>不允许线程的本地内存中使用一个未被初始化的变量。</p></li><li><p>一个变量在同一时刻只允许一个线程对其进行lock操作，但是一个线程可以对一个变量进行多次的lock操作，当线程对同一变量进行了多次lock操作后需要进行同样次数的unlock操作才能将变量释放。</p></li><li><p>如果一个变量执行了lock操作，则会清空本地内存中变量的拷贝，当需要使用这个变量时需要重新执行read和load操作。</p></li><li><p>如果一个变量没有执行lock操作，那么就不能对这个变量执行unlock操作，同样也不允许unlock一个被其它线程执行了lock操作的变量。也就是说lock 和unlock操作是成对出现的并且是在同一个线程中。</p></li><li><p>对一个变量执行unlock操作之前，必须将这个变量的值同步到主内存中去。</p></li></ul><h3 id="volatile-内存语义之可见性"><a href="#volatile-内存语义之可见性" class="headerlink" title="volatile 内存语义之可见性"></a>volatile 内存语义之可见性</h3><p>大概了解了Java的内存模型后，我们再看上面的代码结果我们将很好理解为什么是这样子的了。首先主内存中flag的值是false，在t1线程执行时，依次执行的操作有read、load和use操作，这个时候t1线程的本地内存中flag的值也是false，线程会一直执行。当main线程调用v.setFlag(true)方法时，main线程中的falg被赋值成了true,因为使用了assign操作，因此main线程中本地内存的flag值将同步到主内存中去，这时主内存中的flag的值为true。但是t1线程没有再次执行read 和 load操作，因此t1线程中flag的值仍然是false，所以t1线程不会终止运行。想要正确的停止t1线程，只需要在flag变量前加上volatile修饰符即可，因为volatile保证了变量的可见性。既然volatile在各个线程中是一致的，那么volatile是否能够保证在并发情况下的安全呢？答案是否定的，因为volatile不能保证变量的原子性。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        VolatileTest2 v2 = <span class="keyword">new</span> VolatileTest2();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(v2).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(v2.getI());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码启动了100线程，每个线程都对i变量进行1000次的自增操作，如果这段代码能够正确的运行，那么正确的结果应该是100000，但是实际并非如此，实际运行的结果是少于100000的，这是因为volatile不能保证i++这个操作的原子性。我们用javap反编译这段代码，截取run()方法的代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1</span><br><span class="line">        <span class="number">2</span>: iload_1</span><br><span class="line">        <span class="number">3</span>: sipush        <span class="number">1000</span></span><br><span class="line">        <span class="number">6</span>: if_icmpge     <span class="number">25</span></span><br><span class="line">        <span class="number">9</span>: aload_0</span><br><span class="line">       <span class="number">10</span>: dup</span><br><span class="line">       11: getfield      #2                  // Field i:I</span><br><span class="line">       <span class="number">14</span>: iconst_1</span><br><span class="line">       <span class="number">15</span>: iadd</span><br><span class="line">       16: putfield      #2                  // Field i:I</span><br><span class="line">       <span class="number">19</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">       <span class="number">22</span>: goto          <span class="number">2</span></span><br><span class="line">       <span class="number">25</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>我们发现i++虽然只有一行代码，但是在Class文件中却是由4条字节码指令组成的。从上面字节码片段，我们很容易分析出并发失败的原因：当getfield指令把变量i的值取到操作栈时，volatile关键字保证了i的值在此时的正确性，但是在执行iconst_1和iadd指令时，i的值可能已经被其它的线程改变，此时再执行putfield指令时，就会把一个过期的值回写到主内存中去了。由于volatile只保证了变量的可见性，在不符合以下规则的场景中，我们仍然需要使用锁来保证并发的正确性。</p><ul><li>运算结果结果并不依赖变量的当前值，或者能够确保只有单一的线程修改了变量的值</li><li>变量不需要与其他的状态变量共同参与不变约束</li></ul><h3 id="volatile-内存语义之禁止重排序"><a href="#volatile-内存语义之禁止重排序" class="headerlink" title="volatile 内存语义之禁止重排序"></a>volatile 内存语义之禁止重排序</h3><p>在介绍volatile的禁止重排序之前，我们先来了解下什么是重排序。重排序是指编译器和处理器为了优化程序性能而对指令进行重新排序的一种手段。那么重排序有哪些规则呢？不可能任何代码都可以重排序，如果是这样的话，那么在单线程中，我们将不能得到明确的知道运行的结果。重排序规则如下：</p><ul><li>具有数据依赖性操作不能重排序，数据依赖性是指两个操作访问同一个变量，如果一个操作是写操作，那么这两个操作就存在数据依赖性。</li><li>as-if-serial语义，as-if-serial语义的意思是，不管怎么重排序，单线程的程序执行结果是不会改变的。</li></ul><p>既然volatile禁止重排序，那是不是重排序对多线程有影响呢？我们先来看下面的代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;                 <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;           <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;               <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> i = a*a;        <span class="comment">// 4</span></span><br><span class="line">            System.out.println(<span class="string">"i的值为："</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时有2个线程A和B，线程A先执行write()方法，虽有B执行read()方法，在B线程执行到第4步时，i的结果能正确得到吗？结论是 <strong>不一定</strong>  ，因为步骤1和2没有数据依赖关系，因此编译器和处理器可能对这2个操作进行重排序。同样步骤3和4也没有数据依赖关系，编译器和处理器也可以对这个2个操作进行重排序，我们来看看这两种重排序带来的效果：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E7%BA%BF%E7%A8%8B%E9%87%8D%E6%8E%92%E5%BA%8F.png"  alt="线程重排序"></p><p>从上面图片，这2组重排序都会破坏多线程的运行结果。了解了重排序的概念和知道了重排序对多线程的影响后，我们知道了volatile为什么需要禁止重排序，那JMM到底是如何实现volatile禁止重排序的呢？下面我们就来探讨下JMM是如何实现volatile禁止重排序的。</p><p>前面提到过，重排序分为编译器重排序和处理器重排序，为了实现volatile内存语义，JMM分别对这两种重排序进行了限制。下图是JMM对编译器重排序指定的volatile规则：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/volatile%E8%A7%84%E5%88%99.png"  alt="volatile规则"></p><p>从上面图中我们可以分析出：</p><ul><li><p>当第一个操作为volatile读时，无能第二个操作是什么，都不允许重排序。这个规则确保了volatile读之后的操作不能重排序到volatile读之前。</p></li><li><p>当第二个操作为volatile写时，无论第一个操作是什么，都不允许重排序。这个规则确保了volatile写之前的操作不能重排序到volatile写之后。</p></li><li><p>当第一个操作是volatile写，第二个操作是volatile读时，不允许重排序。</p><p>为了实现volatile内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型处理器的重排序，在JMM中，内存屏障的插入策略如下：</p></li><li><p>在每个volatile写操作之前插入一个StoreStore屏障</p></li><li><p>在每个volatile写操作之后插入一个StoreLoad屏障</p></li><li><p>在每个volatile读操作之后插入一个LoadLoad屏障</p></li><li><p>在每个volatile读操作之后插入一个LoadStore屏障</p></li></ul><p>StoreStore屏障可以保证在volatile写之前，前面所有的普通读写操作同步到主内存中</p><p>StoreLoad屏障可以保证防止前面的volatile写和后面有可能出现的volatile读/写进行重排序</p><p>LoadLoad屏障可以保证防止下面的普通读操作和上面的volatile读进行重排序</p><p>LoadStore屏障可以保存防止下面的普通写操作和上面的volatile读进行重排序</p><p>上面的内存屏障策略可以保证任何程序都能得到正确的volatile内存语义。我们以下面代码来分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;                 <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;           <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;               <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> i = a*a;        <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%AD%96%E7%95%A5%E5%88%86%E6%9E%90%E4%B8%80.png"  alt="内存屏障策略分析一"></p><p>通过上面的示例我们分析了volatile指令的内存屏蔽策略，但是这种内存屏障的插入策略是非常保守的，在实际执行时，只要不改变volatile写/读的内存语义，编译器可以根据具体情况来省略不必要的屏障。如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileBarrierExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> v2 = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = v1; <span class="comment">// 第一个volatile读</span></span><br><span class="line"><span class="keyword">int</span> j = v2; <span class="comment">// 第二个volatile读</span></span><br><span class="line">a = i + j; <span class="comment">// 普通写</span></span><br><span class="line">v1 = i + <span class="number">1</span>; <span class="comment">// 第一个volatile写</span></span><br><span class="line">v2 = j * <span class="number">2</span>; <span class="comment">// 第二个 volatile写</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，编译器在生成字节码时，可能做了如下优化</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%AD%96%E7%95%A5%E5%88%86%E6%9E%90%E4%BA%8C.png"  alt="内存屏障策略分析二"></p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMM之重排序</title>
      <link href="/jmm-reordering/"/>
      <url>/jmm-reordering/</url>
      
        <content type="html"><![CDATA[<h3 id="重排序定义"><a href="#重排序定义" class="headerlink" title="重排序定义"></a>重排序定义</h3><p>在前面我们提到过，重排序是编译器和处理器为了优化程序性能而对指令序列重新排序的一种手段。但是我们也知道代码不可能毫无原则的进行重排序，如果是毫无原则的进行重排序，那么我们的代码将无法获得预期的结果。因此重排序必须满足如下原则：</p><blockquote><ol><li>在单线程中不改变运行结果</li><li>操作不具备数据依赖性</li></ol></blockquote><p>那这两条原则如何理解么，我们先来看看下面的定义</p><h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>数据依赖性的意思是，如果两个操作访问同一个变量，并且其中一个操作是写操作，那么这两个操作就具备数据依赖性。</p><h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p> as-if-serial语义的意思是，不管如何重排序，在单线程中，程序的执行结果不能被改变。编译器、处理器和runtime都必须遵守as-if-serial语义。注意：as-if-serial只对单线程有效，对多线程无效。</p><p>了解了数据依赖性和as-if-serial后，我们看看如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;      <span class="comment">// A</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;      <span class="comment">// B </span></span><br><span class="line"><span class="keyword">int</span> c = a * b;  <span class="comment">// C</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们根据数据依赖性可以分析出，A和C具备数据依赖性，B和C具备数据依赖性，A和B之前不存在数据依赖性关系，因此编译器和处理器在进行重排序时，A和B可以进行重排序，但是A和C，以及B和C是不能进行重排序的。因为尽管A和B进行了重排序，但是他们不影响程序在单线程中运行的结果。</p><p>在这里，我们联想前面讲到过的happens-before，可以看出上面代码存在3个happens-before关系。它们分别是：</p><ol><li>A happens-before B</li><li>B happens-before C</li><li>A happens-before C</li></ol><p>在这里LZ再次强调，<strong>happens-before与时间上的先后完全没有关系</strong>，happens-before仅仅要求，前一个操作的结果对后一个操作可见。在这里操作A的结果不需要对B可见，重排序操作A和操作B的结果与按照A happens-before B 的执行结果一致。在这种情况下JMM认为这种重排序并不非法，JMM允许这种重排序。</p><h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><p> 在了解了重排序的概念和数据依赖性以及as-if-serial的定义后，我们知道重排序在单线程中是没有影响的，那么重排序对多线程是否有影响呢？我们首先来看看下面的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123; <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">int</span> i = a * a; <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设现在有A和B两个线程，此时A线程执行write()方法，B线程执行reader()方法，那么在线程B在执行操作4时，能否获取到a=1呢？答案是不一定。</p><p>由于操作1 和操作2没有数据依赖性，因此编译器和处理器能够对这2个操作进行重排序，当操作1和操作2进行重排序时，此时程序的执行时序图是这样子的</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E9%87%8D%E6%8E%92%E5%BA%8F%E5%88%86%E6%9E%90%E4%B8%80.png"  alt="重排序分析一"></p><p>如上图所示，操作1和操作2进行了重排序。程序在执行时，线程A首先写标记变量flag，随后线程B读取这变量，由于条件判断为真，线程B将读取变量a,此时变量a还没有被线程A写入，在这里多线程程序的语义被重排序破坏掉了。</p><p>同样，操作3和操作4也可以进行重排序，但是操作3和操作4存在控制依赖的关系，即当操作3为真时，操作4才可以执行。当代码中存在控制依赖关系时，会影响指令序列执行的并行度。为此，编译器和处理器采用<strong>猜测执行</strong>来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前计算a*a，然后把计算的结果保存到重排序缓存中，当操作3的结果为真时，就把该计算结果写入变量i中。</p><p>通过上面的分析，我可以得出结论：<strong>重排序对单线程的执行结果没有影响，但是在多线程中，重排序可能会改变程序执行的结果</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入分析synchronized实现原理</title>
      <link href="/synchronized-implementation-principle/"/>
      <url>/synchronized-implementation-principle/</url>
      
        <content type="html"><![CDATA[<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>synchronized可以保证在多线程运行中，同一时刻只有一个方法或者代码块被执行，它还可以保证共享变量的可见性和原子性</p><p>在Java中每个对象都可以作为锁，这是synchronized实现同步的基础。具体的表现为以下3种形式：</p><ol><li>普通同步方法，锁是当前实例对象；</li><li>静态同步方法，锁是当前类的Class对象；</li><li>同步方法块，锁是synchronized括号中配置的对象。</li></ol><p>当一个线程试图访问同步代码块时，它必须先获取到锁，当同步代码块执行完毕或抛出异常时，必须释放锁。那么它是如何实现这一机制的呢？我们先来看一个简单的synchronized的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用javap工具查看生成的class文件信息分析synchronized，下面是部分信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> com.zzw.juc.sync.SyncDemo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/zzw/juc/sync/SyncDemo;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_synchronized</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/zzw/juc/sync/SyncDemo;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter</span><br><span class="line">         <span class="number">4</span>: aload_1</span><br><span class="line">         <span class="number">5</span>: monitorexit</span><br><span class="line">         <span class="number">6</span>: goto          <span class="number">14</span></span><br><span class="line">         <span class="number">9</span>: astore_2</span><br><span class="line">        <span class="number">10</span>: aload_1</span><br><span class="line">        <span class="number">11</span>: monitorexit</span><br><span class="line">        <span class="number">12</span>: aload_2</span><br><span class="line">        <span class="number">13</span>: athrow</span><br><span class="line">        <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">4</span>     <span class="number">6</span>     <span class="number">9</span>   any</span><br><span class="line">             <span class="number">9</span>    <span class="number">12</span>     <span class="number">9</span>   any</span><br></pre></td></tr></table></figure><p>从上面利用javap工具生成的信息我们可以看到同步方法是利用ACC_synchronized这个修饰符来实现的，同步代码块是利用monitorenter和monitorexit这2个指令来实现的。</p><ul><li><strong>同步代码块</strong>：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</li><li><strong>同步方法</strong>：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在JVM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass作为锁对象</li></ul><p>在继续分析synchronized之前，我们需要理解2个非常重要的概念：Java对象头和Monitor</p><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>synchronized用的锁是存放在Java对象头里面的。那么什么是对象头呢？在Hotspot虚拟机中，对象头包含2个部分：标记字段（Mark Word)和类型指针（Kass point)。<br>其中Klass Point是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。这里我们将重点阐述Mark Word。</p><h5 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h5><p>Mark Word用于存储对象自身的运行时数据，如哈希码（Hash Code）、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等，这部分数据在32位和64位虚拟机中分别为32bit和64bit。一个对象头一般用2个机器码存储（在32位虚拟机中，一个机器码为4个字节即32bit）,但如果对象是数组类型，则虚拟机用3个机器码来存储对象头，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。<br>在32位虚拟机中，Java对象头的Mark Word的默认存储结构如下：</p><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit 是否是偏向锁</th><th align="left">2bit锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象的HashCode</td><td>对象分代年龄</td><td>0</td><td align="left">01</td></tr></tbody></table><p>在程序运行期间，对象头中锁表标志位会发生改变。Mark Word可能发生的变化如下：<br><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/Mark_Word_32.png"  alt="Mark_Word_32"></p><p>在64位虚拟机中，Java对象头中Mark Work的长度是64位的,其结构如下：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/Mark_Word_64.png"  alt="Mark_Word_64"></p><p>介绍了Mark Word 下面我们来介绍下一个重要的概念Monitor。</p><h5 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h5><p>Monitor是操作系统提出来的一种高级原语，但其具体的实现模式，不同的编程语言都有可能不一样。Monitor 有一个重要特点那就是，同一个时刻，只有一个线程能进入到Monitor定义的临界区中，这使得Monitor能够达到互斥的效果。但仅仅有互斥的作用是不够的，无法进入Monitor临界区的线程，它们应该被阻塞，并且在必要的时候会被唤醒。显然，monitor 作为一个同步工具，也应该提供这样的机制。Monitor的机制如下图所示：<br><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/Monitor%E6%9C%BA%E5%88%B6.jpg"  alt="Monitor机制"></p><p>从上图中，我们来分析下Monitor的机制：<br>Mointor可以看做是一个特殊的房间（这个房间就是我们在Java线程中定义的临界区），Monitor在同一时间，保证只能有一个线程进入到这个房间，进入房间即表示持有Monitor，退出房间即表示释放Monitor。<br>当一个线程需要访问临界区中的数据（即需要获取到对象的Monitro）时，他首先会在entry-set入口队列中排队等待（这里并不是真正的按照排队顺序），如果没有线程持有对象的Monitor,那么entry-set队列中的线程会和waite-set队列中被唤醒的线程进行竞争，选出一个线程来持有对象Monitor，执行受保护的代码段，执行完毕后释放Monitor，如果已经有线程持有对象的Monitor，那么需要等待其释放Monitor后再进行竞争。当一个线程拥有对象的Monitor后，这个时候如果调用了Object的wait方法，线程就释放了Monitor，进入wait-set队列，当Object的notify方法被执行后，wait-set中的线程就会被唤醒，然后在wait-set队列中被唤醒的线程和entry-set队列中的线程一起通过CPU调度来竞争对象的Monitor，最终只有一个线程能获取对象的Monitor。</p><p>需要注意的是：<br>当一个线程在wait-set中被唤醒后，并不一定会立刻获取Monitor，它需要和其他线程去竞争。如果一个线程是从wait-set队列中唤醒后，获取到的Monitor，它会去读取它自己保存的PC计数器中的地址，从它调用wait方法的地方开始执行。</p><h3 id="锁的优化和对比"><a href="#锁的优化和对比" class="headerlink" title="锁的优化和对比"></a>锁的优化和对比</h3><p>在JavaSE6为了对锁进行优化，引入了偏向锁和轻量级锁。在JavaSE6中锁一共有4种状态，它们从低到高依次是无状态锁、偏向锁、轻量级锁和重量级锁。锁的这几种状态会随着竞争而依次升级，但是锁是不能降级的。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁顾名思义就是偏向于第一个访问锁的线程，在运行的过程中同步锁只有一个线程访问，不存在多线程竞争的情况，则线程不会触发同步，这种情况下会给线程加一个偏向锁。偏向锁的引入就是为了让线程获取锁的代价更低。</p><h5 id="偏向锁的获取"><a href="#偏向锁的获取" class="headerlink" title="偏向锁的获取"></a>偏向锁的获取</h5><p>（1）访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。　　<br>（2）如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。　　<br>（3）如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。　　<br>（4）如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。　　<br>（5）执行同步代码。 </p><h5 id="偏向锁的释放"><a href="#偏向锁的释放" class="headerlink" title="偏向锁的释放"></a>偏向锁的释放</h5><p>偏向锁的释放在上面偏向锁的获取中的第4步已经提到过。偏向锁只有在遇到其它线程竞争偏向锁时，持有偏向锁的线程才会释放。线程是不会主动的去释放偏向锁的。偏向锁的释放需要等到全局安全点（在这个时间点上没有正在执行的字节码），它会首先去暂停拥有偏向锁的线程，撤销偏向锁，设置对象头中的Mark Word为无锁状态或轻量级锁状态，再恢复暂停的线程。</p><h5 id="偏向锁的关闭"><a href="#偏向锁的关闭" class="headerlink" title="偏向锁的关闭"></a>偏向锁的关闭</h5><p>偏向锁在Java6和Java7中是默认开启的，但它是在应用程序启动几秒后才激活。如果想消除延时立即开启，可以调整JVM参数来关闭延迟：-XX: BiasedLockingStartupDelay=0。如果你确定应用程序中没有偏向锁的存在，你也可以通过JVM参数关闭偏向锁： -XX:UseBiasedLocking=false，使用该参数后，程序会默认进入到轻量级锁状态。</p><h5 id="偏向锁的适用场景"><a href="#偏向锁的适用场景" class="headerlink" title="偏向锁的适用场景"></a>偏向锁的适用场景</h5><p>始终只有一个线程在执行同步块，在它没有执行完同步代码块释放锁之前，没有其它线程去执行同步块来竞争锁，在锁无竞争的情况下使用。一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁需要在全局安全点上，这个时候会导致Stop The World，Stop The Wrold 会导致性能下降，因此在高并发的场景下应当禁用偏向锁。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是有偏向锁竞争升级而来的。引入轻量级锁的目的是在没有多线程竞争的情况下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><h5 id="轻量级锁的获取"><a href="#轻量级锁的获取" class="headerlink" title="轻量级锁的获取"></a>轻量级锁的获取</h5><p>（1）在代码进入同步代码块时，如果同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建了一个名为锁记录（Lock Record）的空间，用于存储对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。<br>（2）虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果更新成功，则表示获取到了锁，并将锁标志位设置为“00”（表示对象处于轻量级锁状态）。如果失败则执行（3）操作。<br>（3）虚拟机检查当前对象的Mark Wrod 是否指向当前线程的栈帧，如果是这说明当前线程已经持有了这个对象的锁，直接进入同步块继续运行；否则说明这个锁对象已经被其它线程持有，这是轻量级锁就要膨胀为重量级锁，锁标志的状态值变更为“10”，后面等待锁的线程也要进入阻塞状态。</p><h5 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h5><p>（1）使用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果成功，则同步过程完成。<br>（2）CAS替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p><p>轻量级锁能提升同步性能的依据是“对于绝大部分的锁，在整个同步周期都是不存在竞争的”如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发成了CAS操作，因此存在竞争的情况下，轻量级锁比传统的重量级做会更慢。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p><h4 id="偏向锁、轻量级锁的状态转换"><a href="#偏向锁、轻量级锁的状态转换" class="headerlink" title="偏向锁、轻量级锁的状态转换"></a>偏向锁、轻量级锁的状态转换</h4><p><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/%E5%81%8F%E5%90%91%E9%94%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png"  alt="偏向锁轻量级锁的状态转换"></p><h4 id="其它优化"><a href="#其它优化" class="headerlink" title="其它优化"></a>其它优化</h4><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>线程的挂起和恢复需要CPU从用户状态切换到核心状态，频繁的挂起和恢复会给系统的并发性能带来很大的压力。同时我们发现在许多的应用上，共享该数据的锁定只会持续很短的一段时间，为了这一段很短的时间，让线程频繁的挂起和恢复是很不值得的，因此引入了自旋锁。<br>自旋锁的原理非常的简单，如果那些持有锁的线程能够在很短的时间释放资源，那么那些等待竞争锁的线程就不需要做用户状态和内核状态的切换进入阻塞挂起状态，它们只需要“稍等一下”，等待持有锁的线程释放资源后立即获取锁。这里需要注意的是，线程在自旋的过程中，是不会放弃CPU的执行时间的，因此如果锁被占用的时间很长，那么自旋的线程不做任何有用的工作从而浪费了CPU的资源。所有自旋等待时间必须有一个限制，如果自旋超过了限定的次数仍然没有获取锁，则需要停止自旋进入阻塞状态。虚拟机设定的自旋次数默认是10次，可以通过 -XX：PreBlockSpin来更改。</p><h5 id="自适自旋锁"><a href="#自适自旋锁" class="headerlink" title="自适自旋锁"></a>自适自旋锁</h5><p>上面说到自旋锁的自旋次数是一个固定的值，但是这个自旋次数应该如何限定了，设置大了会让线程一直占用CPU时间浪费性能，设置低了会让线程频繁的进入挂起和恢复状态也会浪费性能。因此JDK在1.6中引入了自适应自旋锁，自适应说明自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定的。</p><p>自适应自旋锁的原理也非常简单，当一个线程在一把锁上自旋成功，那么下一次在这个锁上自旋的时间将更长，因为虚拟机认为上次自旋成功了，那么这次自旋也有可能再次成功。反之，如果一个线程在一个锁上很少自旋成功，那么以后这个线程要获取这个锁时，自旋的此时将会减少甚至可能省略自旋的过程，直接进入阻塞状态以免浪费CPU的资源。</p><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据是逃逸分析的数据支持。变量是否逃逸对于虚拟机来说需要使用数据流来分析，但是对于我们程序员应该是很清楚的，怎么会在知道不存在数据竞争的情况下使用同步呢？但是程序有时并不是我们想的那样，虽然我们没有显示的使用锁，但是在使用一些Java 的API时，会存在隐式加锁的情况。例如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道每个sb.append()方法中都有一个同步块，锁就是sb的对象。因此虚拟机在运行这段代码时，会监测到sb这个变量永远不会“逃逸”到concat()方法之外，因此虚拟机就会消除这段代码中的锁而直接执行了。</p><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>我们知道在使用同步锁的时候，需要尽量将同步块的作用范围限制的尽量小一些—-只在共享数据的实际作用域中才进行同步，这样做的目的是为了使同步的时间尽可能的缩短，如果存在锁的竞争，那么等待锁的线程也能尽快的获取到锁。</p><p>大多数情况下，上面的的原则都是正确的。但是如果一系列的连续操作都对同一个对象反复的加锁，甚至加锁出现在循环体中，那么即使没有竞争，频繁的进行互斥同步操作也会导致不必须的性能损耗。所以引入了锁粗化的概率。</p><p>那么什么是锁粗化呢？锁粗化就是将连接加锁、解锁的过程连接在一起，扩展（粗化）成为一个同步范围更大的锁。以上面代码为例，就是扩展到第一个append()操作之前，直至最后一个append()操作之后，这样只需要加锁一次就可以了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文重点探究了synchronized的实现原理，以及JDK引入偏向锁和轻量级锁对synchronized所做的优化处理，和一些其他的锁的优化处理。我们最后来总结一下synchronized的执行过程： </p><ol><li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁 。</li><li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1 。</li><li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。 </li><li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁 。</li><li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 </li><li>如果自旋成功则依然处于轻量级状态。 </li><li>如果自旋失败，则升级为重量级锁。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程的启动和终止</title>
      <link href="/java-thread-startup-and-termination/"/>
      <url>/java-thread-startup-and-termination/</url>
      
        <content type="html"><![CDATA[<p>在Java中我们启动线程都是调用Thread类中的start()方法来启动，当线程处理完<code>run()</code>方法里面的逻辑后自动终止。但是在调用<code>start()</code>方法之前，我们需要先构建一个Thread对象，一般我们都是直接使用Thread类的构造函数来创建一个线程对象，Thread构造函数定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread(Runnable target, AccessControlContext acc) &#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>, acc, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target)</span> </span>&#123;</span><br><span class="line">    init(group, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, String name)</span> </span>&#123;</span><br><span class="line">    init(group, <span class="keyword">null</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target, String name)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name)</span> </span>&#123;</span><br><span class="line">    init(group, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(group, target, name, stackSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到在Thread类中定义了这么多的构造函数，但是这些构造函数都是调用<code>init()</code>方法来完成Thread对象的构建，<code>init()</code>方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g  线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target   调用run方法的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name    创建新线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize   构建新线程所需要的堆栈大小   stackSize的值为0时，表示忽略这个参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc          上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritThreadLocals  是否继承thread-locals</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize, AccessControlContext acc,<span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="comment">//构建线程的父线程就是当前正在运行的线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果线程组为空，则尝试用父线程的线程组</span></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//安全检查</span></span><br><span class="line">    g.checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加线程组中未启动线程的数量</span></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="comment">//继承父线程的Daemon属性</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="comment">//继承父线程的优先级</span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="comment">//构建合适的类加载器</span></span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给新线程分配一个ID</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从init方法中我们看到，线程daemon属性、线程的优先级、资源加载的contextClassLoader以及可继承的ThreadLocal都是继承自父线程。从这里也也验证了前面文章中提到的线程优先级的继承性。在init()方法执行完毕后，一个线程对象就被构建出来了，它存放在堆内存中等待调用start()方法启动。start()方法在Thread类中的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 构建线程threadStatus默认值为0</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知线程组，该线程即将开始启动，将该现场添加到线程组中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                <span class="comment">//启动线程失败，将该线程从线程组中移除</span></span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果线程已经销毁，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程组为空，初始化线程组</span></span><br><span class="line">        <span class="keyword">if</span> (threads == <span class="keyword">null</span>) &#123;</span><br><span class="line">            threads = <span class="keyword">new</span> Thread[<span class="number">4</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nthreads == threads.length) &#123;</span><br><span class="line">            <span class="comment">//线程组已经满，则扩容，扩容的大小为原来的2倍</span></span><br><span class="line">            threads = Arrays.copyOf(threads, nthreads * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将线程添加到线程组中</span></span><br><span class="line">        threads[nthreads] = t;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程数量加一</span></span><br><span class="line">        nthreads++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为启动的线程数量减一</span></span><br><span class="line">        nUnstartedThreads--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadStartFailed</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        remove(t);</span><br><span class="line">        nUnstartedThreads++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nthreads; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (threads[i] == t) &#123;</span><br><span class="line">                System.arraycopy(threads, i + <span class="number">1</span>, threads, i, --nthreads - i);</span><br><span class="line">                threads[nthreads] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码中，我们可以看出start()方法最终是调用本地方法start0()方法启动线程的。那么start0()这个本地方法具体做了那些事情呢，它主要完成了将Thread在虚拟机中启动，执行构建Thread对象时重写的run()方法，修改threadStatus的值。<br>从上面start()方法的源码中可以看到，start()方法是不能被重复调用的，当重复调用start()方法时，会抛出IllegalThreadStateException异常。说完了线程的启动，我们再来说说线程的终止。</p><h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>我们在看Thread类的源码的时候，发现Thread类提供了stop()、suspend()和resume()方法来管理线程终止，暂停和恢复。但是这些方法在Thread类中被标记为废弃的方法，不推荐开发者使用这些方法。至于原因，小伙伴自己去查阅资料，这里LZ就不在赘述了。既然官方不推荐是用这么方法来终止线程，那我们应该应该用什么来代替呢？<br>stop()方法的替代方案是在线程对象的run方法中循环监视一个变量，这样我们就可以很优雅的终止线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadOne</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() / <span class="number">1000</span> + <span class="string">" 线程正在运行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadOne t = <span class="keyword">new</span> ThreadOne();</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        t.flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">1554371306</span> 线程正在运行</span><br><span class="line"><span class="number">1554371307</span> 线程正在运行</span><br><span class="line"><span class="number">1554371308</span> 线程正在运行</span><br><span class="line"><span class="number">1554371309</span> 线程正在运行</span><br><span class="line"><span class="number">1554371310</span> 线程正在运行</span><br></pre></td></tr></table></figure><p>从上面的示例中，我们可以看到线程在运行了5秒中后，自动关闭了。这是因为主线程在睡眠了5秒后，给ThreadOne类中的flag值赋予了false值。</p><p>suspend()和resume()方法的替代方案是使用等待/通知机制。等待/通知的方法是定义在Object类上面的，因此任何类都能实现等待/通知。等待/通知方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知一个在对象上等待的线程，使其从wait()方法返回，而从wait()方法返回的前提是需要获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 通知所有对象上等待的线程，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 超时等待，线程在对象上等待timeout毫秒，如果时间超过则直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 超时等待，超时等待的时间可以控制到纳秒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">// 线程在对象上等待，直到有其它的线程调用了notify()或者notifyAll()方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待/通知示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyAndWait</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        WaitThread waitThread = <span class="keyword">new</span> WaitThread(lock, <span class="string">"WaitThread"</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line"></span><br><span class="line">        NotifyThread notifyThread = <span class="keyword">new</span> NotifyThread(lock, <span class="string">"NotifyThread"</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitThread</span><span class="params">(Object lock, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行完成..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotifyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotifyThread</span><span class="params">(Object lock, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行..."</span>);</span><br><span class="line">            lock.notify();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行完成..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">WaitThread开始运行...</span><br><span class="line">NotifyThread开始运行...</span><br><span class="line">NotifyThread执行完成...</span><br><span class="line">WaitThread执行完成...</span><br></pre></td></tr></table></figure><p>从上面的示例代码中我们看到，当WaitThread线程调用start()方法并执行完了wait()方法后，将释放锁，然后NotifyThread获取到了锁，当通知线程执行了notify()方法后，将会通知等待在该锁上面的线程，当NotifyThread线程运行完成后，WaitThread线程将会重新恢复执行。<br>调用wait()方法和notify()方法需要注意一下几点：</p><ul><li>调用wait()或notify()方法之前需要获取到锁。</li><li>当调用wait()方法后，线程会立即释放锁。</li><li>当调用wait()方法后，线程将从运行状态转变为WAITING状态，线程进入等待队列中。</li><li>当调用notify()/notifyAll()方法后，线程不会立即释放锁，它必须在线程执行完后释放锁，wait线程才能获取到锁再次执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程简介</title>
      <link href="/java-multithreading-introduction/"/>
      <url>/java-multithreading-introduction/</url>
      
        <content type="html"><![CDATA[<p>多线程在Java程序中无处不在，在上一篇（<a href="http://zzwzdx.cn/java-thread/" target="_blank" rel="external nofollow noopener noreferrer">Java线程概念理解</a>）中我们看到就算是一个最简单的Java类中也涉及到了多线程，大家可能会疑惑，为什么一个这么简单的Java类中，却启动了那么多“无关”的线程，Java是不是将简单的问题搞复杂了呢？答案当然是否定了，这是因为正确的使用多线程能够将耗时的处理大大的缩减时间，能够让用户的体验更加友好。使用多线程的主要原因有以下几点：</p><ol><li>更多的处理器核心</li></ol><p>现代处理器的核数越来越多，以及多线程越来越广泛的使用，现代计算机越来越擅长并行计算。我们知道一个程序作为一个进程在运行，而一个进程可以创建多个线程，而一个线程在一个时刻只能运行在一个处理器核心上，试想一下一个单线程程序在运行时只能使用一个处理器核心，而再多的处理器核心也无法提升该程序的执行效率。</p><ol start="2"><li>更快的响应时间</li></ol><p>多线程能够给用户更快的响应时间，例如我们在做一些复杂的业务逻辑的时候，我们先可以给用户一个反馈，然后再将一些数据一致性不强的业务逻辑派发给其它线程去处理，这样一来就大大缩短了响应时间，提升了用户体验。</p><ol start="3"><li>更好的编程模型</li></ol><p>Java为多线程提供了良好的编程模型，使开发者能够更加专注于问题的解决，即为所遇到的问题建立合适的模型，而不是绞尽脑汁的如何将其多线程化。</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>线程优先级从低到高依次为1~10，在创建线程是可以使用<code>setPriority(int newPriority)</code>方法来设置线程等的优先级，默优先级位是5。线程的优先级控制的是线程获取时间片段的多少，也就是说优先级高的线程分配时间片的数量多于优先级低的线程。但是这也不是绝对的，因为不同的JVM和操作系统上，线程的规划会存在着差异，有些操作系统甚至会忽略线程优先级的设置，因此不要将线程的优先级作为线程的运行顺序以及程序的正确性的依赖。</p><h3 id="线程优先级设置"><a href="#线程优先级设置" class="headerlink" title="线程优先级设置"></a>线程优先级设置</h3><p>线程优先级在Thread类中的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程可以拥有的最小优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配个线程的默认优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程可以拥有的最大优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程组</span></span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="comment">//优先级范围检查</span></span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置线程优先级</span></span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终调用本地方法设置优先级</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setPriority0</span><span class="params">(<span class="keyword">int</span> newPriority)</span></span>;</span><br></pre></td></tr></table></figure><p>接下来我们看下线程优先级的特性：</p><ul><li><strong>线程优先级的继承性</strong>：如果一个线程A启动了线程B，那么线程B的优先级将会和线程A 的一致（线程B不显示的设置线程优先级）。</li><li><strong>线程优先级的随机性</strong>：优先级高的线程并不一定会先于优先级低的线程执行。</li></ul><p>下面我们来验证下线程优先级的这些特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriority</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread1 t1 = <span class="keyword">new</span> Thread1();</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">"main的线程优先级："</span> + Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"优先级："</span> + Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">main的线程优先级：<span class="number">5</span></span><br><span class="line">Thread-<span class="number">0</span>优先级：<span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriority</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            PriorityThread t = <span class="keyword">new</span> PriorityThread(<span class="string">"线程优先级"</span> + i);</span><br><span class="line">            t.setPriority(i);</span><br><span class="line">            t.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始执行...."</span>);</span><br><span class="line">        <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> addResult = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">                Random random = <span class="keyword">new</span> Random();</span><br><span class="line">                random.nextInt();</span><br><span class="line">                addResult = addResult + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"☆☆☆☆☆"</span> + Thread.currentThread().getName() + <span class="string">" use time="</span> + (endTime - beginTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">线程优先级<span class="number">9</span>开始执行....</span><br><span class="line">线程优先级<span class="number">10</span>开始执行....</span><br><span class="line">线程优先级<span class="number">7</span>开始执行....</span><br><span class="line">线程优先级<span class="number">8</span>开始执行....</span><br><span class="line">线程优先级<span class="number">5</span>开始执行....</span><br><span class="line">线程优先级<span class="number">6</span>开始执行....</span><br><span class="line">线程优先级<span class="number">4</span>开始执行....</span><br><span class="line">线程优先级<span class="number">3</span>开始执行....</span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">10</span> use time=<span class="number">157</span></span><br><span class="line">线程优先级<span class="number">2</span>开始执行....</span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">9</span> use time=<span class="number">226</span></span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">7</span> use time=<span class="number">273</span></span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">8</span> use time=<span class="number">274</span></span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">5</span> use time=<span class="number">354</span></span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">6</span> use time=<span class="number">369</span></span><br><span class="line">线程优先级<span class="number">1</span>开始执行....</span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">3</span> use time=<span class="number">572</span></span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">4</span> use time=<span class="number">580</span></span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">1</span> use time=<span class="number">223</span></span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">2</span> use time=<span class="number">455</span></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">线程优先级<span class="number">7</span>开始执行....</span><br><span class="line">线程优先级<span class="number">8</span>开始执行....</span><br><span class="line">线程优先级<span class="number">9</span>开始执行....</span><br><span class="line">线程优先级<span class="number">10</span>开始执行....</span><br><span class="line">线程优先级<span class="number">5</span>开始执行....</span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">9</span> use time=<span class="number">170</span></span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">10</span> use time=<span class="number">185</span></span><br><span class="line">线程优先级<span class="number">6</span>开始执行....</span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">7</span> use time=<span class="number">206</span></span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">8</span> use time=<span class="number">228</span></span><br><span class="line">线程优先级<span class="number">1</span>开始执行....</span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">5</span> use time=<span class="number">262</span></span><br><span class="line">线程优先级<span class="number">3</span>开始执行....</span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">6</span> use time=<span class="number">84</span></span><br><span class="line">线程优先级<span class="number">2</span>开始执行....</span><br><span class="line">线程优先级<span class="number">4</span>开始执行....</span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">4</span> use time=<span class="number">95</span></span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">3</span> use time=<span class="number">112</span></span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">2</span> use time=<span class="number">135</span></span><br><span class="line">☆☆☆☆☆线程优先级<span class="number">1</span> use time=<span class="number">230</span></span><br></pre></td></tr></table></figure><p>从上面2个例子，我们就验证了线程优先级的继承性和随机性。</p><h3 id="2、线程状态"><a href="#2、线程状态" class="headerlink" title="2、线程状态"></a>2、线程状态</h3><p>Java线程在运行的生命周期中可能处于以下几种状态，在给定的时刻，线程只能处于其中一种状态。线程状态如下：</p><ol><li><strong>NEW</strong>：初始状态，线程被构建，但是还没有调用start()方法。</li><li><strong>RUNNABLE</strong>：运行状态，Java线程将操作系统中<strong>就绪</strong>和<strong>运行</strong>两种状态笼统的称作<strong>运行中</strong>。</li><li><strong>BLOCKED</strong>：阻塞状态，表示线程阻塞于锁。</li><li><strong>WAITING</strong>：等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</li><li><strong>TIME_WAITING</strong>：超时等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的。</li><li><strong>TERMINATED</strong>：终止状态，表示当前线程已经执行完毕。</li></ol><p>我们用一个示例来深入的理解现在的状态，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeWaiting(), <span class="string">"TimeWaitingThread"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Waiting(), <span class="string">"WaitingThread"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用两个Blocked线程，一个获取锁成功，另一个被阻塞</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该线程不断地进行睡眠</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该线程在Waiting.class实例上等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(Waiting<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Waiting<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该线程在Blocked.class实例上加锁后，不会释放该锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Blocked<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开终端，输入“jps”,输出如下：<br>C:\Users\Administrator&gt;jps<br>15680 Jps<br>16160 ThreadState<br>10772<br>15492 Launcher<br>3196 Launcher</p><p>可以看到运行示例对应的进程ID是16160，接着在输入“jstack 16160”,部分输入如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jstack <span class="number">16160</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BlockedThread-2 线程阻塞在获取Blocked.class示例的锁上</span></span><br><span class="line">"BlockedThread-2" #14 prio=5 os_prio=0 tid=0x0000000019399000 nid=0x1dec waiting for monitor entry [0x000000001a00f000]</span><br><span class="line">  java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at com.zzw.juc.thread.ThreadState$Blocked.run(ThreadState.java:<span class="number">54</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x00000000d87c86a0</span>&gt; (a java.lang.Class <span class="keyword">for</span> com.zzw.juc.thread.ThreadState$Blocked)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  BlockedThread-1线程获取到了Blocked.class的锁</span></span><br><span class="line">"BlockedThread-1" #13 prio=5 os_prio=0 tid=0x0000000019394000 nid=0x3e58 waiting on condition [0x0000000019f0f000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at java.lang.Thread.sleep(Thread.java:<span class="number">340</span>)</span><br><span class="line">        at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class="number">386</span>)</span><br><span class="line">        at com.zzw.juc.thread.ThreadState$Blocked.run(ThreadState.java:<span class="number">54</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x00000000d87c86a0</span>&gt; (a java.lang.Class <span class="keyword">for</span> com.zzw.juc.thread.ThreadState$Blocked)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// WaitingThread线程在Waiting实例上等待</span></span><br><span class="line">"WaitingThread" #12 prio=5 os_prio=0 tid=0x00000000193a0000 nid=0x3ed0 in Object.wait() [0x0000000019e0f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;<span class="number">0x00000000d87c5910</span>&gt; (a java.lang.Class <span class="keyword">for</span> com.zzw.juc.thread.ThreadState$Waiting)</span><br><span class="line">        at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">        at com.zzw.juc.thread.ThreadState$Waiting.run(ThreadState.java:<span class="number">40</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x00000000d87c5910</span>&gt; (a java.lang.Class <span class="keyword">for</span> com.zzw.juc.thread.ThreadState$Waiting)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// TimeWaitingThread线程处于超时等待</span></span><br><span class="line">"TimeWaitingThread" #11 prio=5 os_prio=0 tid=0x0000000019393000 nid=0x38d8 waiting on condition [0x0000000019d0e000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at java.lang.Thread.sleep(Thread.java:<span class="number">340</span>)</span><br><span class="line">        at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class="number">386</span>)</span><br><span class="line">        at com.zzw.juc.thread.ThreadState$TimeWaiting.run(ThreadState.java:<span class="number">27</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure><p>通过上面的示例，我们大概了解了Java程序运行中线程状态的具体含义。线程在自身的生命周期中，并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变迁如下图所示：<br><img src="/" class="lazyload" data-src="https://gitee.com/zhangzwd/pic-bed/raw/master/blog/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png"  alt="Java线程状态"></p><p>从上图我们可以看到，线程创建后调用start()方法开始执行。当线程执行了waite()方法之后，线程进入了等待状态，进入到等待状态的线程需要其它线程的通知才能返回到运行状态。超时等待状态相当于在等待状态上增加了超时时间的限制，也就是说当超时时间到达是线程会从超时等待状态返回到运行状态。当线程在竞争锁失败时，会进入阻塞状态，当阻塞状态的线程竞争锁成功时，将进入运行状态。线程在执行完run()方法之后进入终止状态。<br><strong>注意：</strong> 这里说的竞争锁失败，是线程在进入synchronized关键字修饰的方法或者代码。而不是java并发包下的Lock接口实现的锁。在Lock锁竞争失败，线程进入的是等待状态，因为java并发包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。</p><h3 id="3-Deamon线程"><a href="#3-Deamon线程" class="headerlink" title="3 Deamon线程"></a>3 Deamon线程</h3><p>Deamon线程是一种支持型线程，它主要被用作程序中后台调度已经支持性工作。Deamon线程在主线程结束后将被直接关闭。可以通过Thread.setDaemon(true)方法将线程转换为Deamon线程。设置Deamon属性必须在线程启动之前设置，线程启动后设置的Deamon属性将不起作用。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程概念理解</title>
      <link href="/java-thread/"/>
      <url>/java-thread/</url>
      
        <content type="html"><![CDATA[<h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1 进程"></a>1 进程</h3><p>进程是现代操作系统资源调度和分配的基本单位。在现代操作系统中一个程序就是一个进程。每个进程都拥有一块独立的运行空间。例如在window系统中一个运行的exe程序就是一个进程。</p><h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2 线程"></a>2 线程</h3><p>线程是现代操作系统调度的最小单元，一个进程可以创建多个线程。一个线程拥有自己独立的堆栈、程序计数器和局部变量，线程共享进程的内存。</p><p>线程在Java程序中无时不在，就算只运行一个简单的java程序也有线程在运行，例如下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        ThreadMXBean threadMXBean =  ManagementFactory.getThreadMXBean();   </span><br><span class="line">        ThreadInfo[] threadInfos =  threadMXBean.dumpAllThreads(<span class="keyword">false</span>,<span class="keyword">false</span>);  </span><br><span class="line">        <span class="keyword">for</span> (ThreadInfo threadInfo:threadInfos)&#123;            </span><br><span class="line">            System.out.println(<span class="string">"["</span> + threadInfo.getThreadId() +                                                                   <span class="string">"]"</span>+threadInfo.getThreadName());       </span><br><span class="line">        &#125;   </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">output：</span><br><span class="line">[<span class="number">6</span>] Monitor Ctrl-Break</span><br><span class="line">[<span class="number">5</span>] Attach Listener</span><br><span class="line">[<span class="number">4</span>] Signal Dispatcher</span><br><span class="line">[<span class="number">3</span>] Finalizer</span><br><span class="line">[<span class="number">2</span>] Reference Handler</span><br><span class="line">[<span class="number">1</span>] main</span><br></pre></td></tr></table></figure><p>从上面输出我们可以看出，Java程序的入口main()方法实际上是由一个叫做“main”的线程在调用执行。</p><h3 id="3-Java中的线程"><a href="#3-Java中的线程" class="headerlink" title="3 Java中的线程"></a>3 Java中的线程</h3><p>Java中线程的创建有如下的几种方式：</p><ul><li>继承Thread类创建线程</li><li>实现Runnable接口创建线程</li><li>实现Callable接口通过FutureTask包装器来实现</li></ul><p>第一种和第二种是常用的无返回结果的线程实现方式，第三种则相对少见的有结果返回的线程实现方式。以上3种创建线程的方式可以分为两类，一类是继承Thread，另一类是实现接口。下面是3种创建线程和调用的案例：</p><h4 id="1、继承Thread"><a href="#1、继承Thread" class="headerlink" title="1、继承Thread"></a>1、继承Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadOne</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程开始执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadOne t = <span class="keyword">new</span> ThreadOne();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、实现Runnable接口"><a href="#2、实现Runnable接口" class="headerlink" title="2、实现Runnable接口"></a>2、实现Runnable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTwo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程开始执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTwo t = <span class="keyword">new</span> ThreadTwo();</span><br><span class="line">        Thread tt = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        tt.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、实现Callable接口"><a href="#3、实现Callable接口" class="headerlink" title="3、实现Callable接口"></a>3、实现Callable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadThree</span> <span class="keyword">implements</span> <span class="title">Callable</span> &lt; <span class="title">Integer</span> &gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,</span></span><br><span class="line"><span class="function">    InterruptedException </span>&#123;</span><br><span class="line">        ThreadThree t = <span class="keyword">new</span> ThreadThree();</span><br><span class="line">        FutureTask &lt; Integer &gt; ft = <span class="keyword">new</span> FutureTask &lt; &gt; (t);</span><br><span class="line">        Thread tt = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">        tt.start();</span><br><span class="line">        <span class="keyword">int</span> result = ft.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
